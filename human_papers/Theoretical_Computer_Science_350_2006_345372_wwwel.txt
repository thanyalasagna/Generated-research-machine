Theoretical Computer Science 350 (2006) 345â€“372
www.elsevier.com/locate/tcs
Games with winning conditions of high Borel complexity
Olivier Serreâˆ—
LIAFA, UniversitÃ© Paris VII, CNRS, 2, place Jussieu, case 7014 F-75251 Paris Cedex 05, France
Abstract
We ï¬rst consider inï¬nite two-player games on pushdown graphs. In previous work, Cachat et al. [Solving pushdown games with
a 3-winning condition, in: Proc. 11th Annu. Conf. of the European Association for Computer Science Logic, CSL 2002, Lecture
Notes in Computer Science, Vol. 2471, Springer, Berlin, 2002, pp. 322â€“336] have presented a winning decidable condition that
is 3-complete in the Borel hierarchy. This was the ï¬rst example of a decidable winning condition of such Borel complexity. We
extend this result by giving a family of decidable winning conditions of arbitrary ï¬nite Borel complexity. From this family, we
deduce a family of decidable winning conditions of arbitrary ï¬nite Borel complexity for games played on ï¬nite graphs. The problem
of deciding the winner for these conditions is shown to be non-elementary.
Â© 2005 Elsevier B.V. All rights reserved.
Keywords: Pushdown automata; Two-player games; Borel complexity
1. Introduction
Inï¬nite two-player games have been intensively studied in the last few years. One of the main motivations is the
strong relation that exists with veriï¬cation questions and controller synthesis. For instance, -calculus model checking
for ï¬nite graphs (respectively, for pushdown graphs) is polynomially equivalent to the problem of deciding the winner
in a game played on a ï¬nite graph [7] (respectively, on a pushdown graph [24]). In addition, constructing a winning
strategy is the same as synthesizing a discrete controller [1].
One important branch of game theory is developed in the framework of descriptive set theory in which the central
question is determinacy, that is, the existence of a winning strategy. One of the deepest results is due to Martin [15]
and states that, for Borel winning conditions, games are determined. In computer science, the games considered are in
general equipped with winning conditions of low Borel complexity and therefore trivially determined. Nevertheless,
deciding the winner is, in many cases, a difï¬cult problem. Since we are mostly interested in decidable games, it is
natural to ask whether there exist decidable games of arbitrary high ï¬nite Borel complexity.
For ï¬nite graphs and for the natural conditions appearing in veriï¬cation and model-checking, efï¬cient algorithms are
known to decide the winner and to compute the associated winning strategies [20,25,10,22]. These winning conditions
all belong to a low level of the Borel hierarchy, namely to the boolean closure of the Borel class 2.
 This research has been partially supported by the European Community Research Training Network â€œGames and Automata for Synthesis and
Validationâ€ (GAMES), (Contract HPRN-CT-2002-00283), see www.games.rwth-aachen.de.
âˆ—Tel.: +33 1 44 27 28 48; fax: +33 1 44 27 68 49.
E-mail address: serre@liafa.jussieu.fr.
0304-3975/$ - see front matter Â© 2005 Elsevier B.V. All rights reserved.
doi:10.1016/j.tcs.2005.10.024
346
O. Serre / Theoretical Computer Science 350 (2006) 345â€“372
In [21], Thomas proposes to study games with winning conditions of Borel level larger than 2. In the paper, we
focus on this topic and exhibit a family of winning conditions on pushdown games that have an arbitrary high Borel
complexity while remaining decidable.As a corollary, one obtains a similar result for games on ï¬nite graphs. In addition,
these games have effective winning strategies.
The ï¬rst results concerning high-level Borel conditions come from pushdown games. In this model, the game graph
is the inï¬nite graph of the conï¬gurations of a pushdown process. Walukiewicz has shown that parity games on such
graphs can be effectively solved [24]. For this model, winning conditions exploiting the inï¬nity of the stack become
natural. In [4], Cachat et al. have considered the following condition: Eve wins a play if and only if some conï¬guration
is inï¬nitely often visited. They have shown that it is a decidable winning condition belonging to 3. More recently,
Bouquet et al. have considered in [2] winning conditions that are boolean combinations of a BÃ¼chi condition with a
condition called unboundedness that requires the stack to be unbounded. Gimbert has used the elegant method from
[12] to study the boolean combination of a parity condition with unboundedness [9]. All these winning conditions are
closely related to the one of [4] and remain decidable [2,9]. A natural question was therefore to consider higher-level
winning conditions.
In this paper, we give a uniform answer to the question of [21] by providing a family of winning conditions of
increasing ï¬nite Borel complexity. The main idea is to require the stack to converge to some limit and then to have
additional conditions on the limit. To solve classical conditions on pushdown games, one method consists in reducing
the problem to a game on a ï¬nite graph [24,2]. We adapt this method and reduce the problem of deciding the winner in
a pushdown game to the problem of deciding the winner in another pushdown game, equipped with a lower winning
condition. Therefore, the proof goes by induction.
From the proofs we also infer the effectiveness of the winning strategies. Whereas for previously studied winning
conditions on pushdown games, the set of winning positions was regular, it is no longer the case here. The exact nature
of these sets remains open. We further show that the complexity of determining the winner for these high-level Borel
winning conditions is non-elementary and is elementary-hard. We also show that Eve has, from a winning position, a
persistent strategy, that is, a strategy using memory but such that the move given from some vertex is always the same
for a given play.
The paper is organized as follows. In Section 2, we start with basic deï¬nitions on games and introduce the family
of winning conditions that we will consider in the rest of the paper. In Section 3, we precisely characterize the Borel
complexity of these winning conditions. In Section 4, we give the decidability results and constructions of these games.
Remark that it gives a new proof of the decidability results of [4]. In Section 5, we show that the complexity of deciding
the winner for such winning conditions is non-elementary and is elementary-hard. Finally, in Section 6, we discuss
several points.
2. Deï¬nitions
2.1. Basic deï¬nitions
An alphabet A is a ï¬nite or inï¬nite set of letters. Aâˆ—denotes the set of ï¬nite words on A, A the set of inï¬nite words
on A and Aâˆthe set Aâˆ—âˆªA. The empty word is denoted by Îµ. For a word u, we denote its (possibly inï¬nite) length
by |u|. For i < |u|, we write u(i) for the ith letter of u.
Let u âˆˆAâˆ—and v âˆˆAâˆ. Then u is a preï¬x of v, denoted u âŠ‘v if there exists some word w âˆˆAâˆsuch that
v = u Â· w. For any word u âˆˆAâˆ, there exists a unique preï¬x of length k for all kâ©½|u|. This preï¬x is denoted
by uâ†¾k.
Deï¬nition 1 (Limit of a sequence of ï¬nite words). Let (ui)i â©¾0 âˆˆ(Aâˆ—)N be an inï¬nite sequence of words. The limit
limiâˆˆN ui of (ui)i â©¾0 is the maximal word satisfying the following: for each j, there exists an index r such that
the jth letter of limiâˆˆN ui equals the jth letter of up for every pâ©¾r. Note that limiâˆˆN ui can be either ï¬nite or
inï¬nite.
We recall now the classical notion of deterministic pushdown automaton. A deterministic pushdown automaton with
input from Aâˆis a tuple A = âŸ¨Q, , A, âŠ¥, qin, âŸ©, where Q is a ï¬nite set of states,  is a ï¬nite set of stack symbols,
O. Serre / Theoretical Computer Science 350 (2006) 345â€“372
347
âŠ¥âˆˆ is a special bottom-of-stack symbol, A is the ï¬nite input alphabet, qin âˆˆQ is the initial state and
 : Q Ã—  Ã— A â†’{skip(q), pop(q), push(q, ) | q âˆˆQ,  âˆˆ \ {âŠ¥}}
is the transition function. In addition, we require that for all q, qâ€² âˆˆQ, a âˆˆA, (q, âŠ¥, a) Ì¸= pop(qâ€²) (the bottom-of-
stack symbol is never removed).
A stack is an element of the set St = ( \ {âŠ¥})âˆ—Â· âŠ¥. A conï¬guration of A is a pair (q, ) with q âˆˆQ and  âˆˆSt.
Note that the top stack symbol in some conï¬guration (q, ) is the leftmost symbol of .
A conï¬guration (q, ), for some q âˆˆQ and  âˆˆSt, has a unique successor by some letter a âˆˆA, which is deï¬ned
as follows, depending on (q, , a):
â€¢ If (q, , a) = skip(qâ€²), it is (qâ€², ).
â€¢ If (q, , a) = pop(qâ€²), it is (qâ€², ).
â€¢ If (q, , a) = push(qâ€², â€²), it is (qâ€², â€²).
A run of A on a (possibly inï¬nite) word  = 01 Â· Â· Â· starts from the conï¬guration (qin, âŠ¥). A reads 0 and goes
to the successor of (qin, âŠ¥) by 0, then it reads 1 and goes to the successor of the current conï¬guration by 1, and
so on.
One can in addition equip such an automaton with a classical acceptance condition, for instance a parity condition.
In that case, one has a mapping col from Q to a ï¬nite set of colors C âŠ‚N. This coloring function naturally extends to
the set of conï¬gurations by setting col((q, )) = col(q). Finally, an inï¬nite word  is accepted by A, if and only if the
smallest color appearing inï¬nitely often in the run of A on  is even.
If A is a deterministic pushdown automaton equipped with a parity acceptance condition, we denote L(A) the
language accepted by A.
Let A be a deterministic pushdown automaton and let  be some inï¬nite word on the input alphabet of A. We say
that the stack of A is strictly unbounded when reading , if the sequence (i)i â©¾0 of stack contents in the run of A on
 is such that limiâˆˆN i is inï¬nite. Equivalently, we require that for all hâ©¾0, there is some index jh such that |i|â©¾h
for all i â©¾jh, and the limit of the stack is the inï¬nite word j0(0)j1(1)j2(2) Â· Â· Â· .
2.2. The classes (Cn(A))nâ©¾0
Now, let nâ©¾0 be some integer and let us consider a collection A1, . . . , An of deterministic pushdown automata
(if n = 0 this collection is considered to be empty). Let An+1 be a deterministic pushdown automaton equipped
with a parity acceptance condition. On input alphabet of A1, . . . , An+1, we require the following stack consistency
property:
For all 1â©½i â©½n, the input alphabet of Ai+1 is the stack alphabet of Ai.
Let A be the input alphabet of A1. We associate with A1, . . . , An, An+1 a language of inï¬nite words on the alphabet
A, that we denote L(A1 â–·Â· Â· Â· â–·An â–·An+1), and which is deï¬ned as follows:
â€¢ If n = 0, L(A1 â–·Â· Â· Â· â–·An â–·An+1) = L(An+1) is the language accepted by An+1.
â€¢ If n > 0, L(A1 â–·Â· Â· Â· â–·An â–·An+1) is the set of inï¬nite words 0 on the alphabet A such that:
â—¦When A1 reads 0, its stack is strictly unbounded and therefore the sequence of stack contents converges to some
limit 1.
â—¦1 âˆˆL(A2 â–·Â· Â· Â· â–·An â–·An+1).
Equivalently, a word 0 âˆˆA belongs to L(A1 â–·Â· Â· Â· â–·An â–·An+1) if and only if:
â€¢ For all 1â©½i â©½n, when Ai reads iâˆ’1, its stack is strictly unbounded and the sequence of stack contents converges
to some limit i.
â€¢ An+1 accepts n.
Fig. 1 illustrate the case where n = 3.
Finally, we denote by Cn(A) the class of languages L on some ï¬nite alphabet A such that L = (A1 â–·Â· Â· Â· â–·An â–·
An+1) for some collection of deterministic pushdown automata A1, . . . , An and some deterministic parity automaton
An+1. In particular C0(A) is the class of deterministic -context free languages on the alphabet A [5].
348
O. Serre / Theoretical Computer Science 350 (2006) 345â€“372
Fig. 1. The language L(A1 â–·A2 â–·A3 â–·A4).
In the sequel, when considering pushdown automata A1, . . . , An, An+1 used to deï¬ne a language as described above,
we will implicitly suppose that they are stack consistent.
2.3. Games
Let A be a ï¬nite alphabet and let G = (V, E) be a graph with edges labeled by letters in some alphabet A or by the
empty word Îµ, that is E âŠ†V Ã— (A âˆª{Îµ}) Ã— V . Let VE âˆªVA be a partition of V between two players Eve and Adam.
A game graph is such a tuple G = (VE, VA, E).
A two-player game on a game graph G is a pair G = (G, 	), where 	 is a winning condition, which can be of two
kinds:
â€¢ 	 is an internal winning condition if 	 âŠ†V .
â€¢ 	 is an external winning condition if 	 âŠ†Aâˆ.
A play from some vertex v0 proceeds as follows: if v0 âˆˆVE, Eve chooses a successor v1 and an edge (v0, a0, v1) âˆˆE.
Otherwise, it is Adamâ€™s turn to choose a successor v1 and an edge. If there is no such v1, then the play ends in v0,
otherwise the player to whom v1 belongs tries to move to some v2 and so on. Therefore, a play starting from v0 is a
ï¬nite or inï¬nite sequence 
 = v0a0v1a1v2 Â· Â· Â· âˆˆV ((A âˆª{Îµ})V )âˆsuch that (vi, ai, vi+1) âˆˆE for all i. In the case
where the play is ï¬nite, we require that there is no (vn, an, vn+1) âˆˆE, if vn was the last vertex of the play. A partial
play is any preï¬x of a play.
A ï¬nite play is lost by the player that cannot move. An inï¬nite play 
 = v0a0v1a1v2 Â· Â· Â· is won by Eve if and only if:
â€¢ 	 is internal and v0v1v2 Â· Â· Â· âˆˆ	.
â€¢ 	 is external and a0a1a2 Â· Â· Â· âˆˆ	.
For a play 
 = v0a0v1a1v2 Â· Â· Â· we denote by Lab(
) the word a0a1 Â· Â· Â· . For instance Lab(v0Îµv1bv2bv3Îµv4Îµv5a
v6Îµv7) = bba. Therefore, if 
 is a play in a game equipped with an external winning condition 	, it is won by Eve if
and only if Lab(
) âˆˆ	.
A strategy for Eve is a function assigning, to any partial play ending in some vertex v âˆˆVE, an edge (v, a, vâ€²) âˆˆE.
Eve respects a strategy f during some play 
 = v0a0v1a1v2 Â· Â· Â· if (vi, ai, vi+1) = f (v0a0 Â· Â· Â· vi), for all i â©¾0 such
that vi âˆˆVE. Finally a strategy for Eve is winning from some position v, if any play starting from v âˆˆV , where Eve
respects f , is won by her. A vertex v âˆˆV is winning for Eve if she has a winning strategy from v. Symmetrically, one
deï¬nes the strategies and the winning positions for Adam.
A game G is determined if, from any position, either Eve or Adam has a winning strategy.
2.4. Pushdown games
Pushdown processes provide a natural model for programs with recursive procedures. They are like pushdown
automata except that they are nondeterministic. In addition, in this model, the input word (and therefore the initial state
and acceptance condition) are ignored.
O. Serre / Theoretical Computer Science 350 (2006) 345â€“372
349
More formally, a pushdown process is a tuple P = âŸ¨Q, , âŠ¥, âŸ©where Q is a ï¬nite set of states,  is a ï¬nite stack
alphabet that contains a special bottom-of-stack symbol âŠ¥and
 : Q Ã—  â†’2({skip(q),pop(q),push(q,) | qâˆˆQ,âˆˆ\{âŠ¥}})
is the transition relation. As for pushdown automata, we require that, for all q âˆˆQ, (q, âŠ¥) does not contain any
element pop(qâ€²). Finally, the notions of stack and conï¬guration of a pushdown process are deï¬ned as for pushdown
automata.
From P, one deï¬nes an inï¬nite graph, denoted G = (V, E), whose vertices are the conï¬gurations of P, and edges
E are deï¬ned by the transition relation , i.e., from a vertex (p, ) one has:
â€¢ (q, ) whenever skip(q) âˆˆ(p, ).
â€¢ (q, ) whenever pop(q) âˆˆ(p, ).
â€¢ (q, â€²) whenever push(q, â€²) âˆˆ(p, ).
Finally, let QE âˆªQA be some partition of Q between Eve and Adam. It induces a natural partition VE âˆªVA of V by
setting VE = QE Ã— St and VA = QA Ã— St. The game graph G = (VE, VA, E) is called a pushdown game graph.
Note that in a pushdown game graph, the edges are not labeled. Therefore, we will equip them only with internal
winning conditions. Moreover, a play will be represented as a word on the alphabet V of vertices, and a strategy for
Eve will be a function f : V âˆ—VE â†’V .
For a vertex v = (q, ) of V, we deï¬ne |v| to be the length of . In a play 
 = v0v1v2 . . ., the stack is strictly
unbounded if the stack size converges to +âˆ. More formally we require that for all kâ©¾0, there exists some i such that:
for all j â©¾i, |vj| > k.
If the stack in a play 
 = v0v1 . . . is strictly unbounded, we will consider its limit, StLim
 = lim i, where for all
i â©¾0, vi = (pi, i) for some pi âˆˆQ and i âˆˆSt.
The following internal winning condition 	ubd = {
 | the stack is strictly unbounded in 
} is called the strict un-
boundedness winning condition. A pushdown game G = (G, 	ubd) is called a strict unboundedness pushdown game.
Remark 2. In [4], it is shown that it can be decided in Dexptime whether Eve has a winning strategy in a pushdown
game equipped with a winning condition requiring that some conï¬guration is inï¬nitely often visited. It is easily seen
that this condition is the dual condition of the strict unboundedness winning condition. Therefore, it is equivalent to
decide a strict unboundedness pushdown game. In Section 4.3, we show that our main result gives the one of [4] as a
corollary, hence provides a new proof.
Finally, let us mention the parity condition on pushdown games. Let col be a coloring function from Q into a ï¬nite
set of colors C âŠ‚N. This function is easily extended into a function from V in C by setting col((q, )) = col(q). The
parity condition is the internal winning condition deï¬ned by
	par =

v0v1 Â· Â· Â· | inf{c | âˆƒâˆi s.t. col(vi) = c} is even

.
2.5. The winning conditions 	int
A1 â–·Â·Â·Â· â–·An â–·An+1 and 	ext
A1 â–·Â·Â·Â· â–·An â–·An+1
Let nâ©¾0 be some integer and let A1, . . . , An, An+1 be some pushdown automata where in addition An+1 is equipped
with a parity condition. Let  be the input alphabet of A1. From A1, . . . , An, An+1, we deï¬ne two winning conditions,
an external one that will be used for games played on ï¬nite graphs, and an internal one for pushdown games. It will be
shown later that they are closely related.
Deï¬nition 3. The external winning condition 	ext
A1 â–·Â·Â·Â· â–·An â–·An+1, is deï¬ned by
	ext
A1 â–·Â·Â·Â· â–·An â–·An+1 = L(A1 â–·Â· Â· Â· â–·An â–·An+1).
Deï¬nition 4. Let G be a pushdown game graph constructed from some pushdown process with  as stack alphabet.
Then 	int
A1 â–·Â·Â·Â· â–·An â–·An+1 is deï¬ned by
	int
A1 â–·Â·Â·Â· â–·An â–·An+1 = {
 âˆˆ	ubd | lim 
 âˆˆL(A1 â–·Â· Â· Â· â–·An â–·An+1)}.
350
O. Serre / Theoretical Computer Science 350 (2006) 345â€“372
Example 5. We ï¬nish with examples of such winning conditions:
(1) Let A be some parity automaton accepting all inï¬nite words on some alphabet . Then the winning condition 	int
A
is the strict unboundedness winning condition.
(2) Consider the deterministic parity pushdown automaton A that accepts the language { âˆˆ{p, c, t} | âˆ€kâ©¾0, |â†¾k|c
â©½|â†¾k|p} of words  on the alphabet {c, p, t} such that in any preï¬x of , the number of p is greater than the number
of c (|u|a designates the number of occurrences of some letter a in some word u). If p stands for produced, c for
consumed and t for transform, the winning condition 	int
A expresses that, in a system using recursive procedure
and such that at the end of the main procedure (where all recursive calls end), some resource may be produced,
consumed or transformed (which is also recorded in the stack by pushing either p, c or t), there is always an
available resource when the consumer asks for it.
3. Borel complexity
3.1. Borel hierarchy
Let A be a (possibly inï¬nite) alphabet. We consider the set A of inï¬nite words on the alphabet A, and we equip it
with the usual Cantor topology where the open sets are those of the form W Â· A where W âŠ†Aâˆ—is a language of ï¬nite
words on the alphabet A. The ï¬nite Borel hierarchy (1, 1), (2, 2), . . . is inductively deï¬ned as follows:
â€¢ 1 = {W Â· A | W âŠ†Aâˆ—} is the set of open sets.
â€¢ For all nâ©¾1, n = {Sco | S âˆˆn} consists of the complements of n-sets.
â€¢ For all nâ©¾1, n+1 =

iâˆˆN Si
 âˆ€i âˆˆN, Si âˆˆn

is the set of countable union of n-sets.
Finally, if we denote by B(n) the Boolean combination of n-sets, we have the following strict inclusions:
A set S is a proper-n-set if it is in n but not in n.
3.2. Borel complexity of a winning condition
Let G = (G, 	) be some game played on a game graph G and equipped with a winning condition 	. The Borel
complexity of the winning condition 	 is its Borel complexity when considered as a set on the alphabet of the vertices
of G if 	 is internal, and on the alphabet A that labels the edges of G if 	 is external.
Here are some examples of internal winning conditions:
Example 6. (1) Consider a reachability winning condition (Eve wins if and only if the play eventually visits a vertex
in some subset F âŠ†V ). Such a condition is a 1-winning condition, as the winning condition for Eve is (V âˆ—F)V .
(2) Consider a BÃ¼chi winning condition (Eve wins if and only if the play inï¬nitely visits vertices belonging to some
subset F âŠ†V ). Such a condition is a 2-winning condition, as the winning condition for Eve is 
nâ©¾0[(V nV âˆ—F)V ].
(3) Consider a Muller condition (Eve wins if and only if the set of inï¬nitely visited vertices belongs to a set of
subsets of V). Such a winning condition is a B(2)-winning condition, as it is a Boolean combination of BÃ¼chi winning
conditions.
O. Serre / Theoretical Computer Science 350 (2006) 345â€“372
351
(4) Consider an unboundedness winning condition for pushdown games (Eve wins if and only if the stack size is
not bounded). Such a condition is a 2-winning condition. Indeed, for any nâ©¾0, if one denotes by Vn the set of
conï¬gurations of stack size n, the winning condition for Eve is 
nâ©¾0[(V âˆ—Vn)V ].
(5) Consider a strict unboundedness winning condition for pushdown games (Eve wins if and only if the stack
size converges to âˆ). The corresponding condition for Adam is the one considered in [4]: Adam wins if and only
if some conï¬guration (equivalently some stack size) is inï¬nitely repeated. Therefore, if one denotes by Vn the set of
conï¬gurations of stack size n, the winning condition for Adam is

nâ©¾0

mâ©¾0
[(V mV âˆ—Vn)V ].
Therefore, the winning condition for Adam is a 3-set, and thus the strict unboundedness winning condition is a
3-winning condition for Eve.
Finally, let us mention the well-known Martinâ€™s Borel determinacy theorem.
Theorem 7 (Martin [15]). Any game equipped with a Borel winning condition is determined.
3.3. Wadge games
Deï¬nition 8 (Wadge game [23]). Let A and B be two (possibly inï¬nite) alphabets. Let X âŠ†A and Y âŠ†B. The
Wadge game G(X, Y) is a two-player game between Alice and Bob. Alice ï¬rst chooses a letter a0 in A. Then, Bob
chooses a (possibly empty) ï¬nite word b0 âˆˆBâˆ—. ThenAlice chooses a letter a1, and Bob a word b1, and so on. Therefore
a play consists in writing an inï¬nite word  = a0a1 Â· Â· Â· for Alice, and writing a word  = b0b1 Â· Â· Â· for Bob. Bob wins
if and only if both  is inï¬nite, and  âˆˆX â‡” âˆˆY.
Notions of strategies, and winners in Wadge games are deï¬ned similarly. These games are strongly related to the
following notion.
Deï¬nition 9 (Wadge reduction). We say that X âŠ†A Wadge reduces to Y âŠ†B, denoted Xâ©½WY, if and only if
there exists a continuous function f : A â†’B such that X = f âˆ’1(Y). If Xâ©½WY and Y â©½WX, then we say that X
and Y are Wadge equivalent and we denote this by X â‰¡W Y.
Then, we have the following well-known result:
Proposition 10 (Wadge [23]). Bob has a winning strategy in the game G(X, Y) if and only if Xâ©½WY.
Example 11. Consider the language A on some non-empty alphabet A. Then A â©½wY for any non-empty set Y.
Indeed, a winning strategy for Bob in W(A, Y) consists in describing some word in Y.
Let A = {a, b}. Let X âŠ†A be a closed set and let Y = {a} âŠ†A. Then, Xâ©½wY. Indeed, Bob plays a if the
preï¬x played by Alice is a preï¬x of some word in X. Otherwise, he plays b. This strategy is winning as an inï¬nite word
is in a closed set X if and only if any preï¬x of the word is a preï¬x of some word in X (see [17]). Note that these two
examples stress the importance of the underlying alphabets.
The Wadge equivalence preserves the Borel hierarchy levels.
Proposition 12. Let X and Y be two Wadge equivalent sets. Then they belong to the same level of the Borel hierarchy.
Then, it is natural to consider the following completeness notion induced by the relation â©½W.
Deï¬nition 13 (Complete sets). A set Y âˆˆn is n-complete if and only if Xâ©½WY for all X âˆˆn. In particular, a
n-complete set is a proper n-set. One easily deï¬nes n-complete sets.
352
O. Serre / Theoretical Computer Science 350 (2006) 345â€“372
Remark 14. The notion of complete sets is not relevant for the class B(n), as there are no complete set for such a
class for nâ©¾1 [11].
Now, we give some examples to illustrate the completeness notion.
Example 15. Let A = {a, b}. Let X âŠ†A be the set of inï¬nite words that contains inï¬nitely many a. X is a 2-
complete set. Indeed X =

i â©¾0 AiAâˆ—aA, hence X is a 2-set. Let Y be a 2-set on some alphabet B. Therefore,
Y =

i â©¾0 Yi for some family (Yi)i â©¾0 of open sets, where Yi = ZiB. In the game G(Y, X), Bob has a winning
strategy that consists in maintaining some counter i which is initialized to 0. If the word already written by Alice is in
ZiBâˆ—, he plays a and changes his counter to i + 1. Otherwise, he plays b and does not change the value of his counter.
Therefore, the word played by Bob contains inï¬nitely many a if and only if the word played by Alice belongs to Yi for
all i â©¾0, that is, it belongs to Y.
3.4. The operation X â†’Xâˆ¼
In [6], Duparc introduces several Borel operations that are homomorphic to ordinal sum, to multiplication by a
countable ordinal and to ordinal exponentiation of base  (for some uncountable regular cardinal ). Here, we only
focus on the operation X â†’Xâˆ¼, which is the Borel counterpart of the ordinal exponentiation of base .
The operation X â†’Xâˆ¼works on sets X âŠ†Aâˆof ï¬nite or inï¬nite words on some alphabet A. Nevertheless, one
needs to transform ï¬nite words into inï¬nite words to deï¬ne the operation. In this paper, we will only use a consequence
of Duparcâ€™s results that works for languages of inï¬nite words. That is why we only describe the result in the framework
of languages of inï¬nite words.
Deï¬nition 16 (Dupare [6, deï¬nition 22]). Let A be some alphabet, let X âŠ†Aâˆ, and â†/âˆˆA (a symbol for â€œBack
Spaceâ€), then Xâˆ¼= {u âˆˆ(A âˆª{â†})âˆ| uâ†«âˆˆX} where uâ†«is inductively deï¬ned by
â€¢ Îµâ†«= Îµ
â€¢ for u ï¬nite with |uâ†«| = k:
â—¦(u Â· a)â†«= uâ†«Â· a if a Ì¸= â†.
â—¦(u Â· â†)â†«= uâ†«â†¾(kâˆ’1) if k > 0 (erases the last letter of uâ†«).
â—¦(u Â· â†)â†«= Îµ if k = 0 (there is nothing to erase).
â€¢ for u inï¬nite, uâ†«= limnâˆˆN((uâ†¾n)â†«).
For instance, abâ†â†c = aâ†c = c, bb(abâ†) = bba and bb(bâ†) = bb.
The operation X â†’Xâˆ¼has a very natural interpretation in terms of Wadge game. A player in charge of Xâˆ¼is
like a player in charge of X that can in addition erase symbols as often as he wants by simply playing the Back Space
letter â†.
The iterated version of the operation X â†’Xâˆ¼is deï¬ned as follows:
Deï¬nition 17. Let X be some set. Then, we deï¬ne Xâˆ¼0 = X and âˆ€n âˆˆN, Xâˆ¼n+1 = (Xâˆ¼n)âˆ¼.
In this paper, we use the following consequence of Lemma 31 of [6], that works for languages of inï¬nite words.
Lemma 18 (Finkel [8]). Let A be some alphabet and let X âŠ†A be some k-complete set for some kâ©¾2. Then,
(Xâˆ¼n) is a n+k-complete set, for all nâ©¾0.
Finally, let us give the following result due to LÃ¶ding [13].
Lemma 19. Let A be some alphabet and let X âŠ†A. If X âˆˆB(n) for nâ©¾2 then Lâˆ¼âˆˆB(n+1).
O. Serre / Theoretical Computer Science 350 (2006) 345â€“372
353
Proof. We start proving the result for open sets. For this, it sufï¬ces to prove it for some 1-complete set as the operation
X â†’Xâˆ¼respects the Wadge ordering â©½W [6]. Let us consider the language O = (aâˆ—b)A on the alphabet A = {a, b}
which is the complement of the 1-complete language a (see Example 11).
Then one has
Oâˆ¼=

nâ©¾0
((A âˆª{â†})nb(A âˆª{â†}) âˆ©Kn,
where Kn is the set of inï¬nite words  on the alphabet Aâˆª{â†} such that the nth letter of  is not erased when computing
â†«. More precisely,
Kn =
	
Hâ©¾n(A âˆª{â†})
co
where Hâ©¾n is the set of ï¬nite words u such that the nth letter of u is erased when computing nâ†«, that is u(n + 1)
Â· Â· Â· u(|n| âˆ’1) = vâ†vâ€² for some v such that vâ†«= Îµ.
Therefore, Kn is a 1-set and therefore Oâˆ¼is a 2-set.
Now, note that the operation X â†’Xâˆ¼on set of inï¬nite words distributes over intersection and union.
For complementation, in general, (Xco)âˆ¼âŠŠ(Xâˆ¼)co. Indeed, (Xâˆ¼)co also contains the words  such that â†«is ï¬nite.
Therefore (Xco)âˆ¼= (Xâˆ¼)co âˆ©Inf , where Inf is the set of words  âˆˆ(A âˆª{â†}) such that â†«is inï¬nite:
Inf =

mâ©¾0

nâ©¾m
Kn.
Hence, Inf is a 3-set.
Now, if X is some set in B(n) for some nâ©¾2, one applies the X â†’Xâˆ¼operation to the formula proving its member-
ship to B(n), pushes the preceding operation to the level of 1-sets and intersect with Inf whenever complementation
is used. In the resulting formula, all 1-sets have been changed into 2-sets, and therefore it shows that Xâˆ¼belongs to
B(n+1) (intersection with Inf does not increase the Borel complexity, as nâ©¾2).
â–¡
3.5. Borel complexity of L(A1 â–·Â· Â· Â· â–·An â–·An+1)
In this section, we study the Borel complexity of languages in the class Cn(A) for some ï¬nite alphabet A and some
integer nâ©¾0.
More precisely, we show the following result:
Theorem 20. Let A be some ï¬nite alphabet and let nâ©¾0 be some integer. Then a language in Cn(A) belongs to
B(n+2). In addition, there is a language in Cn(A) that is n+2-complete.
Note that for n = 0 the result is the classical one stating that a language recognized by some deterministic machine
equipped with a parity condition is in B(2) (the proof is a generalization of the one showing that -regular languages
are in B(2) [17]). For completeness, one can consider the -regular language on the alphabet {a, b} of inï¬nite words
containing inï¬nitely many occurrences of the letter a (see Example 15).
The proof of Theorem 20 goes by induction on n, and relies on the following lemma:
Lemma 21. Let nâ©¾1 and let A1, . . . , An be a collection of pushdown automata and let An+1 be a parity pushdown
automaton. Then L(A1 â–·Â· Â· Â· â–·An â–·An+1)â©½WL(A2 â–·Â· Â· Â· â–·An â–·An+1)âˆ¼.
In addition, there is some pushdown automaton A1 such that the preceding inequality is an equivalence.
Proof. Let X = L(A1 â–·Â· Â· Â· â–·An â–·An+1) and let Y = L(A2 â–·Â· Â· Â· â–·An â–·An+1)âˆ¼.
We show that Bob has a winning strategy in the Wadge game G(X, Y). Indeed, Bob plays so that when Alice has
played some word u, he has played a word v such that vâ†«is the stack content of A1 when having read u. Bob wins by
the very deï¬nition of X from Y, hence Xâ©½WY.
354
O. Serre / Theoretical Computer Science 350 (2006) 345â€“372
Now consider the special case where A1 = âŸ¨{q}, , , âŠ¥, q, âŸ©where:
â€¢  =  âˆª{â†} where â†/âˆˆ.
â€¢ For all  âˆˆ, (q, , â†) = pop(q) and (q, , a) = push(q, a), for a Ì¸= â†.
Then, if we consider â†as an eraser, we directly have that the stack contents of A1, after reading some word u, is uâ†«.
In addition, the stack limit of A1 after reading some inï¬nite word  is â†«. By deï¬nition of acceptance, an inï¬nite word
 âˆˆX if and only if the stack limit of A1 when reading  is inï¬nite and is in L(A2 â–·Â· Â· Â· â–·An â–·An+1). Therefore,
 âˆˆX if and only if â†«âˆˆL(A2 â–·Â· Â· Â· â–·An â–·An+1). This exactly means that X â‰¡W Y.
â–¡
Then, Theorem 20 follows from transitivity of â©½W, Lemmas 18 and 19, and from the basic case n = 0.
3.6. Borel complexity of 	int
A1 â–·Â·Â·Â· â–·An â–·An+1 and 	ext
A1 â–·Â·Â·Â· â–·An â–·An+1
In this section, we discuss the Borel complexity of the winning conditions of the form 	int
A1 â–·Â·Â·Â· â–·An â–·An+1 and
	ext
A1 â–·Â·Â·Â· â–·An â–·An+1.
For the external winning condition 	ext
A1 â–·Â·Â·Â· â–·An â–·An+1, we have the following corollary of Theorem 20.
Corollary 22. For all nâ©¾0 the following holds:
â€¢ For any collection of deterministic pushdown automata A1, . . . , An, and any parity pushdown automaton An+1,
	ext
A1 â–·Â·Â·Â· â–·An â–·An+1 is a B(n+2) external winning condition.
â€¢ There exists a collection of deterministic pushdown automata A1, . . . , An, and a parity pushdown automaton An+1
such that 	ext
A1 â–·Â·Â·Â· â–·An â–·An+1 is a n+2-complete internal winning condition.
For the internal winning condition 	int
A1 â–·Â·Â·Â· â–·An â–·An+1 on pushdown games, we have the following result.
Theorem 23. For all nâ©¾0 the following holds:
â€¢ For any collection of deterministic pushdown automata A1, . . . , An, and any parity pushdown automaton An+1,
	int
A1 â–·Â·Â·Â· â–·An â–·An+1 is a B(n+3) internal winning condition for pushdown games.
â€¢ There exists a collection of deterministic pushdown automata A1, . . . , An, and a parity pushdown automaton An+1
such that 	int
A1 â–·Â·Â·Â· â–·An â–·An+1 is a n+3-complete internal winning condition for pushdown games.
Theorem 23 is a consequence of Theorem 20 together with the following lemma:
Lemma 24. Let P be a pushdown process with stack alphabet  and associated with some pushdown game graph G
equipped with the winning condition 	int
A1 â–·Â·Â·Â· â–·An â–·An+1. Then
	int
A1 â–·Â·Â·Â· â–·An â–·An+1 â‰¡W L(A1 â–·Â· Â· Â· â–·An â–·An+1)âˆ¼.
Proof. Let X = 	int
A1 â–·Â·Â·Â· â–·An â–·An+1 and Y = L(A1 â–·Â· Â· Â· â–·An â–·An+1)âˆ¼.
Consider the Wadge game W(X, Y). A winning strategy for Bob consists in playing so that if u is the word he has
written since the beginning of the play, uâ†«equals the stack contents in the last conï¬guration (that is the last letter)
written by Alice.
Conversely, consider the Wadge game W(Y, X). The winning strategy for Bob is to write a conï¬guration which stack
contents equal to uâ†«, where u is the word already played by Alice.
â–¡
4. Decidability
In this section, we explain how to decide the winner in a game played on a ï¬nite game graph equipped with a winning
condition of the form 	ext
A1 â–·Â·Â·Â· â–·An â–·An+1 and in a pushdown game equipped with a winning condition of the form
	int
A1 â–·Â·Â·Â· â–·An â–·An+1. More precisely, we show the following result:
O. Serre / Theoretical Computer Science 350 (2006) 345â€“372
355
Theorem 25. Consider some integer nâ©¾0 and a collection A1, . . . , An, An+1 of pushdown automata where in
addition An+1 is equipped with a parity condition. Then the following holds:
â€¢ Let G be a ï¬nite game graph. Then, for any vertex v in G, it is decidable whether Eve has a winning strategy from v
in the game G = (G, 	ext
A1 â–·Â·Â·Â· â–·An â–·An+1).
â€¢ Let G be a pushdown game graph. Then, for any conï¬guration of the form (q, âŠ¥) in G, it is decidable whether Eve
has a winning strategy from (q, âŠ¥) in the game G = (G, 	int
A1 â–·Â·Â·Â· â–·An â–·An+1).
The proof follows from Theorems 26â€“28 that show how to transform a game on a ï¬nite game graph into an equivalent
pushdown game with a simpler winning condition, and how to transform a pushdown game into an equivalent game on
a ï¬nite game graph with a winning condition of the same complexity. Thus, several transformations yield a pushdown
game with a parity winning condition, a problem known to be decidable [24].
4.1. From a game on a ï¬nite game graph to a pushdown game
In this subsection, we consider a ï¬nite game graph G = (VE, VA, E) with edges labeled by letters on some al-
phabet A or by the empty word Îµ, and we set V = VE âˆªVA. We also consider some integer nâ©¾0, and a collection
A1, . . . , An, An+1 of pushdown automata, where in addition An+1 is equipped with a parity condition and such that
A is the input alphabet of A1. Finally, we consider an initial vertex vin âˆˆV .
We construct a pushdown game equipped with the winning condition 	int
A2 â–·Â·Â·Â· â–·An â–·An+1 if nâ©¾1, and with a parity
condition if n = 0. In addition, we show that there is a position in that game such that it is winning for Eve if and only
if vin is winning for Eve in the game G = (G, 	ext
A1 â–·Â·Â·Â· â–·An â–·An+1).
From G and A1 = âŸ¨Q, , A, âŠ¥, qin, âŸ©, we deï¬ne the following pushdown process P = âŸ¨Q Ã— V, , âŠ¥, âŸ©
where:
â€¢ skip((qâ€², vâ€²)) âˆˆ((q, v), ) if and only if there is some a âˆˆA such that (v, a, vâ€²) âˆˆE and (q, , a) = skip(qâ€²), or
(v, Îµ, vâ€²) âˆˆE and q = qâ€².
â€¢ pop((qâ€², vâ€²)) âˆˆ((q, v), ) if and only if there is some a âˆˆA such that (v, a, vâ€²) âˆˆE and (q, , a) = pop(qâ€²).
â€¢ push((qâ€², vâ€²), â€²) âˆˆ((q, v), ) if and only if there is some a âˆˆA such that (v, a, vâ€²) âˆˆE and (q, , a)
= push(qâ€², â€²).
We consider the partition QÃ—VE âˆªQÃ—VA of QÃ—V , and denote by G the pushdown game graph induced by P and the
preceding partition. Intuitively, G encodes on-the-ï¬‚y computations of A1 on plays in G. Then, we have the following
result.
Theorem 26. If nâ©¾1, for any vertex vin âˆˆV , Eve has a winning strategy in G = (G, 	ext
A1 â–·Â·Â·Â· â–·An â–·An+1) from vin if
and only if she has a winning strategy in G = (G, 	int
A2 â–·Â·Â·Â· â–·An â–·An+1) from ((vin, qin), âŠ¥).
Proof. Assume that Eve has a winning strategy f from vin in G. We deï¬ne a strategy f in G from ((qin, vin), âŠ¥). As
G encodes an on-the-ï¬‚y computation of A1 on a play in G, f will reconstruct a play in G (using some function ), and
use the value of f on it, to compute the move to play, and use  to update the stack and the ï¬rst component of the
control state.
Let 
 be a partial play in G starting from ((qin, vin), âŠ¥) and let (
) be inductively deï¬ned by:
â€¢ If 
 = ((qin, vin), âŠ¥), then (
) = vin.
â€¢ If 
 = 
â€² Â· ((qâ€², vâ€²), â€²), then, let ((q, v), ) be the last vertex of 
â€². Then (
) = (
â€²) Â· a Â· vâ€² for some a âˆˆA âˆª{Îµ}
such that (v, a, vâ€²) âˆˆE and (qâ€², â€²) is the successor of (q, ) by a in A1. Note that by construction of P, (
) is
always deï¬ned (and may not be unique).
Now, for any partial play 
 ending in some conï¬guration ((q, v), ), we set f (
) = ((qâ€², vâ€²), â€²) where (v, a, vâ€²) =
f ((
)) for some a âˆˆA âˆª{Îµ}, and where (qâ€², â€²) is the successor by a of (q, ) in A1.
356
O. Serre / Theoretical Computer Science 350 (2006) 345â€“372
Now, it is easily seen that any partial play 
 in G starting from ((qin, vin), âŠ¥) where Eve respects f is such that:
(1) (
) is a play in G starting from vin where Eve respects f .
(2) The run of A1 on Lab((
)) ends in the conï¬guration (q, ) where the last vertex of 
 is of the form ((q, v), ) for
some v âˆˆV .
Now, we conclude that a play 
 in G, where Eve respects f , is winning for her. If the play is ï¬nite then the ï¬rst point
allows us to conclude that the player who cannot move is Adam. If 
 is inï¬nite, (
) is won by Eve, and therefore
the stack of A1 when reading Lab((
)) is unbounded and has its limits in L(A2 â–·Â· Â· Â· â–·An â–·An+1). Therefore, the
stack in 
 is unbounded and its limit is in L(A2 â–·Â· Â· Â· â–·An â–·An+1). Thus 
 âˆˆ	int
A2 â–·Â·Â·Â· â–·An â–·An+1.
Conversely, assume that Eve has a winning strategy f from ((qin, vin), âŠ¥) in G. Let 
 be a partial play in G starting
from vin and let (
) be inductively deï¬ned by
â€¢ If 
 = vin, then (
) = ((qin, vin), âŠ¥).
â€¢ If 
 = 
â€² Â· a Â· vâ€², then, let ((q, v), ) be the last vertex of (
â€²). Then (
) = (
â€²) Â· ((qâ€², vâ€²), â€²) where (qâ€², â€²) is
the successor by a of (q, ) in A1.
Now, for any partial play 
 ending in some conï¬guration v, we set f (
) = (v, a, vâ€²) where ((qâ€², vâ€²), â€²) = f ((
)) and
a âˆˆAâˆª{Îµ} is such that (qâ€², â€²) is the successor in A1 by a of (q, ), where ((q, v), ) designates the last conï¬guration
of (
). Note that, by deï¬nition of 
, such an a always exists (and may not be unique).
Now, it is easily seen that any partial play 
 in G starting from vin where Eve respects f is such that:
(1) (
) is a play in G starting from ((vin, qin), âŠ¥) where Eve respects f .
(2) The run of A1 on Lab(
) ends in the conï¬guration (q, ) where the last vertex of (
) is of the form ((q, v), ),
for some v âˆˆV .
Now, we easily conclude that a play 
 in G, where Eve respects f , is winning for her. If the play is ï¬nite then the
ï¬rst point allows to conclude that the player who cannot move is Adam. If 
 is inï¬nite, (
) is won by Eve, and
therefore the stack is unbounded in (
) and its limits is in L(A2 â–·Â· Â· Â· â–·An â–·An+1). Therefore, the stack of A1
when reading Lab(
) is unbounded and its limit is in L(A2 â–·Â· Â· Â· â–·An â–·An+1). Thus 
 is winning for the external
condition 	ext
A1 â–·Â·Â·Â· â–·An â–·An+1.
â–¡
For the case where n = 0, A1 is equipped with a coloring function col : Q â†’C. Therefore, we extend col into a
function col : Q Ã— V â†’C by setting col(q, v) = col(q). We denote by G the pushdown parity game played on G and
induced by col. Then, using the same techniques as for Theorem 26, we prove the following result:
Theorem 27. For any vertex vin âˆˆV , Eve has a winning strategy in G = (G, 	ext
A1) from vin if and only if she has a
winning strategy in the parity pushdown game G from ((vin, qin), âŠ¥).
4.2. From a pushdown game to a game on a ï¬nite game graph
In this section, we consider a pushdown process P = âŸ¨Q, , âŠ¥, âŸ©together with a partition QEâˆªQA of Q. The asso-
ciated pushdown game graph is denoted by G. We also consider some integer nâ©¾0 and a collection A1, . . . , An, An+1
of pushdown automata where in addition An+1 is equipped with a parity condition and such that  is the input alphabet
of A1. Finally, we set G = (G, 	int
A1 â–·Â·Â·Â· â–·An â–·An+1) and we consider an initial conï¬guration (pin, âŠ¥) in G.
We now construct a ï¬nite game graph G with the external winning condition 	ext
A1 â–·Â·Â·Â· â–·An â–·An+1, such that Eve has a
winning strategy in G from (pin, âŠ¥) if and only if she has a winning strategy in G from some special vertex. Intuitively,
in G, we keep track only of the control state and the symbol on the top of the stack. The interesting aspect of the game
is when it is in a control state p with top-of-stack , and the player owning p wants to push a letter â€² onto the stack.
Consider the set of all (ï¬nite) continuations of the play that will end with popping this â€² symbol from the stack. We
require Eve to declare the set of all states the game can be in after the popping of â€² along these plays. Note that since
itâ€™s a game, Eve does not have complete control, hence she cannot give one exact state, but can only give the set of
possible states the game could be in at the corresponding pop. Let this set be R.
O. Serre / Theoretical Computer Science 350 (2006) 345â€“372
357
Fig. 2. Local structure of G: oval vertices belong to Eve, square for Adam.
Adam now has two choices. He can either continue the game by pushing â€² onto the stack and updating the state (we
call this a pursue move), or he can pick some state pâ€²â€² âˆˆR and continue from that state, leaving  on the top of the
stack (we call this a jump move). If he makes a pursue move, then he remembers R, and makes sure that if there is a
pop-transition on â€² later in the play, then the resulting state is indeed in R (if it is not, Eve would lose the game). If
along a play such a pop-transition on â€² is indeed met, and the resulting state is in R, then the play stops right there and
Eve is declared the winner.
Now consider an inï¬nite play in this game, that is a play that never simulates a pop-transition. In such a play,
a pursue move corresponds to a new letter pushed forever on the stack. Therefore, if there are only ï¬nitely many
pursue moves, the stack is not strictly unbounded (some stack level is inï¬nitely often visited), and therefore the play
will be lost for Eve. If it goes inï¬nitely often through pursue moves, the stack is strictly unbounded and its limit is
obtained by considering the word which letters are the top stack symbols just before pursue moves. Hence, the winning
condition becomes external, if we label the pursue move by the top stack symbol in the conï¬guration just before the
pursue move.
Let us now describe the construction more precisely. The structure of the ï¬nite game graph G is depicted in Fig. 2.
The main vertices of G are tuples in Q Ã—  Ã— 2Q. A vertex (p, , R) belongs to Eve if and only if p âˆˆQE.
Intuitively, a vertex (p, , R) denotes that p is the current state,  is the symbol on the top of the stack and R is the
current commitment Eve has made, i.e. Eve has previously claimed that if there is a pop- transition, then the state will
be in R. The starting vertex is (pin, âŠ¥, âˆ…) (the bottom-of-stack symbol will never be popped, and therefore the third
component is âˆ…).
In order to simulate an internal-transition skip(pâ€²) âˆˆ(p, ), we have edges in G of the form ((p, , R), Îµ, (pâ€², , R)),
for all R âŠ†Q.
Pop-transitions are not simulated. From any vertex (p, , R), we have a transition to tt if âˆƒr âˆˆR such that pop(r) âˆˆ
(p, ) (showing that R was correctly deï¬ned with respect to this transition).Also, we have a transition to ff , if âˆƒr /âˆˆR
such that pop(r) âˆˆ(p, ) (showing that R was not correctly deï¬ned with respect to this transition).
The simulation of a push-transition goes in several steps. Let (p, , R) be a vertex. The player owning p ï¬rst picks a
particular push-transition push(pâ€², â€²) âˆˆ(p, ) by moving (through an edge labeled by Îµ) to the vertex (p, , R, pâ€², â€²),
which belongs to Eve. Then Eve proposes a set Râ€² âŠ†Q containing the states that she claims to be reached if â€² gets
eventually popped. She does this by moving (through an edge labeled by Îµ) to the vertex (p, , R, pâ€², â€², Râ€²), which
belongs to Adam.
Now, Adam has two kinds of choices. He can do a jump move by picking a state pâ€²â€² âˆˆRâ€², and move to the vertex
(pâ€²â€², , R) through an edge labeled by Îµ. Or he can do a pursue move by moving to the vertex (pâ€², â€², Râ€²) through an
edge labeled by . Note that these last edges are the only ones that are not labeled by Îµ.
358
O. Serre / Theoretical Computer Science 350 (2006) 345â€“372
Now we have the following result:
Theorem 28. Eve has a winning strategy from (pin, âŠ¥) in G if and only if she has a winning strategy from (pin, âŠ¥, âˆ…)
in G = (G, 	ext
A1 â–·Â·Â·Â· â–·An â–·An+1).
Before starting the proof, we introduce two notations. Let 
 be some play in G, we set Steps
 = {n âˆˆN | âˆ€mâ©¾n,
|
(m)|â©¾|
(n)|}, where |
(n)| is the size of the stack when being in the conï¬guration 
(n). Therefore Steps
 is the set
of indexes corresponding to positions where the stack height will not decrease later on the play.
Let 
 be some play in G, we set Steps
 = {n âˆˆN | 
(n) = (p, , R), for some p âˆˆQ,  âˆˆ, R âŠ†Q}. Therefore
Steps
 is the set of indexes corresponding to positions where the play is in one of the main vertices of G.
4.2.1. From G to G
Assume that (pin, âŠ¥) is winning for Eve in the game G. This means that Eve has a winning strategy f : V âˆ—VE â†’V
from (pin, âŠ¥).
We deï¬ne, using f , a strategy f for Eve in G from (pin, âŠ¥, âˆ…). For this we inductively construct a play 
 in G and
consider the preï¬x of 
 already constructed to determine how to play in G at any time: f is deï¬ned from f and from
the preï¬x of 
 already constructed.
Let us describe 
 and f :
(1) At the beginning 
 = (pin, âŠ¥).
(2) Assume that the play is in some conï¬guration (p, , R). If p âˆˆQE, Eve considers the move given in G by f when
having played 
 (for instance at the beginning from (pin, âŠ¥)). In other words, she considers the value of f (
). If it
is a skip-transition skip(pâ€²), she moves to (pâ€², , R). If it is a pop-transition then she goes to tt (Proposition 29 will
show that such a move is always possible in that case). Otherwise she goes to the vertex (p, , R, pâ€², â€²), where the
push-transition was push(pâ€², â€²). If p âˆˆQA, Adam goes either to ff (Proposition 29 will show that such a move
is impossible), to tt, to some vertex (pâ€², , R) or to some vertex (p, , R, pâ€², â€²).
(3) From a vertex (p, , R, pâ€², â€²), Eve considers the set of all (ï¬nite) extensions of 
 Â· (pâ€², â€²) (where (p, ) was
the last conï¬guration in 
) in G, where she respects f , and that end with popping â€² from the stack. She moves to
(p, , R, pâ€², â€², Râ€²), where Râ€² is the set of all states the game can be in after popping â€² along these plays.
(4) Assume Adam goes from (p, , R, pâ€², â€², Râ€²) to (pâ€²â€², , R), by playing a jump move. If (p, ) is the last conï¬g-
uration in 
, then Eve completes 
 by adding (pâ€², â€²) followed by a sequence of moves respecting f in G that
ends in (pâ€²â€², ). Then she goes to step (2).
(5) Assume Adam goes from (p, , R, pâ€², â€², Râ€²) to (pâ€², â€², Râ€²) by playing a pursue move. If (p, ) is the last conï¬g-
uration in 
, then Eve completes 
 by adding (pâ€², â€²). Then she goes to step (2).
Therefore with any partial (resp. inï¬nite) play 
 in G is associated a partial (resp. inï¬nite) play 
 in G.
From the deï¬nition of f , it follows that for any partial play 
 in G, where Eve respects f , the corresponding partial
play 
 is a valid partial play in G where Eve follows her winning strategy f . The same holds for inï¬nite plays. Therefore,
if 
 is inï¬nite, it is a winning play for Eve.
In addition, we have the following proposition, which is a direct consequence of how f is deï¬ned.
Proposition 29. Consider a partial play 
 in G where Eve respects f and that ends in a vertex (p, , R). Then,
the associated partial play 
 (constructed by f ) ends in some vertex (p, ) for some  âˆˆSt. Moreover, for any
continuation of 
 where Eve respects f , if  is eventually popped and leads to some conï¬guration (r, ), then r âˆˆR.
In particular, the above proposition implies that 
 does not eventually reach some vertex ff (such a move would be
done by Adam and would correspond to a pop-transition from 
 that contradicts Proposition 29) and that the moves to
tt given by f are always possible. Therefore, ï¬nite plays in G are won by Eve.
Now, consider some inï¬nite play 
 in G starting from (pin, âŠ¥, âˆ…) where Eve respects f . Let 
 be the inï¬nite play
constructed by f while playing 
. 
 is won by Eve as it is a play where she respects her winning strategy f . Moreover,
we have the following straightforward result:
O. Serre / Theoretical Computer Science 350 (2006) 345â€“372
359
Lemma 30. Let Steps
 = {n0 < n1 < n2 < Â· Â· Â·} and let Steps
 = {m0 < m1 < m2 < Â· Â· Â·}. Then for any index i â©¾0,
one has the following:
â€¢ 
(ni) = (p, ) for some p âˆˆQ,  âˆˆ and  âˆˆSt if and only if 
(mi) = (p, , R) for some R âŠ†Q.
â€¢ |
(ni)| = |
(ni+1)| if and only if in the factor 
(mi) Â· Â· Â· 
(mi+1) of 
, all the edges are labeled by Îµ.
â€¢ |
(ni)| + 1 = |
(ni+1)| if and only if in the factor 
(mi) Â· Â· Â· 
(mi+1) of 
, there is exactly one edge which is not
labeled by Îµ. In addition, it is labeled by  where  is such that 
(ni) = (p, ) for some p âˆˆQ and  âˆˆSt.
Now, as 
 is an inï¬nite play starting from (pin, âŠ¥), where Eve respects her winning strategy f , it implies that the
stack of P is strictly unbounded in 
 and therefore StLim(
) âˆˆL(A1 â–·Â· Â· Â· â–·An â–·An+1). Therefore, using Lemma
30, we conclude that Lab(
) = StLim(
) and therefore, Lab(
) âˆˆL(A1 â–·Â· Â· Â· â–·An â–·An+1) = 	ext
A1 â–·Â·Â·Â· â–·An â–·An+1,
which exactly means that 
 is winning for Eve.
4.2.2. From G to G
Assume that (pin, âŠ¥, âˆ…) is winning for Eve in G and let f be a winning strategy for Eve in G from (pin, âŠ¥, âˆ…). From
f , we deï¬ne a winning strategy f in G from (pin, âŠ¥).
The strategy f uses a stack Î¥ containing vertices of G. At the beginning, Î¥ only contains (pin, âŠ¥, âˆ…). By top(Î¥ )
we denote the top symbol of Î¥ . We will have top(Î¥ ) = (p, , R) if and only if the current partial play 
 in G ends in
some conï¬guration (p, ) for some  âˆˆSt. In addition, R is such that, if Eve respects f , and if  is eventually popped,
it leads to some state r âˆˆR. By StCont(Î¥ ) we denote the word obtain by reading Î¥ from bottom to top. StCont(Î¥ )
will contain a play in G starting from (pin, âŠ¥, âˆ…), and where Eve respects her winning strategy f .
In order to describe f , let us assume that we are in some conï¬guration (p, ) with top(Î¥ ) = (p, , R). First we
describe how Eve plays if she is the one that has to move, and then we explain how Î¥ is updated.
â€¢ Choice of the move: From some conï¬guration (p, ) where p âˆˆQE, Eve considers the value of f (StCont(Î¥ )).
If the move given by f (StCont(Î¥ )) is to some vertex (pâ€², , R), then, in G, Eve plays the internal-transition
skip(pâ€²) âˆˆ(p, ). If it is a move to tt then Eve plays some pop-transition pop(r) âˆˆ(p, ) for some r âˆˆR
(Lemma 31 will show that it is always possible). If the move given by f (StCont(Î¥ )) is to some vertex (p, , R, pâ€², â€²),
then, in G, Eve plays the push-transition push(pâ€², â€²) âˆˆ(p, ).
â€¢ Update of Î¥ : If the move (made by whoever) from (p, ) is to move to a conï¬guration (pâ€², ), Eve updates Î¥ by
pushing the transition ((p, , R), Îµ, (pâ€², , R)) followed by the vertex (pâ€², , R).
If the move (made by whoever) from (p, ) is to pop and reach a conï¬guration (r, ), Eve updates Î¥ by popping
the top symbols until ï¬nding a transition labeled by some letter â€² Ì¸= Îµ. Let ((qâ€², â€², Râ€², q, , R), â€², (q, , R)) be this
top symbol. She removes it and pushes the edge ((qâ€², â€², Râ€², q, , R), Îµ, (r, â€², Râ€²)) followed by the vertex (r, â€², Râ€²).
This update is illustrated in Fig. 3.
If the move (made by whoever) from (p, ) is to push â€² and reach some conï¬guration (pâ€², â€²), then Eve pushes
on Î¥ â€™s top the edge ((p, , R), Îµ, (p, , R, pâ€², â€²)) followed by the vertex (p, , R, pâ€², â€²). Then she pushes the value
((p, , R, pâ€², â€², Râ€²), Îµ, (p, , R, pâ€², â€², Râ€²)) of f (StCont(Î¥ )) followed by (p, , R, pâ€², â€², Râ€²) on Î¥ â€™s top. Finally, she
pushes the transition ((p, , R, pâ€², â€², Râ€²), , (pâ€², â€², Râ€²)) followed by (pâ€², â€², Râ€²) on Î¥ â€™s top.
We then have the following lemma:
Lemma 31. Let 
 be a partial play starting from (pin, âŠ¥) in G where Eve follows her strategy f and that ends in a
conï¬guration (p, ). Then, the following holds:
(1) top(Î¥ ) = (p, , R) for some R âŠ†Q.
(2) StCont(Î¥ ) is a partial play in G that starts in (pin, âŠ¥, âˆ…), ends in (p, , R) and in which Eve respects f .
(3) If the next move is a pop--transition, then it leads to some conï¬guration (r, ) with r âˆˆR.
Proof. The proof goes by induction on the length of the play.
First we show that the third point is a direct consequence of the two other points. Assume that from (p, ) a pop-
transition pop(r) âˆˆ(p, ) is applied. Therefore, there is an edge in G from (p, , R) to tt or ff depending whether
360
O. Serre / Theoretical Computer Science 350 (2006) 345â€“372
Fig. 3. Updating Î¥ after popping.
r âˆˆR. If p âˆˆQE then, due to how f is deï¬ned, the edge is to tt and thus we have the result. If p âˆˆQA then, if r /âˆˆR,
Adam could move in G from (p, , R) to ff : using the second point, StCont(Î¥ ) is a partial play that ends in (p, , R)
and where Eve respects her winning strategy f . Thus, it cannot be extended by a move of Adam into a loosing play
for Eve.
Now assume that the result holds for some play 
, and let us show that it also holds for some play 
â€² obtained from

 by applying some transition. We have two cases, depending on the kind of transition is applied:
â€¢ 
â€² is obtained from 
 by playing some internal-transition or some push-transition. The ï¬rst two points are immediate
using the induction hypothesis and considering the way Î¥ is updated.
O. Serre / Theoretical Computer Science 350 (2006) 345â€“372
361
â€¢ 
â€² is obtained from 
 by applying some pop--transition. Then let (p, ) be the last conï¬guration of 
 and let R be
the third component of top(Î¥ ) in (p, ). Then by induction hypothesis, and using the third point, 
â€² = 
 Â· (r, )
for some r âˆˆR. In addition, it is easily seen that, if n = ||, there are n edges with labels different from Îµ, and
that StCont(Î¥ ) = 
1 Â· (pâ€², â€², Râ€², q, , R) Â· ((pâ€², â€², Râ€², q, , R), â€², (q, , R)) Â· 
2 Â· (p, , R) for some pâ€², q âˆˆQ,
Râ€² âŠ†Q, â€² âˆˆ, and for some partial plays 
1, 
2 of G. In addition, all vertices in 
2 have R as third component and

2 only contains edges labeled by Îµ. Now if we denote by Î¥ â€² the updated value of Î¥ , by deï¬nition of how the stack
Î¥ is updated, StCont(Î¥ â€²) = 
1 Â· (pâ€², â€², Râ€², q, , R) Â· ((pâ€², â€², Râ€², q, , R), Îµ, (r, â€², Râ€²)) Â· (r, â€², Râ€²). By induction
hypothesis on StCont(Î¥ ) and as r âˆˆR, StCont(Î¥ â€²) is a valid play in G where Eve respects f . This shows that the
second point holds. The ï¬rst points is a direct consequence of the second one.
â–¡
By induction, one easily has the following proposition:
Proposition 32. Let 
 be a partial play starting from (qin, âŠ¥) in G where Eve follows her strategy f , and that
ends in a conï¬guration (p, ) where top(Î¥ ) = (p, , R) when being in (p, ). Let 
 be equal to StCont(Î¥ ). Let
Steps
 = {n0 < n1 < n2 < Â· Â· Â· < nh} and let Steps
 = {m0 < m1 < m2 < Â· Â· Â· < mk}. Then the following holds:
â€¢ h = k.
â€¢ For every i = 0, . . . , h, 
(ni) is of the form (p, ) for some p âˆˆQ,  âˆˆ and  âˆˆSt if and only if 
(mi) is of
the form (p, , R) for some R âŠ†Q and  = Lab(
â†¾mi).
Now consider an inï¬nite play 
 in G where Eve respects f . Then, either some level is inï¬nitely repeated or not.
For every integer i â©¾0, let 
i = StCont(Î¥i), where Î¥i is the (strategy) stack in 
(i). Then, in both cases, for all kâ©¾0
there is some j â©¾0 such that 
iâ†¾k = 
jâ†¾k for all i â©¾j. Let 
 be the inï¬nite word such that for all kâ©¾0, 
â†¾k is the limit
of (
iâ†¾k)i â©¾0. Then, from Lemma 31, it follows that 
 is a play in G starting from (pin, âŠ¥, âˆ…) where Eve respects f .
Therefore Lab(
) âˆˆL(A1 â–·Â· Â· Â· â–·An â–·An+1) and is thus inï¬nite. Using Proposition 32, we conclude that the stack
is strictly unbounded in 
 and that StLim(
) = Lab(
). Therefore StLim(
) âˆˆL(A1 â–·Â· Â· Â· â–·An â–·An+1) and thus 
is winning for Eve.
â–¡
4.3. The special case of strict unboundedness pushdown games
In this section, we consider the special case of strict unboundedness pushdown games. In [4], the following internal
winning condition on pushdown game graphs was considered: Eve wins an inï¬nite play if and only if some conï¬guration
is inï¬nitely often visited. It is easily seen that the corresponding winning condition forAdam is the strict unboundedness
winning condition.
Since the strict unboundedness winning condition is the winning condition 	int
A for any automaton A recognizing
the -regular language  (where  is the stack alphabet of the pushdown graph), we conclude that the preceding
constructions induce the decidability for the strict unboundedness pushdown game (and for the games considered
in [4]).
More precisely, let P = âŸ¨Q, , âŠ¥, âŸ©be a pushdown process with a partition QE âˆªQA of Q. We denote by G
the associated pushdown game graph, and by Gubd the associated strict unboundedness pushdown game. Then, the
equivalent game, played on a ï¬nite graph described as above, is equipped with the winning condition 	ext
A . Therefore,
this last game is a BÃ¼chi game, as Eve wins a play if and only if inï¬nitely many edges not labeled by Îµ are visited.
Therefore, we have the following special case of Theorem 28.
Theorem 33. Eve has a winning strategy from a conï¬guration (pin, âŠ¥) in G if and only if she has a winning strat-
egy from (pin, âŠ¥, âˆ…) in the BÃ¼chi game G played on the ï¬nite game graph G (with edges marked ï¬nal) depicted
in Fig. 4.
Therefore, we have the following corollary:
Corollary 34. Deciding the winner in a strict unboundedness pushdown game (respectively, in a pushdown game
equipped with the winning condition of [4]) can be achieved in Dexptime.
362
O. Serre / Theoretical Computer Science 350 (2006) 345â€“372
Fig. 4. Local structure of G for strict unboundedness: ï¬nal edges are marked by â‹†.
5. Complexity
5.1. Main results
We ï¬rst start with some deï¬nitions.
Deï¬nition 35. For any h, N â©¾0, tow(h, N) is deï¬ned inductively by
â€¢ tow(0, N) = N.
â€¢ tow(h, N) = 2tow(hâˆ’1,N) for hâ©¾1.
For instance, tow(3, N) = 222N
.
Deï¬nition 36 (h-Dexptime). Let consider a problem P and a deterministic Turing machine deciding in O(tow(h, N))
steps whether some instance of the problem P is true, where N is polynomial in the size of the instance. Then the
problem P belongs to the class h-Dexptime.
We have the following upper bounds:
Proposition 37. Let consider an integer kâ©¾0 and a collection A1, . . . , Ak, Ak+1 of pushdown automata, where in
addition Ak+1 is equipped with a parity condition.
Let G be a pushdown game equipped with the winning condition 	int
A1 â–·Â·Â·Â· â–·Ak â–·Ak+1. Deciding the winner in such
a game is a (k + 2)-Dexptime problem.
Let G be a game on a ï¬nite game graph equipped with the winning condition 	ext
A1 â–·Â·Â·Â· â–·Ak â–·Ak+1. Deciding the
winner in such a game is a (k + 1)-Dexptime problem.
Proof. First note that the transformation described in Section 4.1 is polynomial, and that the transformation described
in Section 4.2 is exponential. Moreover, recall that deciding the winner in a parity pushdown game costs exponential
time [24]. Then the proof is immediate by induction on k.
â–¡
Concerning the lower bound, we have the following result which is proved in Section 5.2:
Proposition 38. The problem of deciding the winner in a game played on a ï¬nite game graph and equipped with a
winning condition of the form 	ext
A1 â–·Â·Â·Â· â–·Ak â–·Ak+1, with kâ©¾0, is a (k + 1)-Dexptime hard problem.
O. Serre / Theoretical Computer Science 350 (2006) 345â€“372
363
From Proposition 38 and from the polynomial reduction described in Section 4.1, we obtain the following corollary.
Corollary 39. The problem of deciding the winner in a pushdown game equipped with a winning condition of the form
	int
A1 â–·Â·Â·Â· â–·Ak â–·Ak+1, with kâ©¾0, is a (k + 2)-Dexptime hard problem.
Recall that a problem is elementary if it is a k-Dexptime problem for some kâ©¾0. An elementary hard problem is
thus a problem which is k-Dexptime hard for all kâ©¾0.
Propositions 37 and 38 and Corollary 39 leads to the following result:
Theorem 40. The complexity of deciding the winner in a pushdown game (resp. a game on a ï¬nite game graph)
equipped with a winning condition of the form 	int
A1 â–·Â·Â·Â· â–·Ak â–·Ak+1 (resp. 	ext
A1 â–·Â·Â·Â· â–·Ak â–·Ak+1) is non-elementary and
is elementary-hard.
5.2. Proof of Proposition 38
5.2.1. Presentation of the proof
The proof starts with the basic case k = 0. Then, it focuses on the case k = 1 that gives some insight for the general
case. The basic idea of the proof is to simulate an alternating Turing machine using tow(k, N) space for some kâ©¾1
and some polynomial N in the size of the input. Such a Turing machine is equivalent to a deterministic Turing machine
using tow(k + 1, N) time [16] which completes the proof.
From now on, a conï¬guration of a Turing machine is described by a word upv, where uv is the contents of the tape,
p is the control state and the head of the Turing machine is just after u.
Note that in all the proof Ak+1 will not be equipped with a parity acceptance condition but with a weaker one, namely
a reachability condition.
5.2.2. Basic case: k = 0
This case is a slightly modiï¬ed version of the proof showing that deciding the winner in a reachability pushdown
game is Dexptime hard [24].
5.2.3. Basic case: k = 1
We start by proving the hardness for the special case of a game G played on a ï¬nite game graph G equipped
with a winning condition 	ext
A1 â–·A2. We explain how such a game can be used to simulate an alternating Turing
machine M of exponential space 2N, where N is polynomial in the size of M. More precisely, G is constructed
so that Eve has a winning strategy if and only if M accepts from a blank tape. A play in G is the description
by Eve and Adam of a run of the Turing machine M, that is a sequence of conï¬gurations. For this the players go
through labeled-edges. In what follows, we say that a player writes a instead of saying that he goes through an edge
labeled by a.
A conï¬guration a0a1 . . . a2Nâˆ’1 of M will be represented by the following word:
(#a0a1)(n0,n0)2N (a0a1a2)(n1,n1)2N Â· Â· Â· (a2Nâˆ’2a2Nâˆ’1#)(n2Nâˆ’1,n2Nâˆ’1)2N ,
where ni is the binary representation of i on N bits with the most signiï¬cant bit on the left and ni is the binary re-
presentation of i with the most signiï¬cant bit on the right. For instance, if N = 4, n10 = 1010 and n10 = 0101.
By (ni,ni) we mean (n0
i , nNâˆ’1
i
)(n1
i , nNâˆ’2
i
) Â· Â· Â· (nNâˆ’1
i
, n0
i ) where ni = n0
i n1
i . . . nNâˆ’1
i
, e.g. (n10,n10) = (1, 0)(0, 1)
(1, 0)(0, 1). For a word u and an integer kâ©¾0, uk is the word obtained by concatenating k copies of u (e.g. u4 = uuuu).
The sequence (ni,ni) is called a counter. The reason why we copy 2N times the same counter will appear later when
we perform an exhaustive search of a counter in a stack.
A play goes as follows: Eve describes (going through labeled-edges) the initial conï¬guration (that is, the initial
state i followed by 2N âˆ’1 blank symbols) then, depending on whether the control state in the initial conï¬guration is
364
O. Serre / Theoretical Computer Science 350 (2006) 345â€“372
existential or universal, Eve (existential state) or Adam (universal state), chooses a move, that is, goes through an edge
whose label is the description of a transition of the Turing machine. Then, Eve describes the resulting conï¬guration
and so on. If some accepting conï¬guration is eventually reached then the play goes in a special vertex where it loops
forever through an edge labeled by a special symbol â™¥.
To prevent Eve from cheating in the description of the conï¬gurations, there are 5 special symbols !c,!c, !v, !v and
? (c stands for copy and v for value). Adam can write them to contest the validity of the last symbol written by Eve.
They can be used in the following cases:
â€¢ The jth pair of bits of a counter (ni,ni) is false. If it is the ï¬rst copy of the counter, the value of the counter should
be equal to the value of the preceding counter plus 1. Therefore, Adam writes !v (if the mistake is for ni) or !v
(otherwise) just after the wrong pair of bits. If it is not the ï¬rst copy, the error concerns the duplication. In that case,
Adam writes !c (if the mistake is for ni) or !c (otherwise) just after the wrong pair of bits.
â€¢ The value of a tuple (aiâˆ’1aiai+1) is incorrect. In that case, Adam writes ? just after it.
Once a contesting !c, !c, !v or !v has been made, the play goes in a special vertex where it loops forever through
an edge labeled by a special symbol â™ . In the case of a contesting ?, the value of the next counter is written (and
can be contested), and then the play reaches the aforementioned special vertex and loops forever through an edge
labeled by â™ .
The alternation between both players (that allowsAdam to contest any symbol written by Eve), the memory to decide
whether the control state is existential or universal, and the memory of a contesting or a ï¬nal conï¬guration (to write
â™ or â™¥) are encoded in the vertices of G. It is also the same to change of component of G when (n2Nâˆ’1,n2Nâˆ’1) has
been written or to force Eve to start describing the empty tape conï¬guration and to write (n0,n0) after the ï¬rst tuple
of a conï¬guration. Moreover, the vertices are also used to force Eve to describe an overlapping sequence of tuples of
letters. More precisely, if she has just written the tuple (aiâˆ’1, ai, ai+1), then she will be in some vertex where she will
be forced to write as next tuple (ai, ai+1, ai+2) for some letter ai+2.
Let us now describe how the validity of a contesting is checked. For the contesting concerning (ni,ni), the preceding
counter must be considered to compute the correct value of the contested bit, which allows to decide if the contesting
is valid or not. The computation of that bit will of course depend on the nature of the contesting.
For a contesting ? on a tuple of letters, the corresponding tuple in the preceding conï¬guration has to be consid-
ered. To ï¬nd it, one uses the values of the counters that must therefore be correct. For this reason, the validity of
the counters has to be checked ï¬rst and only after this, can one check the validity of the tuples. Therefore, in the
winning condition 	ext
A1 â–·A2, A1 will be used to check the validity of the counters and A2 to check the validity of the
conï¬gurations.
The automaton A1 copies its input word (in our case the description of the run of M) in its stack. If it eventually
reads a contesting !v or !v, it determines the index j of the contested bit (which is bounded by N) by popping and
counting the bits already written in its stack until it ï¬nds a tuple of letters. Fig. 5 illustrates the next two cases. If the
contesting is !v, A1 pops the next j pairs of bits of its stack and considers their second components to compute the
jth bit of the counter obtained by adding 1 to the top counter of the stack, and thus decides whether or not there was
an error. If the contesting was !v, it pops and ignores the j ï¬rst pairs and then veriï¬es with the ï¬rst components of
the next N âˆ’j bits stored in the stack whether or not there was an error. After having checked the correctness of the
contesting, A1 pushes an inï¬nite sequence of â™ if the contesting was correct, and pushes an inï¬nite sequence of â™¥
otherwise.
If A1 reads a contesting !c or !c, it pops the last N bits in its stack and compares the new top bit with the contested
one. The contesting is correct if and only if they are different. This case is illustrated by Fig. 6.After having checked the
correctness of the contesting, A1 pushes an inï¬nite sequence of â™ if the contesting was correct, and pushes an inï¬nite
sequence of â™¥otherwise.
The automaton A2 copies its input word in its stack. It goes in a ï¬nal state when it reads â™¥and goes and stays
forever in a non-ï¬nal state when it reads â™ . In particular, it accepts any word ending by an inï¬nite sequence of â™¥and
rejects any word ending by an inï¬nite sequence of â™ . Note that the limits of the stack contents of A1 can only contain
a contesting of the form ?. Fig. 7 illustrates the behavior of A2. When A2 reads some contesting ?, it pops until it
ï¬nds a symbol describing a transition of the Turing machine and remembers it. Then it reads synchronously the ï¬rst
components of the counters described after ? and pops its stack and focuses on the second component of the counters.
O. Serre / Theoretical Computer Science 350 (2006) 345â€“372
365
Fig. 5. Stack content of A1 when reading !v or!v.
It does so until it ï¬nds a correspondence between the counters. Note that for this search, it only compares the counter
it reads with the ï¬rst copy of the counter it has in its stack (otherwise it might run out of copies before ï¬nding the
corresponding counter). This search terminates because there are 2N possible values for a counter and the counter in
the input word is repeated 2N times. Therefore, there are enough copies to successfully perform an exhaustive search.
Once the corresponding counter is found, the top stack symbol is the tuple of letters whose index is the same as the one
being contested. The automaton A2 can therefore decide whether its central letter has been correctly updated and thus
concludes on the validity of the contesting. Then it stops reading its input word and goes in an accepting state if the
contesting was not correct, and loops in a non-accepting state otherwise. Finally, in the case where no correspondence
was found, it loops in an non-accepting state. In that case, Eve did an error in the description of the conï¬gurations of
the Turing machine.
One can prove that this reduction is of polynomial size, and is such that Eve has a winning strategy if and only if the
Turing machine accepts from the empty tape. The winning strategy for Eve is to describe an accepting run of the Turing
machine. If the Turing machine rejects from the empty tape, a winning strategy for Adam is to describe a rejecting run
and to contest whenever Eve cheats in the description of the run.
5.2.4. General case: kâ©¾1
In this section, we explain how to extend the techniques used in Section 5.2.3 to prove the (k+1)-Dexptime hardness
of the winning conditions of the form 	ext
A1 â–·Â·Â·Â· â–·Ak â–·Ak+1. For this, we simulate an alternating Turing machine M using
tow(k, N) space by a game on a ï¬nite game graph equipped with such a winning condition.
366
O. Serre / Theoretical Computer Science 350 (2006) 345â€“372
Fig. 6. Stack content of A1 when reading !c or!c.
As in the case k = 1, Eve and Adam will describe a branch of a run of the Turing machine by writing sequences of
conï¬gurations. Previously, a conï¬guration was represented by a sequence of the form
(#a0a1)(n0,n0)2N (a0a1a2)(n1,n1)2N Â· Â· Â· (a2Nâˆ’2a2Nâˆ’1#)(n2Nâˆ’1,n2Nâˆ’1)2N .
Now, the length of a conï¬guration is no longer exponential but k-times exponential. A ï¬rst idea would be to keep
the same representation, except that the counters (ni,ni) would be bigger. Unfortunately, their length would no longer
be linear (but (k âˆ’1)-times exponential), and therefore it would no longer be possible, with polynomial size memory,
to check whether they represent the correct integers.
To address this problem, we adopt a more reï¬ned representation.
Deï¬nition 41 (h-exp decomposition of an integer). The 1-exp decomposition of an integer R < tow(1, N) is the se-
quence ((bNâˆ’1, b0) Â· Â· Â· (b1, bNâˆ’2)(b0, bNâˆ’1))tow(1,N), where bNâˆ’1 . . . b1b0 is the binary representation of R with the
most signiï¬cant bit on the left and therefore b0b1 . . . bNâˆ’2bNâˆ’1 is the binary representation of R with the most signiï¬cant
bit on the right.
Let h > 1 and let R be some integer such that R < tow(h, N). The h-exp decomposition of R is the sequence:

(b0, btow(hâˆ’1,N)âˆ’1)0(b1, btow(hâˆ’1,N)âˆ’2)1 Â· Â· Â· (btow(hâˆ’1,N)âˆ’1, b0)tow(hâˆ’1,N)âˆ’1
tow(h,N) ,
where
â€¢ btow(hâˆ’1,N)âˆ’1 . . . b1b0 is the binary representation of R with the most signiï¬cant bit on the left;
â€¢ b0 . . . btow(hâˆ’1,N)âˆ’2btow(hâˆ’1,N)âˆ’1 is the binary representation of R with the most signiï¬cant bit on the right;
â€¢ i is the (h âˆ’1)-exp decomposition of i.
For convenience, we assume that the binary alphabets used in the h-exp decomposition are distinct for any level h so
that the decomposition is easily readable.
Finally, we designate the sequence (b0, btow(hâˆ’1,N)âˆ’1) Â· Â· Â· (btow(hâˆ’1,N)âˆ’1, b0) as a counter of level h.
O. Serre / Theoretical Computer Science 350 (2006) 345â€“372
367
Fig. 7. Behavior of A2 after reading ?.
A conï¬guration a0a1 Â· Â· Â· atow(k,N)âˆ’1 of the Turing machine M is then represented by the following word:
(#a0a1)n0(a0a1a2)n1 . . . (a(tow(k,N)âˆ’2)a(tow(k,N)âˆ’1)#)ntow(k,N)âˆ’1,
where ni is the k-exp decomposition of i. Note that for k = 1, we obtain exactly the representation used in the preceding
section.
Let us now explain how a play goes on. Eve describes the initial conï¬guration. Then, depending on whether the
control state in this conï¬guration is existential or universal, Eve (existential state) or Adam (universal state), chooses
a move, that is, goes trough an edge whose label is a description of a transition of the Turing machine. Then, Eve
describes the resulting conï¬guration and so on. If an accepting conï¬guration is eventually reached, then the play goes
in a special vertex where it loops forever trough an edge labeled by a special symbol â™¥.
To prevent Eve from cheating, there are special symbols !h
c, !hc, !h
v, !hv for all h = 1 . . . k (c stands for copy and v for
value) and ? that Adam can write whenever he wants to contest the validity of the last symbol written by Eve. They can
be used in the following cases:
â€¢ The jth pair of bits of a counter of level h is false. If it is the ï¬rst copy of the counter, the value should be equal to
the value of the preceding counter plus 1. Therefore, Adam writes !h
v (if the mistake is for the representation with
the most signiï¬cant bit on the left) or !hv (otherwise) just after the wrong pair of bits. If it is ont the ï¬rst copy, the
368
O. Serre / Theoretical Computer Science 350 (2006) 345â€“372
error concerns the duplication. In that case, Adam writes !h
c (if the mistake is for the representation with the most
signiï¬cant bit on the left) or !hc (otherwise) just after the wrong pair of bits.
â€¢ The value of some tuple (aiâˆ’1aiai+1) is incorrect. In that case, Adam writes ? just after it.
Once a contesting on a counter of level 1 has been made, the play goes in a special vertex where it loops forever trough
an edge labeled by a special symbol â™ . In the case of a contesting concerning a counter of level hâ©¾2, the (h âˆ’1)-exp
decomposition of the index of the contested bit is written (and can be contested) and then the symbol â™ is written
forever. In the case of a contesting ?, the value of the k-decomposition of the index of the contested tuple is written
(and can be contested) and then the symbol â™ is written forever.
The alternation between both players (that allowsAdam to contest any symbol written by Eve), the memory to decide
whether the control state is existential or universal, and the memory of a contesting or a ï¬nal conï¬guration (to write â™ 
or â™¥) are encoded in the vertices. It is also the same to force Eve to start by describing the k-exp decomposition of 0,
and to describe an overlapping sequence of tuples of letters. More precisely, if the last tuple was (aiâˆ’1, ai, ai+1), then
Eve is forced to write as next tuple (ai, ai+1, ai+2) for some letter ai+2.
Let us now describe how the validity of a contesting is checked. For the contesting concerning a counter, the
preceding counter must be considered to compute the correct value of the contested bit, which allows to conclude. The
computation of that bit will of course depend on the nature of the contesting. For a contesting ? on a tuple of letters, the
corresponding tuple in the preceding conï¬guration has to be considered. To ï¬nd it, one uses the values of the counters
that must therefore be correct. For this reason, the validity of the counters of level 0 is checked ï¬rst, then the validity of
counters of level 1 is checked and so on. Finally, the validity of the conï¬gurations is checked. Therefore, in the winning
condition 	ext
A1 â–·Â·Â·Â· â–·Ak â–·Ak+1, Ah will be used to check the validity of the counters of level hâ©½k and Ak+1 to check
the validity of the conï¬gurations.
Now, let us describe how the different pushdown automata behave.
â€¢ The automaton A1 copies its input word in its stack. If it reads a contesting !1
c or !1c, it pops the last N bits in its stack
and compares the new top bit with the contested one. The contesting is correct if and only if they are different. If the
contesting was correct, it stops reading the word and pushes an inï¬nite sequence of â™ , otherwise it stops reading
and pushes an inï¬nite sequence of â™¥. If it eventually reads a contesting !1
v or !1v, it determines the index j of the
contested bit (which is bounded by N) by popping and counting the bits already written in its stack until it ï¬nds a
bit from a counter of level 2. If the contesting was !1
v, it pops the next j ï¬rst pairs of bits and considers their second
components to compute the jth bit of the counter obtained by adding 1 to the top counter (of level 1) of the stack.
Then it can decide whether or not there was an error. If the contesting was !1v, it pops and ignores the j ï¬rst pairs and
then veriï¬es, with the ï¬rst components of the next N âˆ’j bits stored in the stack whether there was or not an error.
After having checked the correctness of the contesting, A1 pushes an inï¬nite sequence of â™ if the contesting was
correct, and pushes an inï¬nite sequence of â™¥otherwise.
â€¢ The automaton A2 copies its input word in its stack. If it reads a contesting !2
c or !2c, it has to pop its stack until it ï¬nds
the bit whose index in the preceding counter of level 2 is the same as the one being contested. In order to do this, it
reads the next 1-decomposition (which is a repeated binary representation of the index of the contested bit) and at
the same time, it pops its stack and compares what it reads with the various indices it has in its stack (note that in the
stack the indices are also represented in a iterated form: A2 only compares to the ï¬rst representation). In order to
do this, it compares the ï¬rst component (most signiï¬cant bit ï¬rst) of what it reads with the second component (less
signiï¬cant bit ï¬rst) of what it pops. Eventually, it ï¬nds the corresponding bit of the preceding counter and compares
it with the contested one. The contesting is correct if and only if they are not equal. If the contesting was correct,
it stops reading the word and pushes an inï¬nite sequence of â™ , otherwise it stops reading and pushes an inï¬nite
sequence of â™¥. If it ï¬nds a contesting !2
v or !2v, let j be the index of the contested pair of bits (which is bounded by
(tow(1, N) âˆ’1)). To check the validity of the contesting, one has to compute the bit from the preceding value of the
counter. The computation depends on whether the contested bit is the ï¬rst or the second of the pair. If the contesting
is !2
v, it is sufï¬cient to consider the second component of the pairs of indices (tow(1, N)âˆ’1) . . . (tow(1, N)âˆ’1âˆ’j)
of the preceding counter. If the contesting is !2v, it is sufï¬cient to consider the ï¬rst component of the pairs of indices
(tow(1, N)âˆ’1âˆ’j) . . . 0 of the preceding counter. Note that the binary representation of tow(1, N)âˆ’1âˆ’j is obtained
from the binary representation of j by changing all 0 by 1 and all 1 by 0. Therefore, the binary representation of
(tow(1, N) âˆ’1 âˆ’j) can be computed on the ï¬‚y from the one of j (which is read by A2). Both cases are thus almost
O. Serre / Theoretical Computer Science 350 (2006) 345â€“372
369
the same as for the preceding contestings, except that an on the ï¬‚y addition is performed while searching. Thus, these
cases are no more difï¬cult than the preceding ones. If the contesting was correct, A2 stops reading the word and
pushes an inï¬nite sequence of â™ , otherwise it stops reading and pushes an inï¬nite sequence of â™¥. If, at any moment,
A2 reads some symbol â™ (there was a valid contesting on a counter of level 1), it stops reading and pushes an
inï¬nite sequence of â™ . Symmetrically, if A2 reads some symbol â™¥, it stops reading and pushes an inï¬nite sequence
od â™¥.
â€¢ Let 3â©½hâ©½k. Ah works as A2 except that it handles on the contesting !h
c, !hc, !h
v, !hv. Another difference is that Ah
copies the word it reads in its stack, but it skips all bits concerning counters of level h âˆ’2 as they are no longer
useful. Therefore, in its stack, there are only informations on counters of level greater or equal than h âˆ’1.
â€¢ Ak+1 copies the word, it reads in its stack, but it skips all bits concerning counters of level k âˆ’1. It goes in a ï¬nal
state when it reads â™¥and goes and stays forever in a non-ï¬nal state when it reads â™ . In particular, it accepts words
ending by an inï¬nite sequence of â™¥and rejects words ending by an inï¬nite sequence of â™ . Note that the limits
of stack contents that Ak+1 reads can only contain a contesting of the form ?. When Ak+1 reads some contesting
?, it reads the next symbol (which is a tuple of bits) and pops in its stack until it ï¬nds a symbol describing the
transition of the Turing machine and remembers it. Then, it reads synchronously the ï¬rst component of the counters
described after ?, and pops in the stack and considers on the second component of the counters. It does so until it
ï¬nds a correspondence between the counters. Again, this exhaustive search works since there are enough copies of
the searched counter in the input word (when popping Ak+1 only compares to the ï¬rst value of the iterated counter it
reads in the stack). Then, as top symbol, it gets the tuple of letters whose index is the same as the one being contested.
It can therefore check whether there was an error for the central letter of the tuple. In case of error, it stops reading
and loops in a non-accepting state, otherwise, it stops reading and goes in an accepting state. In the case where no
correspondence was found, it loops in a non-accepting state.
One can prove that the preceding reduction is of polynomial size and is such that Eve has a winning strategy if and
only if the Turing machine accepts from the empty tape. The winning strategy for Eve is to describe an accepting run
of the Turing machine. If the Turing machine rejects from the empty tape, a winning strategy for Adam is to describe
a rejecting run and to contest if Eve cheats in the description of the run.
6. Winning positions and strategies
6.1. Winning positions
In this section, we give results on the set of winning positions for pushdown games equipped with winning conditions
of the form 	int
A1 â–·Â·Â·Â· â–·An â–·An+1.
In [18,3], it is shown that the set of winning positions in a parity pushdown game is a regular language. In fact, using
the same techniques, one can prove similar results for various winning conditions [19]. For instance: unboundedness,
strict unboundedness, trampoline (Eve wins if and only if some conï¬guration is inï¬nitely visited while the stack is
unbounded) or for more exotic winning conditions (for instance: if ni denotes the number of distinct palindromes
appearing in the stack of the ith conï¬guration of a play, Eve wins if and only if (ni)i â©¾1 is unbounded).
The main idea to prove these results is to note that the winner does not depend on a preï¬x of the play neither on a
ï¬nite number of letters on the bottom of the stack, provided these letters will never appear on top of the stack. This
second point is no longer true for the winning conditions 	int
A1 â–·Â·Â·Â· â–·An â–·An+1. Indeed, if some extra letter is added
somewhere in the stack, the stack limit is modiï¬ed, even if this letter never appears on top of the stack. Therefore, the
winner of the play may changed.
In fact, for the winning conditions of the form 	int
A , the set of winning positions may not be regular. For instance,
every deterministic context-free language may occur as a winning set.
Proposition 42. Let A be some deterministic pushdown automaton on ï¬nite words. There exists a deterministic BÃ¼chi
automaton B, a pushdown process P = âŸ¨Q, , âŠ¥, âŸ©, a state q âˆˆQ and a partition Q = QE âˆªQA such that, in the
induced pushdown game equipped with the winning condition 	int
B , the set {u | (q, u) âˆˆWE} is exactly the language
accepted by A.
370
O. Serre / Theoretical Computer Science 350 (2006) 345â€“372
Proof. Let A be the alphabet of A and let # /âˆˆA be a new symbol. We set P = âŸ¨{p, q}, A âˆª{#}, âŠ¥, âŸ©where  is
deï¬ned by: (q, a) = {push(p, #)} for all letter a âˆˆA and (p, #) = {push(p, #)}. In other words, P is deterministic,
and pushes an inï¬nite sequence of # on top of its initial stack contents. QE âˆªQA is any partition of Q. B works as A,
except that it loops when it reads # and cannot read any letter after having read #. Therefore, B accepts the words of
the form u#, where u is accepted by A.
â–¡
It remains open whether there exists a pushdown game equipped with a winning condition of the form
	int
A1 â–·Â·Â·Â· â–·An â–·An+1 such that the set of winning positions for Eve is not a deterministic context-free language.
6.2. Strategies
In this section, we discuss the nature of the winning strategies in the pushdown games equipped with winning
conditions of the form 	int
A1 â–·Â·Â·Â· â–·An â–·An+1. In particular, we show that there are persistent strategies in these games.
First, let us recall the deï¬nition of a persistent strategy [14].
Deï¬nition 43 (Persistent strategy). A strategy  for Eve is persistent if for any partial play v1v2 Â· Â· Â· vk where Eve
respects , if vi = vj, for some 1â©½i, j < k, and if vi is a vertex where Eve is to move, then vi+1 = vj+1.
In other words, a persistent strategy may require memory, but once a choice is made, it is forever. In this section,
we show that for the pushdown games equipped with winning conditions of the form 	int
A1 â–·Â·Â·Â· â–·An â–·An+1 Eve has a
persistent winning strategy.
Theorem 44. Let G be a pushdown game graph and let G = (G, 	int
A1 â–·Â·Â·Â· â–·An â–·An+1) be a game on G equipped with
some winning condition 	int
A1 â–·Â·Â·Â· â–·An â–·An+1. Then, Eve has a persistent winning strategy from any winning position for
her in the pushdown game G.
Before proving Theorem 44, let us give some deï¬nitions.
Deï¬nition 45 (Subword). Let u = a0a1a2a3 Â· Â· Â· be an inï¬nite word and let (ij)j â©¾0 be a strictly increasing sequence
of integers. The word v = ai0ai1ai2ai3 Â· Â· Â· is called a subword of u.
Deï¬nition 46 (Strategy tree). Let  be a strategy for Eve in a game G = (G, 	) played on an unlabeled game graph
G = (VE, VA, E) and equipped with an internal winning condition 	. Let V = VE âˆªVA and let v âˆˆV . One associates
with  and v an inï¬nite tree T with nodes labeled by V in the following way. The root of T is labeled by v. For any
node in T, labeled by some element w âˆˆV one has:
â€¢ If w âˆˆVE, the node has a unique successor labeled by (
) where 
 is the labeling of the unique path from the root
of T to the current node.
â€¢ If w âˆˆVA, let {w1, w2, . . . , wk} be the set of successors of w in G. Then the node has k successors labeled by
w1, w2, . . . wk.
Therefore any labeling of an inï¬nite path in T is a play in G starting from v where Eve respects . Conversely, any
such play is the labeling of some inï¬nite path in T.
The following result directly implies Theorem 44.
Proposition 47. Let G = (G, 	) be a game on an unlabeled game graph G = (VE, VA, E) equipped with an internal
winning condition 	. Assume that 	 satisï¬es the two following conditions:
(1) For all winning play 
 âˆˆ	, and for all vertex v âˆˆV = VE âˆªVA, v appears only ï¬nitely often in 
.
(2) For all winning play 
 âˆˆ	, any inï¬nite subword 
â€² of 
 is in 	.
Then, from any winning position for Eve, she has a winning strategy which insures that every vertex is visited at most
once in a play. In particular, this strategy is a persistent one.
O. Serre / Theoretical Computer Science 350 (2006) 345â€“372
371
Proof. Let v be a winning position for Eve and let  be a winning strategy for her from v.  can be represented as
an inï¬nite V-labeled tree T describing all the plays where Eve follows . Condition (1) implies that for every label
w âˆˆV appearing in T, there is some inï¬nite subtree of T, which root is labeled by w and in which w only labels the
root. Indeed, assume by contradiction, that any inï¬nite subtree of T which root is labeled by w contains another node
labeled by w. Let T1 be some inï¬nite subtree of T which root is labeled by w. T1 contains therefore another node
labeled by w. Let T2 be the inï¬nite subtree of T1 (and therefore of T) rooted in that node. Iterating the construction,
one obtains an inï¬nite sequence T âŠ‹T1 âŠ‹T2 âŠ‹Â· Â· Â· of inï¬nite subtrees, which roots are all labeled by w. The inï¬nite
path from the root of T that visits the roots of the trees (Ti)i â©¾1 is an inï¬nite path in T that contains inï¬nitely many
nodes labeled by w. As the labeling of such a path is a winning play in G, it leads a contradiction with (1).
Now, let us describe how to construct from  a winning strategy â€² for Eve that does not visit a vertex twice. The
strategy â€² maintains an inï¬nite tree T as memory. At the beginning, T = T. From a position w âˆˆVE and a tree T,
â€² considers a subtree of T which root is labeled by w, and where w only labels the root. This tree becomes the new
memory T, and the move given by â€² is to the vertex labeling the (unique) son of the root of T. One easily shows that â€²
is always deï¬ned, and insures that no vertex is visited twice. In addition, any play, where Eve respects â€² is a subword
of a play where Eve respects , and is therefore winning by condition (2).
â–¡
6.3. Effective strategies
In this section, we informally discuss the following questions: do our methods provide effective winning strategies?
Which kind of machine model may be used to give a ï¬nite description of a winning strategy?
In the proof of Theorems 26 and 27, we have shown how to construct an effective strategy in the game played on a
ï¬nite graph from an effective strategy in the equivalent pushdown game. The main idea was to build, from the current
partial play, an equivalent partial play in the pushdown game. This was done by a function  that computes the run
of some deterministic pushdown automaton on the labeling of the current play. Then, the value of the strategy in the
pushdown game on this partial play was considered. Now, assume that the strategy in the pushdown game only needs a
stack, therefore, the strategy we obtain by this construction for the game on the ï¬nite graph only needs a stack (which
alphabet is augmented by a ï¬nite number of symbols used to simulate ). For instance, as pushdown parity games
admits effective stack strategies [24], it implies that there are effective stack strategies in a the game played on a ï¬nite
graph equipped with a condition of the form 	ext
A1.
Now, consider the reduction from the pushdown game to a game played on a ï¬nite graph. In the converse implication
of the proof of Theorem 28, we construct a strategy in the pushdown game from a strategy in the game played on the
ï¬nite graph. For this, a stack Î¥ is used to store a play in the ï¬nite graph. Then, the value of the strategy in the ï¬nite
graph on the partial play stored in the stack is used to decide how to play. Now, assume that the strategy in the ï¬nite
graph uses a stack on some alphabet S. Then, one can encode and update this into the stack Î¥ which alphabet is now
augmented by stacks on the alphabet S: Î¥ is a stack (on an alphabet S) containing stacks and other symbols.
Iterating this reasoning shows that the preceding constructions provide effective winning strategies. Moreover, an
high-order stack (that is a stack which elements are also stacks) is sufï¬cient as a memory for these strategies. The
number of nested stacks is n + 2 if the winning condition that we consider is of the form 	int
A1 â–·Â·Â·Â· â–·An â–·An+1 or
	ext
A1 â–·Â·Â·Â· â–·An+1 â–·An+2.
7. Conclusion and perspectives
We have provided a family of winning conditions that have an arbitrary ï¬nite Borel complexity while remaining
decidable for pushdown games and games on ï¬nite graphs. The complexity of deciding the winner for such a winning
condition is a non-elementary problem that is elementary-hard. In addition, for pushdown games, it gives an example
of decidable winning conditions inducing non-regular sets of winning positions. The exact form of the winning sets
remains open. Finally, we have shown that there are persistent winning strategies for pushdown games equipped with
these winning conditions. The existence of positional strategies remains open.
Studying the classes (Cn(A))nâˆˆN is also an interesting question. As they contain languages of arbitrary ï¬nite Borel
complexity, these classes are not included in the one of deterministic -context-free languages (which only contains
languages in B(2)). Are they a strict subclass of -context-free languages? Note that in case of inclusion it would be
372
O. Serre / Theoretical Computer Science 350 (2006) 345â€“372
strict as there are -context-free languages that are not Borel sets. From the game point of view, studying the closure
properties of these classes under boolean operations is also relevant. Finally, let us mention that the decidability of the
emptiness problem and the universality problem for languages of these classes directly follows from the decidability
of the games on ï¬nite graphs.
Acknowledgments
I gratefully acknowledge Jacques Duparc for suggesting me to study this family of conditions. His advice and
knowledge of Borel complexity were very important in this research. I would also like to express my thanks to Anca
Muscholl and to Solveig, for their help while writing this paper, and to the anonymous referees for their remarks.
References
[1] A. Arnold, A. Vincent, I. Walukiewicz, Games for synthesis of controlers with partial observation, Theoret. Comput. Sci. 303 (1) (2003) 7â€“34.
[2] A. Bouquet, O. Serre, I. Walukiewicz, Pushdown games with the unboundedness and regular conditions, Proc. FST TCS 2003: Foundations of
Software Technology and Theoretical Computer Science, 23rd Conf., Lecture Notes in Computer Science, Vol. 2914, Springer, Berlin, 2003,
pp. 88â€“99.
[3] T. Cachat, Uniform solution of parity games on preï¬x-recognizable graphs, Proc. Fourth Internat. Workshop on Veriï¬cation of Inï¬nite-State
Systems, Electronic Notes in Theoretical Computer Science, Vol. 68, Elsevier Science Publishers, Amsterdam, 2002.
[4] T. Cachat, J. Duparc, W. Thomas, Solving pushdown games with a 3-winning condition, Proc. 11th Annu. Conf. of the European Association
for Computer Science Logic, CSL 2002, Lecture Notes in Computer Science, Vol. 2471, Springer, Berlin, 2002, pp. 322â€“336.
[5] R.S. Cohen, A.Y. Gold, -computations on deterministic pushdown machines, J. Comput. System Sci. 3 (1978) 257â€“300.
[6] J. Duparc, Wadge hierarchy and Veblen hierarchy, Part I: Borel sets of ï¬nite rank, J. Symbolic Logic 66 (1) (2001) 56â€“86.
[7] E.A. Emerson, C.S. Jutla, A.P. Sistla, On model-checking for the mu-calculus and its fragments, Theoret. Comput. Sci. 258 (1â€“2) (2001)
491â€“522.
[8] O. Finkel, Topological properties of omega context-free languages, Theoret. Comput. Sci. 262 (2001) 669â€“697.
[9] H. Gimbert, Parity and exploration games on inï¬nite graphs, Proc. 13th Annu. Conf. of the European Association for Computer Science Logic,
CSL 2004, Lecture Notes in Computer Science, Vol. 3210, Springer, Berlin, 2004, pp. 56â€“70.
[10] M. JurdziÂ´nski, Small progress measures for solving parity games, in: STACS 2000, 17th Annu. Symp. on Theoretical Aspects of Computer
Science, Proc., Lecture Notes in Computer Science, Vol. 1770, Lille, France, Springer, Berlin, February 2000, pp. 290â€“301.
[11] A.S. Kechris, Classical Descriptive Set Theory, Graduate Texts in Mathematics, Vol. 156, Springer, Berlin, 1994.
[12] O. Kupferman, M.Y.Vardi,An automata-theoretic approach to reasoning about inï¬nite-state systems, Proc. CAVâ€™00, Lecture Notes in Computer
Science, Vol. 1855, Springer, Berlin, 2000, pp. 36â€“52.
[13] C. LÃ¶ding, private communication.
[14] J. Marcinkowski, T. Truderung, Optimal complexity bounds for positive LTL games, Proc. 11th Annu. Conf. of the European Association for
Computer Science Logic, CSL 2002, Lecture Notes in Computer Science, Vol. 2471, Springer, Berlin, 2002, pp. 262â€“275.
[15] D.A. Martin, Borel determinacy, Ann. Math. 102 (1975) 363â€“371.
[16] C.H. Papadimitriou, Complexity Theory, Addison-Wesley, Washington, UK, 1994.
[17] D. Perrin, J.-E. Pin, Inï¬nite words, Pure and Applied Mathematics, Vol. 141, Elsevier, Amsterdam, Academic Press, London, 2004.
[18] O. Serre, Note on winning positions on pushdown games with -regular conditions, Inform. Process. Lett. 85 (2003) 285â€“291.
[19] O. Serre, Contribution Ã  lâ€™Ã©tude des jeux sur des graphes de processus Ã  pile, Ph.D. Thesis, UniversitÃ© Paris 7, 2004.
[20] W. Thomas, On the synthesis of strategies in inï¬nite games, Proc. STACS â€™95, Lecture Notes in Computer Science, Vol. 900, Springer, Berlin,
1995, pp. 1â€“13.
[21] W. Thomas, Inï¬nite games and veriï¬cation (extended abstract of a tutorial) Proc. Internat. Conf. on Computer Aided Veriï¬cation CAVâ€™02,
Lecture Notes in Computer Science, Vol. 2404, Springer, Berlin, 2002, pp. 58â€“64.
[22] J. VÃ¶ge, M. JurdziÂ´nski, A discrete strategy improvement algorithm for solving parity games (Extended abstract), in: E.A. Emerson, A.P. Sistla
(Eds.), Computer Aided Veriï¬cation, 12th Internat. Conf. CAV 2000, Proc., Lecture Notes in Computer Science, Vol. 1855, Chicago, IL, USA,
Springer, Berlin, July 2000, pp. 202â€“215.
[23] W.W. Wadge, Reducibility and determinateness of the Baire space, Ph.D. Thesis, Berkeley, 1984.
[24] I. Walukiewicz, Pushdown processes: games and model checking, Inform. Comput. 157 (2000) 234â€“263.
[25] W. Zielonka, Inï¬nite games on ï¬nitely coloured graphs with applications to automata on inï¬nite trees, Theoret. Comput. Sci. 200 (1â€“2) (1998)
135â€“183.
