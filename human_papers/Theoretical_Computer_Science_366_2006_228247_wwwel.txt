Theoretical Computer Science 366 (2006) 228â€“247
www.elsevier.com/locate/tcs
Weighted tree automata and weighted logics
Manfred Drostea,âˆ—, Heiko Voglerb
aInstitute of Computer Science, Leipzig University, D-04109 Leipzig, Germany
bDepartment of Computer Science, Dresden University of Technology, D-01062 Dresden, Germany
Abstract
We deï¬ne a weighted monadic second order logic for trees where the weights are taken from a commutative semiring. We prove
that a restricted version of this logic characterizes the class of formal tree series which are accepted by weighted bottom-up ï¬nite state
tree automata. The restriction on the logic can be dropped if additionally the semiring is locally ï¬nite. This generalizes corresponding
classical results of Thatcher, Wright, and Doner for tree languages and it extends recent results of Droste and Gastin [Weighted
automata and weighted logics, in: Automata, Languages and Programmingâ€”32nd International Colloquium, ICALP 2005, Lisbon,
Portugal, 2005, Proceedings, Lecture Notes in Computer Science, Vol. 3580, Springer, Berlin, 2005, pp. 513â€“525, full version in
Theoretical Computer Science, to appear.] from formal power series on words to formal tree series.
Â© 2006 Elsevier B.V. All rights reserved.
Keywords: Weighted automata; Tree automata; MSO-logics; Formal power series
1. Introduction
In automata theory, BÃ¼chiâ€™s and Elgotâ€™s fundamental theorems [12,20] on the coincidence of regular languages with
languages deï¬nable in monadic second order logic (for short: MSO-logic) led to various extensions. Thatcher and
Wright [39] and Doner [16] established a corresponding equivalence for trees. Engelfriet [22,23] and Courcelle [14]
proved a characterization of a large class of context-free graph languages as images of MSO-deï¬nable functions on
sets of trees. Bloem and Engelfriet [4] proved that the tree transductions computed by a particular class of attributed
tree transducers coincide with the MSO-deï¬nable tree transductions. On a different strand, following SchÃ¼tzenberger
[35], weighted automata form a quantitative extension of classical automata, cf. [34,3,31] for surveys; this recently led
to practical applications in digital image compression [15,28], in model-checking of probabilistic systems [38,1] and
in natural language processing [13].
Very recently, Droste and Gastin [18] deï¬ned a weighted logic and obtained a characterization of the behavior of
weighted automata on words by sentences of this weighted logic, thereby extending BÃ¼chiâ€™s and Elgotâ€™s classical
results. Intuitively, this logic allows us to â€œcountâ€ how often a formula is true, thus it includes quantitative aspects.
In this paper, we will consider a weighted logic for trees and we will achieve an extension of the result of Thatcher and
Wright [39] and Doner [16] to the case of weighted tree automata.
âˆ—Corresponding author.
E-mail addresses: droste@informatik.uni-leipzig.de (M. Droste), vogler@tcs.inf.tu-dresden.de (H. Vogler).
0304-3975/$ - see front matter Â© 2006 Elsevier B.V. All rights reserved.
doi:10.1016/j.tcs.2006.08.025
M. Droste, H. Vogler / Theoretical Computer Science 366 (2006) 228â€“247
229
Weighted tree automata have been considered by a number of researchers [10,2,37,29,24,33,6,19] and have been
used for efï¬cient code selection [25,7]. In such tree automata, transitions are assigned a weight which might model,
e.g., resources used for its execution, length of time needed, or its reliability. To cope with such situations uniformly,
the weights are taken as elements of a semiring. In our weighted logic we take the elements of the given semiring as
atomic formulas. In order to deï¬ne the semantics of the negation of a formula, we restrict in our syntax negation to
atomic formulas. In comparison to the classical logics for trees, this is no essential restriction but forces us to include
universal quantiï¬cation into the syntax. However, already in weighted logics for words [18], in general there are
series deï¬nable in this general weighted logic which are not recognizable by weighted automata. Fortunately, we can
restrict universal quantiï¬cation appropriately. Our main result states that for any commutative semiring the behaviors of
weighted tree automata are precisely the series arising as semantics of sentences of our restricted weighted MSO-logic
(cf. Theorem 5.1). If the semiring is locally ï¬nite, all sentences of our weighted MSO-logic have recognizable semantics
(cf. Theorem 6.5).
The development of our weighted logic for trees is quite similar to the weighted logic for words [18]. Assuming
familiarity with the unweighted logics for trees, background results on weighted tree automata, and the arguments for
the word case in [18], several of our proofs can be obtained straightforwardly as an amalgamation and adjustment of the
existing proofs from these three strands. However, a main difference arises for the treatment of the universal quantiï¬er
on ï¬rst order variables. Roughly speaking, this difference is due to the need for synchronizing of variables in different
subtrees; this problem does not arise in the case of words.
Moreover, crucial differences and open problems occur with respect to constructibility and decidability questions.
Given any computable ï¬eld (e.g., the rational numbers), we can show that for any restricted weighted MSO-sentence we
can effectively construct an equivalent weighted tree automaton (cf. Corollary 5.8). Hence, given two such sentences,
we can decide whether their semantics are equal (cf. Corollary 5.9). But, our procedures are not primitive recursive.
This is due to the present lack of a comparable algebraic theory for weighted tree automata like it was developed for
weighted automata on words, cf. [3,31]. Consequently, it is open at present how to check (for suitable semirings like
arbitrary ï¬elds) whether a given weighted MSO-sentence for trees is restricted; for words this is possible [18]. This
calls for further research on such questions for weighted tree automata.
2. Tree languages and tree automata
Let N = {0, 1, 2, . . . }. A ranked alphabet is a tuple (, rk) where  is a ï¬nite set and rk :  â†’N. For
every mâ©¾0, the set of all symbols of  with rank m is denoted by (m). In the sequel we use the phrase â€œlet  be
a ranked alphabetâ€, if either the function rk is an arbitrary one or it is known from the context. We denote the value
max{rk() |  âˆˆ} by max. In examples, a particular ranked alphabet  is speciï¬ed by showing the set  and
attaching the respective rank to every symbol as superscript as, e.g.,  = {(2), (0)}. The set of (ï¬nite, labeled and
ordered) -trees, denoted by T, is the smallest subset T of ( âˆª{(, )} âˆª{, })âˆ—such that if  âˆˆ(m) with mâ©¾0 and
s1, . . . , sm âˆˆT , then (s1, . . . , sm) âˆˆT . In case m = 0, we identify ( ) with . Clearly T = âˆ…iff (0) = âˆ…. Since
we are not interested in the case that T = âˆ…, we assume that (0) Ì¸= âˆ…for every ranked alphabet  appearing in this
paper.
We deï¬ne the set of positions in a tree by means of the mapping pos: T â†’P(Nâˆ—) inductively as follows: (i)
if t âˆˆ(0), then pos(t) = {}, and (ii) if t = (s1, . . . , sm) where  âˆˆ(m), mâ©¾1 and s1, . . . , sm âˆˆT, then
pos(t) = {} âˆª{i.v | 1â©½i â©½m, v âˆˆpos(si)}.
For every t âˆˆT and w âˆˆpos(t), the label of t at w and the subtree of t at w, denoted by t(w) âˆˆ and
t|w âˆˆT, respectively, are deï¬ned inductively as follows: if t = (s1, . . . , sm) for some  âˆˆ(m) with mâ©¾0 and
s1, . . . , sm âˆˆT, then t() =  and t| = t, and if w = i.v and 1â©½i â©½m, then t(w) = si(v) and t|w = si|v.
Next we recall, for the convenience of the reader, basic back-ground on bottom-up ï¬nite state tree automata, also
see [26,27]. A bottom-up ï¬nite state tree automaton (for short: bu-fta) is a tuple M = (Q, , , F) where Q is a ï¬nite
set (of states),  is a ranked alphabet (of input symbols),  = ( |  âˆˆ) is a family of transition functions of the
form  : Qm â†’P(Q) where mâ©¾0 and  âˆˆ(m), and F âŠ†Q (ï¬nal states). A bottom-up ï¬nite state tree automaton
is deterministic if for every mâ©¾0,  âˆˆ(m), and q1, . . . , qm âˆˆQ, the set (q1, . . . , qm) is a singleton. In this case
we identify the set (q1, . . . , qm) with its element.
Now we deï¬ne the run semantics of a bu-fta M. Let t âˆˆT. A run of M on t is a mapping r : pos(t) â†’Q. A run r
is valid if whenever w âˆˆpos(t) and t(w) =  âˆˆ(m) for some mâ©¾0, then r(w) âˆˆ(r(w.1), . . . , r(w.m)). In other
230
M. Droste, H. Vogler / Theoretical Computer Science 366 (2006) 228â€“247
words, a run r is valid if at every position w the state r(w) is the result of applying the transition performed at w to the
states assigned to the predecessors of w.
Let RM(t) and Rv
M(t) denote the sets of all runs of M on t and all valid runs of M on t, respectively. We note that
if M is deterministic, then there is a unique valid run of M on t, denoted by rt.
The tree language accepted by M is the set L(M) = {t âˆˆT | âˆƒr âˆˆRv
M(t) : r() âˆˆF}. (We note that the run
semantics of M is equivalent to the initial algebra semantics which is usually associated with M, cf. e.g. [39, p. 58].)
A tree language L is recognizable (resp. deterministically recognizable) if there is a (resp. deterministic) bottom-up
ï¬nite state tree automaton M such that L = L(M). By applying the usual powerset construction, one obtains that
every recognizable tree language is also deterministically recognizable (cf. [39, Theorem 1]). It is well known that the
class of recognizable tree languages is closed under the boolean operations (i.e., union, intersection, and complement;
cf. [39, Theorem 2]).
Next we brieï¬‚y recall the MSO-logic on trees and the generalization of BÃ¼chiâ€™s result, namely that MSO-deï¬nable
tree languages are exactly the recognizable tree languages [39,16]. Let  be a ranked alphabet. The set MSO() of all
formulas of MSO-logic over  is deï¬ned as the smallest set F such that
(1) F contains all atomic formulas label(x), edgei(x, y), and x âˆˆX and
(2) if ,  âˆˆF, then also  âˆ¨,  âˆ§, Â¬, âˆƒx., âˆƒX., âˆ€x., âˆ€X. âˆˆF,
where  âˆˆ, x, y are ï¬rst order variables, 1â©½i â©½max, and X is a second order variable. The set of free variables of
 is denoted by Free().
Let V be a ï¬nite set of ï¬rst order and second order variables. The ranked alphabet V = ( Ã— {0, 1}V, rk) is deï¬ned
by rk((, f )) = rk() for every f âˆˆ{0, 1}V. For a symbol (, f ) âˆˆV we denote  by (, f )1 and f by (, f )2.
A V-tree s is valid if for every ï¬rst order variable x âˆˆV, there is exactly one w âˆˆpos(s) such that (s(w)2)(x) = 1.
The subset of TV containing all valid trees is denoted by T v
V . We put  = Free().
Every valid V-tree s corresponds to a pair (t, ) where t âˆˆT and  is a (V, t)-assignment; such an assignment
is a function which maps ï¬rst order variables in V to elements of pos(t) and second order variables in V to subsets
of pos(t). More precisely, we say that s and (t, ) correspond to each other if pos(t) = pos(s), t is obtained from s
by replacing s(w) by s(w)1 for every w âˆˆpos(t), and for every ï¬rst order variable x, second order variable X, and
w âˆˆpos(s), we have that (s(w)2)(x) = 1 iff (x) = w, and (s(w)2)(X) = 1 iff w âˆˆ(X). In the sequel we will
identify a valid V-tree with the corresponding pair (t, ).
Let s be an arbitrary V-tree, x be a ï¬rst order variable, and w âˆˆpos(s). Then s[x â†’w] is the Vâˆª{x}-labeled
tree obtained from s by putting (s[x â†’w](v)2)(x) = 1 iff v = w. Similarly, if X is a second order variable and
I âŠ†pos(s), then s[X â†’I] is the Vâˆª{X}-tree obtained from s by putting (s[X â†’I](v)2)(X) = 1 iff v âˆˆI. If here
s = (t, ), we also write s[x â†’w] = (t, [x â†’w]) and s[X â†’I] = (t, [X â†’I]).
Let  be a formula in MSO() and s = (t, ) be a valid V-tree such that Free() âŠ†V. Then the relation â€œ(t, )
satisï¬es â€, denoted by (t, ) âŠ¨, is deï¬ned as usual. We put
LV() = {(t, ) âˆˆT v
V | (t, ) âŠ¨}
and we will simply write L() instead of LFree()(). Now we recall the equivalence between recognizable tree lan-
guages and MSO-deï¬nable tree language; cf. [39, Theorems 14 and 17], [16, Theorems 3.7 and 3.9], or
[27, Proposition 12.2]: The tree language LV() is recognizable over V. Conversely, for every recognizable tree
language L over , there is an MSO-sentence  such that L = L(). It follows from this, but can also easily be shown
directly, that the set T v
V is recognizable.
Let us denote by MSOâˆ’() the set of all MSO()-formulas in which negation is applied only to atomic formulas.
By applying de Morganâ€™s laws and by pulling negation over a ï¬rst or second order quantiï¬er (as, e.g., by Â¬(âˆ€x.) â†’
âˆƒx.Â¬), we obtain the well-known fact that for every  âˆˆMSO() there is a  âˆˆMSOâˆ’() such that L() =
L().
3. Tree series and weighted tree automata
A semiring is an algebraic structure (K, +, Â·, 0, 1) with operations sum + and product Â· and constants 0 and 1
such that (K, +, 0) is a commutative monoid and (K, Â·, 1) is a monoid, multiplication distributes over addition, and
a Â· 0 = 0 Â· a = 0 for every a âˆˆK. Whenever the operations and constants of a semiring are clear from the context,
M. Droste, H. Vogler / Theoretical Computer Science 366 (2006) 228â€“247
231
we abbreviate (K, +, Â·, 0, 1) by K.The semiring K is commutative if Â· is commutative. Important examples of semirings
are
â€¢ the boolean semiring B = ({0, 1}, âˆ¨, âˆ§, 0, 1) with disjunction âˆ¨and conjunction âˆ§,
â€¢ the semiring of natural numbers (N, +, Â·, 0, 1), abbreviated by N, with the usual addition and multiplication,
â€¢ the tropical semiring Trop = (N âˆª{âˆ}, min, +, âˆ, 0) where the sum and the product operations are min and +,
resp., extended to N âˆª{âˆ} in the usual way.
A (formal) tree series is a mapping S : T â†’K where usually (S, t) is written rather than S(t). The support of S is the
set supp(S) = {t âˆˆT | (S, t) Ì¸= 0}, and the image of S is the set im(S) = {(S, t) | t âˆˆT}. The set of all tree series
(over  and K) is denoted by KâŸ¨âŸ¨TâŸ©âŸ©. For two tree series S, T âˆˆKâŸ¨âŸ¨TâŸ©âŸ©and k âˆˆK, the sum S + T , the Hadamard
product S âŠ™T , and the product k Â·S are each deï¬ned pointwise for every t âˆˆT as follows: (S +T, t) = (S, t)+(T, t),
(S âŠ™T, t) = (S, t) Â· (T, t), and (k Â· S, t) = k Â· (S, t).
For every L âŠ†T, the characteristic tree series 1L : T â†’K is deï¬ned for every t âˆˆT by (1L, t) = 1 if t âˆˆL,
and (1L, t) = 0 otherwise.
A tree series S : T â†’K is a recognizable step function if there are an nâ©¾1 and recognizable tree languages
L1, . . . , Ln âŠ†T such that S = n
i=1 ki Â· 1Li.
Lemma 3.1. Let S : T â†’K be a recognizable step function. Then there is a partitioning U1, . . . , Um of T where
U1, . . . , Um are recognizable tree languages, and there are l1, . . . , lm âˆˆK such that S = m
i=1li Â· 1Ui.
Proof. Let S = n
i=1ki Â· 1Li for some nâ©¾1 and recognizable tree languages L1, . . . , Ln âŠ†T. Let F be the set of all
mappings of type {1, . . . , n} â†’{1, c}. For every mapping f âˆˆF, deï¬ne the tree language Uf = n
i=1 Lf (i)
i
where
L1
i = Li and Lc
i = T \ Li. Note that the Uf â€™s form a partitioning of T. For every such f deï¬ne lf = 
iâˆˆf âˆ’1(1)ki.
Then clearly, S = 
f âˆˆF lf Â· 1Uf .
â–¡
This shows that S is a recognizable step function iff im(S) is ï¬nite and for every k âˆˆK, the set Sâˆ’1(k) = {t âˆˆT |
(S, t) = k} is a recognizable tree language.
Now we introduce weighted bottom-up ï¬nite state tree automata and their behavior. For further investigations, see
[2,29,11,24,33,6,19].
Let (K, +, Â·, 0, 1) be a commutative semiring. Moreover, let Q be a ï¬nite set (of states) and  a ranked alphabet
(of input symbols). A (bottom-up) tree representation (over Q, , and K) is a family 	 = (	m | m âˆˆN) of mappings
	m : (m) â†’KQmÃ—Q. A weighted bottom-up ï¬nite state tree automaton (over K) (for short: wta) is a quadruple
M = (Q, , 	, 
) where 	 is a tree representation over Q, , and K, and 
 : Q â†’K is the weight function for leaving
a state (ï¬nal weights). (We note that we view KQmÃ—Q as the set of (Qm Ã— Q)-matrices with entries taken from K;
thus, following the usual matrix notations, for every mâ©¾0,  âˆˆ(m), and q1, . . . , qm, q âˆˆQ we write 	m()q1...qm,q
to denote the entry in the matrix 	m() at row (q1, . . . , qm) and at column q.)
In this paper we will associate the run semantics with a wta as deï¬ned, e.g., in [19]. (We note that the run semantics
is equivalent to the initial algebra semantics, cf. [6, Lemma 4.1.13].)
Let t âˆˆT and r : pos(t) â†’Q be a run of M on t; also let w âˆˆpos(t). The weight wtM(t, r, w) of r on t at w is
deï¬ned as follows: if t(w) =  âˆˆ(m) for some mâ©¾0, then
wtM(t, r, w) = 	m()r(w.1)...r(w.m),r(w).
The weight of r on t is deï¬ned by
wtM(t, r) =

wâˆˆpos(t)
wtM(t, r, w)
(recall that K is a commutative semiring). We note that here we associate with every run a weight and need not deï¬ne
the concept of valid runs; so to speak, a run on t is â€œvalidâ€ or â€œmakes senseâ€, if all values wtM(t, r, w) (w âˆˆpos(t))
are non-zero. Note that wtM(t, r) = 0 can also arise due to zero-divisors in K.
The tree series accepted by M, denoted by SM âˆˆKâŸ¨âŸ¨TâŸ©âŸ©, is the tree series deï¬ned, for every t âˆˆT, by
(SM, t) =

râˆˆRM(t)
wtM(t, r) Â· 
(r()).
232
M. Droste, H. Vogler / Theoretical Computer Science 366 (2006) 228â€“247
Fig. 1. Example of an input tree with its zig-zag path and the sets X and Y of nodes.
A tree series S âˆˆKâŸ¨âŸ¨TâŸ©âŸ©is called recognizable if there is a wta M over K such that S = SM. The class of all
recognizable tree series is denoted by KrecâŸ¨âŸ¨TâŸ©âŸ©. Clearly, supp(BrecâŸ¨âŸ¨TâŸ©âŸ©) is the class of recognizable tree languages.
Example 3.2 (length of the zig-zag path). Let  = {(2), (0)} be a ranked alphabet. For every t âˆˆT, the zig-zag
path of t is the unique path of t which starts at its root and alternatingly moves down to the ï¬rst or second successor of
the current node, until a leaf is reached. For instance, the zig-zag path of t = ((, (, )), ) contains four nodes
which are labeled by , , , and , respectively (cf. Fig. 1 ignoring the sets X and Y at the time being). Thus, we
can deï¬ne the tree series zigzag âˆˆNâŸ¨âŸ¨TâŸ©âŸ©over the natural number semiring such that for every t âˆˆT, the value
(zigzag, t) is the number of nodes (or positions) on the zig-zag path of t.
Next we describe a wta M = (Q, , 	, 
) over N such that SM = zigzag. Let t be an arbitrary input tree. The idea
of processing t is as follows. M can read every input subtree in the blind state d thereby producing weight 1. At every
node v, M can start to check, whether v lies on the zig-zag path of t or not (check for membership on the zig-zag path);
this is done by using two states 1 and 2; the state 2 has ï¬nal weight 
(2) = 1, all the other states have ï¬nal weight 0.
Formally, we deï¬ne the wta M = (Q, , 	, 
) over the semiring of natural numbers as follows:
â€¢ Q = {1, 2, d},
â€¢ 
(2) = 1 and 
(1) = 
(d) = 0,
â€¢ blind acceptance:
	0(),d = 	2()dd,d = 1,
switching from blind acceptance to checking:
	2()dd,1 = 	2()dd,2 = 1
check for membership on the zig-zag path:
	0(),2 = 	0(),1 = 	2()1d,2 = 	2()d2,1 = 1,
for every other combination q1, q2, q3 âˆˆQ we deï¬ne
	2()q1q2,q3 = 0.
Clearly, we only have to take into consideration those runs on an input tree t which end up at the root in state 2 (because
for every other run r we have wtM(t, r) Â· 
(r()) = 0). Intuitively, it is clear that there are as many such runs on t as
the zig-zag path has positions; every such run has weight 1; this sums up to (zigzag, t).
â–¡
Next we turn to basic properties of recognizable tree series.
Lemma 3.3. Let K be a semiring.
(1) Let L âŠ†T be a recognizable tree language. Then 1L âˆˆKâŸ¨âŸ¨TâŸ©âŸ©is recognizable.
M. Droste, H. Vogler / Theoretical Computer Science 366 (2006) 228â€“247
233
(2) For every k âˆˆK, the constant tree series k âˆˆKâŸ¨âŸ¨TâŸ©âŸ©which maps every tree to k, is recognizable.
(3) Let K be commutative and S, T âˆˆKâŸ¨âŸ¨TâŸ©âŸ©be recognizable. Then S + T and S âŠ™T are recognizable.
Proof. (1) Let L âŠ†T be accepted by the deterministic bottom-up ï¬nite state tree automaton M = (Q, , , F).
Then construct the wta MK = (Q, , 	, 
) over K as follows: for every mâ©¾0,  âˆˆ(m), and q, q1, . . . , qm âˆˆQ, let
	m()q1...qm,q = 1 if q = m(q1, . . . , qm), and 	m()q1...qm,q = 0 otherwise, and for every q âˆˆQ, let 
(q) = 1 if
q âˆˆF and 
(q) = 0 otherwise. Clearly, SMK = 1L(M) = 1L.
(2) Consider the wta M = (Q, , 	, 
) where Q = {q}, for every mâ©¾0 and  âˆˆ(m), deï¬ne 	m()qm,q = 1 where

(q) = k. Clearly, SM = k.
(3) Let S, T âˆˆKâŸ¨âŸ¨TâŸ©âŸ©be accepted by wta M1 and M2, respectively. We can assume that the sets of states of M1
and M2 are disjoint. Then we can construct in the well-known way (by â€œtaking the union of M1 and M2â€) a wta M
such that SM = S + T (cf. e.g., [19, Lemma 6.4]). The claim for S âŠ™T has been proved in [5, Corollary 3.9] (also cf.
[2, Proposition 5.1]).
â–¡
As an immediate consequence of Lemma 3.3, every recognizable step function is a recognizable series. Finally,
we recall that the class of recognizable tree series is closed under relabelings. For this, let  and  be two ranked
alphabets and  :  â†’P() be a mapping such that () âŠ†(m) for every mâ©¾0 and  âˆˆ(m). This mapping is
extended to a mapping â€² : T â†’P(T) by deï¬ning inductively â€²((s1, . . . , sm)) = {(t1, . . . , tm) |  âˆˆ(), t1 âˆˆ
â€²(s1), . . . , tm âˆˆâ€²(sm)} for every mâ©¾0,  âˆˆ(m), and s1, . . . , sm âˆˆT. Note that every such mapping â€² is a
relabeling (in the sense of [21, Deï¬nition 3.1]); that is, it can be computed by a one-state, linear, and nondeleting
bottom-up or top-down tree transducer. Also note that the set {s | t âˆˆâ€²(s)}) is ï¬nite for every t âˆˆT. We will denote
â€² also by . Next we extend  to a mapping  : KâŸ¨âŸ¨TâŸ©âŸ©â†’KâŸ¨âŸ¨TâŸ©âŸ©by deï¬ning ((S), t) = 
sâˆˆT,tâˆˆ(s) (S, s) for
every S âˆˆKâŸ¨âŸ¨TâŸ©âŸ©and t âˆˆT. In the sequel we call mappings like  relabelings.
We note that relabelings can be computed by particular linear nondeleting tree transducers in the sense of [30]. There
the closure of the class of recognizable tree series under such transducers is proved, cf. [30, Corollary 14]; however,
throughout that paper it is assumed that semirings are commutative and continuous. Since we want to prove our main
results for commutative semirings which are not necessarily continuous, we give a direct construction for this closure
property.
Lemma 3.4. Let S âˆˆKâŸ¨âŸ¨TâŸ©âŸ©and  : KâŸ¨âŸ¨TâŸ©âŸ©â†’KâŸ¨âŸ¨TâŸ©âŸ©be a relabeling. If S is recognizable, then (S) is recogniz-
able.
Proof. Let M = (Q, , 	, 
) be a wta over K and  :  â†’P() such that () âŠ†(m) for every  âˆˆ(m). Construct
the wta Mâ€² = (Q, , 	â€², 
) over K where 	â€²
m()q1...qm,q = 
âˆˆ,âˆˆ() 	m()q1...qm,q for every mâ©¾0,  âˆˆ(m), and
q1, . . . , qm, q âˆˆQ.
First we note the following auxiliary statement: for every t âˆˆT and râ€² âˆˆRMâ€²(t) the equation
wtMâ€²(t, râ€²) =

sâˆˆT,tâˆˆ(s)
wtM(s, râ€²)
(1)
holds. Note that for every s âˆˆT with t âˆˆ(s) we have pos(s) = pos(t) and thus also RM(s) = RMâ€²(t). The proof of
Eq. (1) is straightforward and thus left to the reader.
Then we can compute as follows: (SMâ€², t) = 
râ€²âˆˆRMâ€²(t) wtMâ€²(t, râ€²)Â·
(râ€²())
(1)
= 
râ€²âˆˆRMâ€²(t)

sâˆˆT,tâˆˆ(s) wtM(s, râ€²)Â·

(râ€²()) = 
sâˆˆT,tâˆˆ(s)

râ€²âˆˆRMâ€²(t) wtM(s, râ€²) Â· 
(râ€²()) = 
sâˆˆT,tâˆˆ(s) (SM, s) = ((SM), t).
â–¡
4. Weighted MSO-logic on trees
Here we will deï¬ne the weighted MSO-logic on trees. This is a generalization of the weighted MSO-logic
(on strings) as given in [18]. On the other hand, it generalizes (unweighted) MSO-logic on trees in the same way
as weighted MSO-logic generalizes (unweighted) MSO-logic on strings. We will also provide basic properties of our
weighted MSO-logic.
In this section we will always assume that the underlying semiring (K, +, Â·, 0, 1) is commutative. Moreover,
we assume that  is a ranked alphabet.
234
M. Droste, H. Vogler / Theoretical Computer Science 366 (2006) 228â€“247
Deï¬nition 4.1. The set MSO(K, ) of all formulas of weighted MSO-logic over K and  on trees (for short: weighted
MSO-logic) is deï¬ned to be the smallest set F such that
(1) F contains all the atomic formulas k, label(x), edgei(x, y), and x âˆˆX and the negations Â¬label(x),
Â¬edgei(x, y), and Â¬(x âˆˆX), and
(2) if ,  âˆˆF, then also  âˆ¨,  âˆ§, âˆƒx., âˆƒX., âˆ€x., âˆ€X. âˆˆF,
where k âˆˆK,  âˆˆ, x, y are ï¬rst order variables, 1â©½i â©½max(rk()), and X is a second order variable.
Clearly, if we drop formulas of the form k from MSO(K, ), then we obtain MSOâˆ’(). That is, MSOâˆ’() âŠ†
MSO(K, ).
Deï¬nition 4.2. Let  âˆˆMSO(K, ) and V be a ï¬nite set of variables containing Free(). The semantics of  is the
formal tree series V âˆˆKâŸ¨âŸ¨TV âŸ©âŸ©deï¬ned as follows: if s âˆˆTV is not valid, then we put (V, s) = 0. Otherwise,
we deï¬ne (V, s) âˆˆK inductively as follows where (t, ) corresponds to s.
(kV, s) = k,
(label(x)V, s) =
 1
if t((x)) = ,
0
otherwise,
(edgei(x, y)V, s) =
 1
if (y) = (x).i,
0
otherwise,
(x âˆˆXV, s) =
 1
if (x) âˆˆ(X),
0
otherwise ,
(Â¬V, s) =
 1
if (V, s) = 0,
0
if (V, s) = 1
if  is of the form label(x), edgei(x, y), or x âˆˆX,
( âˆ¨V, s) = (V, s) + (V, s),
( âˆ§V, s) = (V, s) Â· (V, s),
(âˆƒx.V, s) =

wâˆˆpos(s)
(Vâˆª{x}, s[x â†’w]),
(âˆƒX.V, s) =

IâŠ†pos(s)
(Vâˆª{X}, s[X â†’I]),
(âˆ€x.V, s) =

wâˆˆpos(s)
(Vâˆª{x}, s[x â†’w]),
(âˆ€X.V, s) =

IâŠ†pos(s)
(Vâˆª{X}, s[X â†’I]).
We write  rather than Free(). Note that if  is a sentence, then  âˆˆKâŸ¨âŸ¨TâŸ©âŸ©. Also note that the unweighted
case is obtained by considering the Boolean semiring B: in fact, if we view an (unweighted) formula  in MSOâˆ’()
as a formula in MSO(B, ), and calculate  âˆˆBâŸ¨âŸ¨TâŸ©âŸ©, then the disjunction âˆ¨and the conjuction âˆ§occurring in 
are interpreted (as usual) by inï¬mum and supremum, respectively; so, in particular, both distributivity laws hold. In
general, for arbitrary commutative semirings, only conjunction distributes over disjunction.
In the weighted case we will also work with formulas from MSOâˆ’() and, in particular, with the quantiï¬er-free
fragment of MSOâˆ’(), denoted by qf-MSOâˆ’(); this is the set of all formulas in MSOâˆ’() which do not contain
any quantiï¬er. For such formulas, it will be necessary to disambiguate disjunctions. For this purpose, we deï¬ne the
syntactic transformations (.)+ and (.)âˆ’on qf-MSOâˆ’() by simultaneous induction as follows: for every ,  âˆˆqf-
MSOâˆ’(),
(1) if  is atomic or the negation of an atomic formula, then we deï¬ne + =  and âˆ’= Â¬ with the convention
that Â¬Â¬ is ,
M. Droste, H. Vogler / Theoretical Computer Science 366 (2006) 228â€“247
235
(2) ( âˆ¨)+ = + âˆ¨(âˆ’âˆ§+) and ( âˆ¨)âˆ’= âˆ’âˆ§âˆ’, and
(3) ( âˆ§)âˆ’= âˆ’âˆ¨(+ âˆ§âˆ’) and ( âˆ§)+ = + âˆ§+.
Clearly, LV(+) = LV() and LV(âˆ’) = T v
V \ LV().
While specifying a particular tree series by means of a weighted MSO-formula it is often helpful to use the implication
symbol as a macro (as in the unweighted case). However, in the weighted case, the macro has to be deï¬ned more
carefully, because negation is only available on atomic formulas. Also we want to disambiguate disjunctions. Formally,
let  âˆˆqf-MSOâˆ’() and  âˆˆMSO(K, ). Then we deï¬ne  â†’ as a shorthand for the formula âˆ’âˆ¨(+ âˆ§).
If ,  âˆˆqf-MSOâˆ’(), let  â†” abbreviate ( â†’) âˆ§( â†’).
We can now show that the formal power series semantics of such disambiguous formulas only take 0 and 1 as values.
Observation 4.3. Let  âˆˆqf-MSOâˆ’() and V be a ï¬nite set of variables containing Free(). Then +V = 1LV()
and âˆ’V = 1LV(Â¬). In particular, +V and âˆ’V are recognizable.
Proof. Straightforward induction on the structure of .
â–¡
Next we show that universal ï¬rst order quantiï¬cation preserves characteristic tree series.
Observation 4.4. Let  âˆˆMSOâˆ’() and V = Free() âˆª{x}. If V = 1LV(), then âˆ€x. = 1L(âˆ€x.).
Proof. Let s = (t, ) âˆˆTFree(âˆ€x.). Clearly, (âˆ€x., s) âˆˆ{0, 1}. In fact,
(âˆ€x., s) = 1 iff âˆ€w âˆˆpos(s) : (Free()âˆª{x}, s[x â†’w]) = 1
iff âˆ€w âˆˆpos(s) : s[x â†’w] âˆˆLFree()âˆª{x}()
iff s âˆˆL(âˆ€x.).
â–¡
Examples for sentences in this weighted logic for words have been given in [18]. Here we give two further examples
for our setting of trees.
Example 4.5 (number of leaves). Let  = {(2), (0), (0)} be a ranked alphabet and K be an arbitrary semiring.
Consider the formula  = âˆƒx.label(x) in MSO(K, ). For every tree t, then

âˆƒx.label(x), t

=

wâˆˆpos(t)
(label(x){x}, t[x â†’w])
= |{w âˆˆpos(t) | t(w) = }|,
the number (in K) of -leaves of t. For instance, if K = N, the semiring of natural numbers, this is the actual
number; if K = Z/3Z, this is the actual number modulo 3; if K = B, this is 1 if there is an -leaf in t, and 0
otherwise.
Example 4.6 (length of the zig-zag path). Consider the formal tree series zigzag of Example 3.2 which associates to
every tree the number of the positions on its zig-zag path. Here we will show that zigzag is MSO(N, )-deï¬nable.
Consider the following formula in MSO(N, ) (cf. Fig. 1 for the input tree ((, (, )), ), the zig-zag path indicated
as double line, and the sets X and Y of nodes):
 = âˆƒX.âˆƒY.(root âˆˆX \ Y) âˆ§(edge1(X) = Y) âˆ§(edge2(Y) = X) âˆ§count(X, Y),
where the four macros are deï¬ned as follows:
â€¢ (root âˆˆX \ Y) = âˆƒz.root(z) âˆ§(z âˆˆX) âˆ§Â¬(z âˆˆY),
â€¢ root(z) = âˆ€zâ€².Â¬edge1(zâ€², z) âˆ§Â¬edge2(zâ€², z),
â€¢ (edge1(X) = Y) = âˆ€x.âˆ€y.edge1(x, y) â†’

Â¬(y âˆˆX) âˆ§(x âˆˆX â†”y âˆˆY)

,
â€¢ (edge2(Y) = X) = âˆ€x.âˆ€y. edge2(y, x) â†’

Â¬(x âˆˆY) âˆ§(y âˆˆY â†”x âˆˆX)

,
â€¢ count(X, Y) = âˆƒz.(z âˆˆX) âˆ¨(z âˆˆY).
236
M. Droste, H. Vogler / Theoretical Computer Science 366 (2006) 228â€“247
Since the root of a tree is unique, we obtain that (root âˆˆX \ Y) = 1L for L = {(t, ) âˆˆT{X,Y} |  âˆˆ
(X)\(Y)}. Since the predecessor of a node is uniquely determined, by Observation 4.4 the series (edge1(X) = Y)
and (edge2(Y) = X are recognizable step functions with values in {0, 1}. Also, for every s = (t, ) âˆˆT{X,Y}, the
following two statements are equivalent:
(1) ((root âˆˆX \ Y) âˆ§(edge1(X) = Y) âˆ§(edge2(Y) = X), s) = 1,
(2)
â€¢ (X) âˆª(Y) is exactly the set of nodes of the zig-zag path through the root of s,
â€¢ the root of s is in (X) \ (Y),
â€¢ for every w âˆˆpos(s) âˆ©(Y), the predecessor of w is in (X) \ (Y), and
â€¢ for every w âˆˆ(pos(s) âˆ©(X)) \ {}, the predecessor of w is in (Y) \ (X).
Then  âˆˆNâŸ¨âŸ¨TâŸ©âŸ©is the tree series such that, for every tree t âˆˆT, the number (, t) is the length of the zig-zag
path through t. For instance, (, ((, (, )), )) = 4. Here, N can also be replaced by an arbitrary commutative
semiring, and similar remarks as at the end of Example 4.5 apply.
Recall that we have deï¬ned the semantics V for any ï¬nite set of variables V containing Free(). Now we show
that these semanticsâ€™ are consistent with each other.
Lemma 4.7. Let  âˆˆMSO(K, ) and V a ï¬nite set of variables containing Free(). Then, for every (t, ) âˆˆT v
V ,
(V, (t, )) = (, (t, |Free())).
Moreover,  is recognizable iff V is recognizable.
Proof. The ï¬rst statement can be proved analogously to [18, Proposition 3.3]. For the ï¬nal claim consider the mapping
 : V â†’ such that (s) = (t, |Free()) for every s = (t, ) âˆˆTV . We ï¬rst assume that  is recognizable. We
deï¬ne the relabeling in the sense of Section 3 which is induced by âˆ’1 :  â†’P(V).Then V = âˆ’1()âŠ™1T v
V .
Thus, by Lemma 3.4, also âˆ’1() is recognizable. Since T v
V is a recognizable tree language, it follows from Lemma
3.3 that V is recognizable.
Conversely, let V be recognizable. Let F âŠ†T v
V be the set of those trees s = (t, ) such that (x) =  (resp.
(X) = {}) for every variable x (resp. X) in V \ Free(). Then F is a recognizable tree language and for every
(t, â€²) âˆˆT v
 there is a unique (t, ) âˆˆF such that ((t, )) = (t, â€²). Then  = (V âŠ™1F ) and by Lemmata 3.3
and 3.4 we have that  is recognizable.
â–¡
Now let Z âŠ†MSO(K, ). We will call a tree series S : T â†’K Z-deï¬nable if there is a sentence  âˆˆZ such that
S = . It has been shown in [18] that there are MSO(, K)-deï¬nable series which are not recognizable. Consider
e.g. the formula  = âˆ€x.âˆ€y.2 over the semiring N of natural numbers and a monadic ranked alphabet  = {(1), (0)}
(cf. [18, Example 3.4]). Then, for every t = n(), (, t) = 2(n+1)2. However, these values cannot be reached by
any wta. Thus, we look for a careful restriction of MSO(, K) by means of which the class KrecâŸ¨âŸ¨TâŸ©âŸ©is characterised.
We follow the lines of [18].
Deï¬nition 4.8. A formula  âˆˆMSO(K, ) is restricted, if it does not contain a universal set quantiï¬cation of the form
âˆ€X., and whenever  contains a universal ï¬rst order quantiï¬cation of the form âˆ€x., then  is a recognizable step
function.
The set of all restricted formulas of MSO(K, ) is denoted by RMSO(K, ). The set of all restricted existential
formulas of MSO(K, ), denoted by REMSO(K, ), is the set of all restricted formulas of MSO(K, ) of the form
 = âˆƒX1, . . . , Xn. with  containing no set quantiï¬cation. Observe that in contrast, in RMSO(K, )-formulas
existential set quantiï¬ers might occur also in the interior of the formula, possibly after a universal ï¬rst order quantiï¬er.
The set of all tree series S âˆˆKâŸ¨âŸ¨TâŸ©âŸ©which are deï¬nable by some sentence in RMSO(K, ) (resp. in REMSO(K, ))
is denoted by KrmsoâŸ¨âŸ¨TâŸ©âŸ©(resp. KremsoâŸ¨âŸ¨TâŸ©âŸ©). An example of a formula in REMSO(K, ) is  of Example 4.6.
Only a very special case of the following lemma will be needed later on. We include a general statement due to the
independent importance of implications.
M. Droste, H. Vogler / Theoretical Computer Science 366 (2006) 228â€“247
237
Lemma 4.9. Let  âˆˆqf-MSOâˆ’(), let  âˆˆMSO(K, ), and let V be a ï¬nite set of variables containing Free() âˆª
Free(). Then  â†’V = âˆ’V + +V âŠ™V. Moreover, if  is a recognizable step function (resp.,
recognizable), then so is  â†’.
Proof. The equation claimed is immediate from the deï¬nition of the macro  â†’. Since the intersection of two
recognizable tree languages is again recognizable, it easily follows that the class of recognizable step functions is
closed under the Hadamard product. This, Lemma 4.7, and Observation 4.3 imply the claim for  â†’ if  is a
recognizable step function. If  is just recognizable, apply Lemma 4.7, Observation 4.3 and Lemma 3.3.
â–¡
5. The main result
The main result of this paper shows the coincidence of recognizability, RMSO-, and REMSO-deï¬nability of tree
series.
Theorem 5.1. Let  be a ranked alphabet and K any commutative semiring. Then KrecâŸ¨âŸ¨TâŸ©âŸ©= KrmsoâŸ¨âŸ¨TâŸ©âŸ©=
KremsoâŸ¨âŸ¨TâŸ©âŸ©.
This result generalizes the corresponding result of [18] for series on words to series on trees; we obtain the word
result from Theorem 5.1 by considering monadic ranked alphabets . Theorem 5.1 will be proved in Sections 5.1 and
5.2. Throughout, we assume that K is a commutative semiring.
5.1. Deï¬nable tree series are recognizable
As in the unweighted case, we prove this implication by induction on the structure of the formula. We start with
atomic formulas.
Lemma 5.2. Let  âˆˆMSO(K, ) be atomic or the negation of an atomic formula. Then  is recognizable.
Proof. If  = k where k âˆˆK, we apply Lemma 3.3. Now let  be of the form label(x) or (edgei(x, y)) or (x âˆˆX)
or a negation of these formulas. Then  âˆˆqf-MSOâˆ’(), so L() is a recognizable tree language. Hence  = 1L()
is recognizable.
â–¡
Now we turn to disjunction and conjunction.
Lemma 5.3. Let ,  âˆˆMSO(K, ) such that  and  are recognizable tree series. Then  âˆ¨ and  âˆ§
are recognizable.
Proof. Let V = Free() âˆªFree(). By Deï¬nition 4.2,  âˆ¨ = V + V and  âˆ§ = V âŠ™V which
are recognizable due to Lemmas 3.3 and 4.7.
â–¡
Next we prove that tree series deï¬ned by formulas of the form âˆƒx. or âˆƒX. are recognizable.
Lemma 5.4. Let  âˆˆMSO(K, ) such that  is recognizable. Then âˆƒx. and âˆƒX. are recognizable.
Proof. âˆƒX. : let V = Free(âˆƒX.); note that X /âˆˆV. Consider the relabeling  : TVâˆª{X} â†’TV deï¬ned by erasing
the X-row, i.e., (t, ) = (t, |V). Let s âˆˆTV . We note that s is valid iff s[X â†’I] is valid for every I âŠ†pos(s).
Hence, by deï¬nition of âˆƒX. and of relabeling, we have for every s âˆˆTV :
(âˆƒX., s) =

IâŠ†pos(s)
(Vâˆª{X}, s[X â†’I])
=

tâˆˆâˆ’1(s)
(Vâˆª{X}, t)
= ((Vâˆª{X}), s).
238
M. Droste, H. Vogler / Theoretical Computer Science 366 (2006) 228â€“247
Thus, âˆƒX. = (Vâˆª{X}). Since Free() âŠ†V âˆª{X} and  is recognizable, by Lemma 4.7 also Vâˆª{X} is
recognizable. Hence by Lemma 3.4, also âˆƒX. is recognizable.
âˆƒx. : Let V = Free(âˆƒx.); note that x /âˆˆV. Consider the relabeling  : TVâˆª{x} â†’TV which is deï¬ned by
erasing the x-row, as above. Let s âˆˆTV . We note that s is valid iff s[x â†’w] is valid for every w âˆˆpos(s). Then we
have for every s âˆˆTV :
(âˆƒx., s) =

wâˆˆpos(s)
(Vâˆª{x}, s[x â†’w])
= (1)

tâˆˆâˆ’1(s)
tis valid
(Vâˆª{x}, t)
= (2)

tâˆˆâˆ’1(s)
(Vâˆª{x}, t)
= ((Vâˆª{x}), s).
At (1) observe that, if s is valid, there is a bijection between the index sets pos(s) and T v
Vâˆª{x} âˆ©âˆ’1(s); if s is not
valid, then the set T v
Vâˆª{x} âˆ©âˆ’1(s) is empty. For (2), note that (Vâˆª{x}, t) = 0 for every non-valid t. Now we proceed
as in the previous case and obtain that âˆƒx. is recognizable.
â–¡
In the next lemma we prove that tree series deï¬nable by formulas of the form âˆ€x. are recognizable if  is a
recognizable step function. The idea of the construction of the wta is the same as in [18, Lemma 4.4]. However, here
we also have to â€œsynchronizeâ€ variables in different subtrees (a more detailed explanation is given inside the proof);
this problem does not arise in the case of words.
Lemma 5.5. Let  âˆˆMSO(K, ) such that  is a recognizable step function. Then âˆ€x. is recognizable.
Proof. Let W = Free() and V = Free(âˆ€x.) = W \ {x}. By assumption,  = n
j=1 kj Â· 1Lj for some nâ©¾1,
kj âˆˆK, and recognizable tree languages L1, . . . , Ln âŠ†TW . By Lemma 3.1 we can assume that the sets L1, . . . , Ln
form a partition of TW .
First we assume that x âˆˆW. Let  = Ã—{1, . . . , n} be the ranked alphabet with rank function rk((, j)) = rk()
for every (, j) âˆˆ. A tree s âˆˆTV corresponds to the tuple (sâ€², ) where sâ€² âˆˆTV is obtained from s by dropping the
second component from the label of every node, and  : pos(s) â†’{1, . . . , n} is deï¬ned by (w) = j if s(w) = (, j, f )
for some  âˆˆ and f âˆˆ{0, 1}V. Vice versa, every such tuple (sâ€², ) corresponds to a tree s âˆˆTV . Hence we can
assume that elements of TV have the form (sâ€², ). Then let
L = {(sâ€², ) âˆˆTV | âˆ€w âˆˆpos(sâ€²), 1â©½j â©½n : if (w) = j, then sâ€²[x â†’w] âˆˆLj}.
Note that for every sâ€² âˆˆTV there is a unique  such that (sâ€², ) âˆˆL, because the Ljâ€™s form a partition of TW .
Next we prove that L is a recognizable tree language. In fact, L = 
1â©½j â©½n 
Lj where

Lj = {(sâ€², ) âˆˆTV | âˆ€w âˆˆpos(sâ€²) : if (w) = j, then sâ€²[x â†’w] âˆˆLj}.
We prove that 
Lj is recognizable. Let Mj = (Q, W, , F) be a deterministic bottom-up ï¬nite state tree automaton
such that L(Mj) = Lj. We will construct the deterministic bottom-up ï¬nite state tree automaton 
Mj = (
Q,V,, 
F)
which recognizes 
Lj. The main idea in this construction is taken from the corresponding result of [18] and it is roughly
described as follows. On an input tree s = (sâ€², ), the automaton 
Mj simulates the work of Mj on sâ€² and, whenever
a position w of sâ€² is encountered for which (w) = j holds, then, additionally, 
Mj splits off a copy of Mj; this copy
behaves as if at w the x would occur. However, here we have to reï¬ne this idea a bit, because we have to guarantee
that the placement of x is done at most once in sâ€². For this, we maintain a bit b in every state of 
Mj which indicates
whether the x was placed (b = 1) or not (b = 0). Then, while traversing with 
Mj over the input tree s, we only form
the possible transitions on a k-ary symbol (, l, f ) from those states of the successors for which the sum of their bits
is not greater than 1.
M. Droste, H. Vogler / Theoretical Computer Science 366 (2006) 228â€“247
239
Formally, we construct 
Mj = (
Q,V,, 
F) by setting 
Q = P(Q Ã— {0, 1}) and 
F = {U âŠ†Q Ã— {0, 1} |
Uâˆ©(QÃ—{1}) âŠ†F Ã—{1}}, and  = {(,l,f )}(,l,f )âˆˆV is deï¬ned for every (, l, f ) âˆˆ(m)
V , mâ©¾0, and P1, . . . , Pm âˆˆ
Q
by
(,l,f )(P1, . . . , Pm) = P,
where
P =
 P â€²
if l Ì¸= j,
P â€² âˆªP â€²â€²
if l = j.
and
P â€² =
	
(,f [xâ†’0])(p1, . . . , pm),
m

i=1
bi

 (pi, bi) âˆˆPi for every1â©½i â©½m and
m

i=1
bi â©½1

and
P â€²â€² =

(,f [xâ†’1])(p1, . . . , pm), 1

| (pi, 0) âˆˆPi for every 1â©½i â©½m} .
Roughly speaking, P â€² formalizes the propagation of the bit value 0, if all successors of the current symbol (labeled
by (, l, f )) have bit value 0, or of the bit value 1, if exactly one of the successors has bit value 1. If l = j, then
additionally to this propagation, 
Mj can change from the bit vector (0, . . . , 0) to the bit value 1, thereby placing the x
to this position and splitting off a new copy of Mj. Now we will show that 
Mj recognizes 
Lj.
Since Mj and 
Mj are deterministic, we have that for every (sâ€², ) âˆˆTV the sets Rv
Mj (sâ€²[x â†’w]) and Rv

Mj ((sâ€², )) of
runs are singletons. Recall that these runs are denoted by rsâ€²[xâ†’w] and r(sâ€²,), respectively. Then for every (sâ€², ) âˆˆTV
we have that
r(sâ€²,)() =

rsâ€²[xâ†’âˆ…](), 0

âˆª{(rsâ€²[xâ†’w](), 1) | w âˆˆpos(sâ€²), (w) = j},
(2)
where sâ€²[x â†’âˆ…] âˆˆTW denotes the tree obtained from sâ€² âˆˆTV by replacing every label (, f ) by (, fx) and
fx : V âˆª{x} â†’{0, 1} extends f by setting fx(x) = 0. Eq. (2) can be proved by structural induction on s = (sâ€², ) as
follows.
Let s = (, l, f )(s1, . . . , sm) âˆˆTV with s = (sâ€², ) and si = (sâ€²
i, i) for every 1â©½i â©½m. Moreover, let sâ€² =
(, f )(sâ€²
1, . . . , sâ€²
m). We assume that Eq. (2) holds for s1, . . . , sm (I.H.). Then we ï¬rst prove the following equation:
	
(,f [xâ†’0])(p1, . . . , pm),
m

i=1
bi

 (pi, bi) âˆˆrsi(),
m

i=1
bi â©½1

= {(rsâ€²[xâ†’âˆ…](), 0)} âˆª{(rsâ€²[xâ†’uw](), 1) | 1â©½uâ©½m, w âˆˆpos(sâ€²
u), u(w) = j}.
(3)
Proof of Eq. (3).
	
(,f [xâ†’0])(p1, . . . , pm),
m

i=1
bi

 for every 1â©½i â©½m: (pi, bi) âˆˆrsi() and
m

i=1
bi â©½1

,
I.H.2
=
	
(,f [xâ†’0])(p1, . . . , pm),
m

i=1
bi

 for every 1â©½i â©½m :
[(pi, bi) = (rsâ€²
i[xâ†’âˆ…](), 0) or (pi, bi) = (rsâ€²
i[xâ†’w](), 1), w âˆˆpos(sâ€²
i), i(w) = j] and
m

i=1
bi â©½1

,
=

(,f [xâ†’0])(rsâ€²
1[xâ†’âˆ…](), . . . , rsâ€²m[xâ†’âˆ…]()), 0

âˆª

((,f [xâ†’0])(rsâ€²
1[xâ†’âˆ…](), . . . , rsâ€²u[xâ†’w](), . . . , rsâ€²m[xâ†’âˆ…]()), 1)|1â©½uâ©½m, wâˆˆpos(sâ€²
u), u(w) = j

,
=

rsâ€²[xâ†’âˆ…](), 0

âˆª

rsâ€²[xâ†’uw](), 1

| 1â©½uâ©½m, w âˆˆpos(sâ€²
u), u(w) = j

.
240
M. Droste, H. Vogler / Theoretical Computer Science 366 (2006) 228â€“247
This ï¬nishes the proof of Eq. (3). Now let l Ì¸= j. Then
rs() =(,l,f )(rs(1), . . . , rs(m)) = (,l,f )(rs1(), . . . , rsm())
=
	
(,f [xâ†’0])(p1, . . . , pm),
m

i=1
bi

 (pi, bi) âˆˆrsi(),
m

i=1
bi â©½1

=

rsâ€²[xâ†’âˆ…](), 0

âˆª

rsâ€²[xâ†’uw](), 1

| 1â©½uâ©½m, w âˆˆpos(sâ€²
u), u(w) = j

(by Eq. (3))
=

rsâ€²[xâ†’âˆ…](), 0

âˆª

rsâ€²[xâ†’w](), 1

| w âˆˆpos(sâ€²), (w) = j

.
Now let l = j. Then
rs() =(,l,f )(rs1(), . . . , rsm())
=
	
(,f [xâ†’0])(p1, . . . , pm),
m

i=1
bi

 (pi, bi) âˆˆrsi(),
m

i=1
bi â©½1

âˆª{((,f [xâ†’1])(rsâ€²
1[xâ†’âˆ…](), . . . , rsâ€²m[xâ†’âˆ…]()), 1)}
=

rsâ€²[xâ†’âˆ…](), 0

âˆª

rsâ€²[xâ†’uw](), 1

| 1â©½uâ©½m, w âˆˆpos(sâ€²
u), u(w) = j

âˆª{(rsâ€²[xâ†’](), 1)}
(by Eq.(3)and deï¬nition of run)
=

rsâ€²[xâ†’âˆ…](), 0

âˆª

rsâ€²[xâ†’w](), 1

| w âˆˆpos(sâ€²), (w) = j

.
This ï¬nishes the proof of Eq. (2). Also, by the assumption that L(Mj) = Lj, for every w âˆˆpos(sâ€²), we have
sâ€²[x â†’w] âˆˆLj
iff rsâ€²[xâ†’w]() âˆˆF.
It follows that (sâ€², ) âˆˆ
Lj iff (for every w âˆˆpos(sâ€²): (w) = j implies rsâ€²[xâ†’w]() âˆˆF) iffâˆ—r(sâ€²,)() âˆˆ
F iff
(sâ€², ) âˆˆL(
Mj) where we use Eq. (2) at the equivalence, which is indicated by the âˆ—. Hence 
Lj is recognizable by 
Mj.
Thus, there is a bottom-up ï¬nite state tree automaton 
M = (
Q,V,, 
F) such that L( 
M) = L. We can assume that

M is deterministic. Finally, we construct the wta M = (
Q,V, 	, 
) by deï¬ning, for every mâ©¾0, (, l, f ) âˆˆV, and
q1, . . . , qm, q âˆˆ
Q,
	m((, l, f ))q1...qm,q =

kl
if (,l,f )(q1, . . . , qm) = q,
0
if otherwise.
Moreover, for every q âˆˆ
Q, we deï¬ne 
(q) = 1 if q âˆˆ
F and 0 otherwise. Clearly, also M is deterministic. Thus,
it should be clear that for every (sâ€², ) âˆˆTV (note that K is commutative)
(SM, (sâ€², )) =
 
1â©½j â©½n k|âˆ’1(j)|
j
if (sâ€², ) âˆˆL,
0
if otherwise.
Now we deï¬ne the relabeling  : KâŸ¨âŸ¨TV âŸ©âŸ©â†’KâŸ¨âŸ¨TV âŸ©âŸ©by ((, , f )) = (, f ) for every (, , f ) âˆˆV. Then for
every sâ€² âˆˆTV :
((SM), sâ€²) =

(sâ€²,)âˆˆâˆ’1(sâ€²)
(SM, (sâ€², ))
= (SM, (sâ€², )) where  : pos(sâ€²) â†’{1, . . . , n} is the unique mapping such that (sâ€², ) âˆˆL
=

1â©½j â©½n
k|âˆ’1(j)|
j
=

wâˆˆpos(sâ€²)
(, sâ€²[x â†’w]) due to the fact that  is a recognizable step function
= (âˆ€x., sâ€²).
Hence (SM) = âˆ€x. and thus, by Lemma 3.4 âˆ€x. is recognizable.
Now assume that x /âˆˆW, and thus V = W. Then we consider the formula â€² =  âˆ¨edge1(x, x). By Lemmas 5.2
and 5.3 we have that â€² is recognizable, in particular, â€² is a recognizable step function, and by an easy calculation,
M. Droste, H. Vogler / Theoretical Computer Science 366 (2006) 228â€“247
241
we obtain that â€²Vâˆª{x} = Vâˆª{x}. Thus, âˆ€x.â€²V = âˆ€x.V which is recognizable by what we have shown
above.
â–¡
Then the next theorem follows from Lemmata 5.2, 5.3, 5.4, and 5.5.
Theorem 5.6. KrmsoâŸ¨âŸ¨TâŸ©âŸ©âŠ†KrecâŸ¨âŸ¨TâŸ©âŸ©.
Next we turn to effectiveness and decidability questions and show results for a particular class of semirings, viz.
computable ï¬elds. We will need the following preparation.
Proposition 5.7 (Seidl [36, Theorem 4.2], also cf. Bozapalidis [10]). Let K be a computable ï¬eld. It is decidable for
two effectively given weighted bottom-up ï¬nite state tree automata M and Mâ€², whether SM = Sâ€²
M or not.
Using this, we can show:
Corollary 5.8. Let K be a computable ï¬eld. There is an effective procedure which produces, for a given restricted
MSO(K, )-formula , a weighted bottom-up ï¬nite state tree automaton M such that  = SM.
Proof. By induction on the structure of . For this, we have to show that all our preceding proofs are constructive.
This is mostly well known or easy, and it remains to consider the proof of Lemma 5.5. So let  be a recognizable
step function. We may assume that  = SM for some given wta M, and we have to construct a wta which accepts
the tree series âˆ€x..
We list all tuples (k1, . . . , kn, M1, . . . , Mn) such that nâ©¾1, k1, . . . , kn âˆˆK and M1, . . . , Mn are deterministic
bottom-up ï¬nite state tree automata. For each such tuple, we construct a wta Mâ€² such that SMâ€² = 
1â©½j â©½n kj Â·1L(Mj ),
and we use Proposition 5.7 to check whether SM = SMâ€². Since SM is a recognizable step function, working through
our list we will eventually obtain a tuple for which this equality holds. Now we can use the values kj and automata Mj
of this tuple in our proof of Lemma 5.5 to construct the required weighted automaton for âˆ€x..
â–¡
The result of Corollary 5.8 also holds for other semirings K than ï¬elds, see Section 6. However, whether it holds for
all commutative semirings remains open at present. As an immediate consequence of Corollary 5.8 and Proposition
5.7 we obtain:
Corollary 5.9. Let K be a computable ï¬eld, and let  and â€² be two RMSO(K, )-sentences. Then it is decidable
whether  = â€².
5.2. Recognizable tree series are deï¬nable
Here, let K again denote an arbitrary commutative semiring. In this section we show that recognizable tree series
are REMSO-deï¬nable. That is, given a wta M, we will explicitly present a formula  of weighted REMSO-logic such
that SM = . As in the proof of the weighted case for strings [18],  can be chosen to have the form âˆƒX1 . . . âˆƒXn.
where every second order variable Xi corresponds to a transition of M and identiï¬es those nodes of a tree t at which
M applies this transition. The subformula  represents a particular run of M, i.e., it (1) guarantees that the sets of
nodes which are identiï¬ed by X1, . . . , Xn, form a partitioning of the set of all nodes of t, and that the transitions of
neighbored nodes match (cf. the subformula M, given below), (2) computes the weight of the run, and (3) computes
the weight for leaving M at the root of t. We prepare this theorem by deï¬ning some formulas and notions which are
relevant for the description of runs of a wta by means of weighted logic.
Deï¬nition 5.10. Let M = (Q, , 	, 
) be a wta.
â€¢ Let X1, . . . , Xn be set variables. The partition formula associated with X1, . . . , Xn is the formula partition âˆˆ
MSOâˆ’() deï¬ned as follows:
partition = âˆ€x.
â›
â

1â©½i â©½n
â›
â(x âˆˆXi) âˆ§

1 â©½j â©½n
jÌ¸=i
Â¬(x âˆˆXj)
â
â 
â
â .
242
M. Droste, H. Vogler / Theoretical Computer Science 366 (2006) 228â€“247
â€¢ The set of all transitions at -symbols is the set BM = {(âƒ—q, , q) | mâ©¾0, âƒ—q âˆˆQm,  âˆˆ(m), q âˆˆQ}.
An enumeration of the set BM is a bijection  : BM â†’{1, . . . , n} where n = |BM|; in the sequel we will ab-
breviate X((âƒ—q,,q)) by Xâƒ—q,,q.
â€¢ Let  be an enumeration of BM. The run-formula associated with M and  is the formula M, âˆˆMSOâˆ’() with
free variables X1, . . . , Xn deï¬ned as follows:
M, = partition âˆ§M,,1 âˆ§M,,2,
where
M,,1 =

(âƒ—q,,q)âˆˆBM
âˆ€x.

(x âˆˆXâƒ—q,,q) â†’label(x)

,
M,,2 =

(âƒ—q,,q)âˆˆBM ,
âƒ—q=(q1,... ,qm)
âˆ€x.
â›
âœâœâœâ(x âˆˆXâƒ—q,,q) â†’âˆƒy1 . . . âˆƒym.
â›
âœâœâœâedge(x, y1 . . . ym)
âˆ§

( âƒ—p1,1,q1)âˆˆBM,
...
( âƒ—pm,m,qm)âˆˆBM
(y1 âˆˆX âƒ—p1,1,q1) âˆ§Â· Â· Â· âˆ§(ym âˆˆX âƒ—pm,m,qm)
â
âŸâŸâŸâ 
+â
âŸâŸâŸâ ,
edge(x, y1 . . . ym) = edge1(x, y1) âˆ§. . . âˆ§edgem(x, ym).
LetusmakesomeobservationsontheformulasinDeï¬nition5.10.Theseformulasdonotcontainanysetquantiï¬cation
and whenever there is a subformula of the form âˆ€x., then  is a recognizable step function. Thus, the formula M,
is in RMSO(K, ). Moreover, by Observation 4.4 we have that M,V = 1LV(M,).
Theorem 5.11. KrecâŸ¨âŸ¨TâŸ©âŸ©âŠ†KremsoâŸ¨âŸ¨TâŸ©âŸ©.
Proof. Let M = (Q, , 	, 
) be a wta,  : BM â†’{1, . . . , n} be an enumeration of the set BM, and V = {X1, . . . , Xn}.
We put  = M,. Let t âˆˆT. First we show that there is a bijection between the set RM(t) of all runs of M on t and
the set
Asst,M = { |  is a (V, t)-assignment, (t, ) âŠ¨}
of all (V, t)-assignments which satisfy . For this, let r: pos(t) â†’Q be a run of M on t. We deï¬ne the (V, t)-
assignment r : V â†’P(pos(t)) as follows: For every 1â©½i â©½n, if i = (((q1, . . . , qm), , q)), then deï¬ne r(Xi) =
{w âˆˆpos(t) | r(w.1) = q1, . . . , r(w.m) = qm, t(w) = , r(w) = q}. It is obvious that (t, r) âŠ¨. Conversely,
let  be a (V, t)-assignment such that (t, ) âŠ¨. Then deï¬ne the run r : pos(t) â†’Q as follows: for every
w âˆˆpos(t), due to the fact that in particular (t, ) âŠ¨partition, there are uniquely determined mâ©¾0, âƒ—q âˆˆQm,  âˆˆ
(m), and q âˆˆQ such that w âˆˆ(Xâƒ—q,,q), and we put r(w) = q. Since (t, ) âŠ¨, it follows that r is a run
on t.
Now consider the following formula of weighted MSO-logic:
 =  âˆ§

(âƒ—q,,q)âˆˆBM
âˆ€x.

(x âˆˆXâƒ—q,,q) â†’	m()âƒ—q,q

âˆ§âˆƒz.

root(z) âˆ§

(âƒ—q,,q)âˆˆBM
(z âˆˆXâƒ—q,,q) âˆ§
(q)

,
where root(z) = âˆ€x.

Â¬edge1(x, z)âˆ§Â· Â· Â·âˆ§Â¬edgemax(x, z)

. Clearly, for every t âˆˆT there is exactly one w âˆˆpos(t)
such that (t, [z â†’w]) âŠ¨root(z), namely w = . By Lemma 4.9,  is restricted.
M. Droste, H. Vogler / Theoretical Computer Science 366 (2006) 228â€“247
243
Let t âˆˆT and r : pos(t) â†’Q be a run of M on t. By the discussion above there is a uniquely determined
(V, t)-assignment r such that (t, r) âŠ¨. Then we can calculate as follows:
V(t, r) =


(âƒ—q,,q)âˆˆBM
	m()
|r(Xâƒ—q,,q)|
âƒ—q,q

Â· 
(r())
(since K is commutative, we can now permute the occurrences of values 	m()âƒ—q,q)
=


wâˆˆpos(t)
	m(t(w))r(w.1)...r(w.m),r(w)

Â· 
(r())
(where m = rk(t(w)))
=


wâˆˆpos(t)
wtM(t, r, w)

Â· 
(r())
= wtM(t, r) Â· 
(r()).
Now let  = âˆƒX1. . . . âˆƒXn.. Then  âˆˆREMSO(K, ). We show that SM = . Let t âˆˆT and put V =
{X1, . . . , Xn}. Then
(t) =

 is a (V,t)-assignm.
(t, )
=

 is a (V,t)-assignm.
(t,)âŠ¨
(t, ) =âˆ—

râˆˆRM(t)
(t, r)
=

râˆˆRM(t)
wtM(t, r) Â· 
(r()) = (SM, t).
where the equation marked by âˆ—is due to the bijection between runs and assignments shown above.
â–¡
Theorems 5.6 and 5.11 imply the main result, Theorem 5.1.
Let us extend the syntax of our weighted logic by adding an atomic formula root(z) which holds for (t, ) iff (z) = ,
the root of t. That is

root(z), (t, )

=
 1
if (z) = ,
0
otherwise.
Then an easy analysis of the proof of Theorem 5.11 shows that we can restrict ourselves to just one application of the
universal ï¬rst order quantiï¬er.
Corollary 5.12. Let S âˆˆKrecâŸ¨âŸ¨TâŸ©âŸ©. Then S =  for a formula  of the form  = âˆƒX1 . . . âˆƒXn.âˆ€x. where 
contains the formula root(z) and only ï¬rst order existential quantiï¬cations, and  is a recognizable step function.
6. Locally ï¬nite semirings
As noted before, easy examples show that there are MSO(K, )-deï¬nable series which are not recognizable (compare
[18]). In this section, we wish to show that for a large class of semirings K, all MSO(K, )-deï¬nable tree series are
recognizable. Again let  denote an arbitrary ranked alphabet.
If K is a semiring and A âŠ†K, we denote by âŸ¨AâŸ©the subsemiring of K generated by A. Clearly, we may construct
âŸ¨AâŸ©by ï¬rst taking the closure Aâ€² of A âˆª{0, 1} under multiplication, then âŸ¨AâŸ©is the closure of Aâ€² under addition.
A semiring K is called locally ï¬nite, if each ï¬nitely generated subsemiring of K is ï¬nite. A monoid is called locally
ï¬nite, if each ï¬nitely generated submonoid is ï¬nite. Clearly, a semiring (K, +, Â·, 0, 1) is locally ï¬nite iff both monoids
(K, +, 0) and (K, Â·, 1) are locally ï¬nite (apply the remark on âŸ¨AâŸ©above, or cf. [17, Section 4] or [9, Lemma 2.5]).
For example, any Boolean algebra (B, âˆ¨, âˆ§, 0, 1) is locally ï¬nite. The maxâ€“min semiring Rmax,min = (R+ âˆª
{âˆ}, max, min, 0, âˆ) of positive reals, used for maximum capacity problems of networks, is locally ï¬nite. More
generally, any distributive lattice (L, âˆ¨, âˆ§, 0, 1) with smallest element 0 and largest element 1 is locally ï¬nite.
244
M. Droste, H. Vogler / Theoretical Computer Science 366 (2006) 228â€“247
The following result slightly generalizes [8, Theorem 9] where wta with ï¬nal states rather than ï¬nal weights were
considered.
Lemma 6.1. Let K be a locally ï¬nite commutative semiring, k âˆˆK, and S âˆˆKrecâŸ¨âŸ¨TâŸ©âŸ©. Then Sâˆ’1(k) is a recognizable
tree language. In particular, S is a recognizable step function.
Proof. Let M = (Q, , 	, 
) be a wta over K which accepts S. We will construct a deterministic bottom-up ï¬nite state
tree automaton Mk such that L(Mk) = Sâˆ’1
M (k). Let Mk = (Qâ€², , , F) such that
â€¢ Qâ€² = (Kâ€²)Q where Kâ€² = âŸ¨{	m()q1...qm,q | mâ©¾0,  âˆˆ(m), q, q1, . . . , qm âˆˆQ} âˆª{
(q) | q âˆˆQ}âŸ©âŠ†K; i.e., Qâ€²
is the set of Q-vectors over Kâ€²;
â€¢ for every mâ©¾0,  âˆˆ(m), P1, . . . , Pm âˆˆQâ€², and q âˆˆQ we deï¬ne
(P1, . . . , Pm)q =

q1,... ,qmâˆˆQ
(P1)q1 Â· . . . Â· (Pm)qm Â· 	l()q1...qm,q,
and
â€¢ F = {P âˆˆQâ€² | k = 
qâˆˆQ
Pq Â· 
(q)}.
We recall that, since Mk is deterministic, for every t âˆˆT there is a unique valid run of Mk on t, denoted by rt, and
t âˆˆL(Mk) iff rt() âˆˆF. Now we claim for every position w âˆˆpos(t), that
rt(w)q =

râˆˆRM (t|w)
r()=q

uâˆˆpos(t|w)
wtM(t|w, r, u)
for every q âˆˆQ.
This claim can be proved straightforwardly by induction on the â€œheightâ€ of w in t; this is deï¬ned as the maximal length
of a path from w to the leaves in t. Next we compute (SM, t) where at (âˆ—) we will use the above equation for w = .
(SM, t) = 
qâˆˆQ

râˆˆRM (t)
r()=q


wâˆˆpos(t)
wtM(t, r, w)

Â· 
(q)
= (âˆ—) 
qâˆˆQ
(rt())q Â· 
(q).
Using this equality we can argue as follows: t âˆˆSâˆ’1
M (k) iff (SM, t) = k iff rt() âˆˆF iff t âˆˆL(Mk). This proves that
L(Mk) = Sâˆ’1
M (k).
Finally, it is clear that S = 
kâˆˆKâ€² k Â· 1Sâˆ’1(k) and hence S is a recognizable step function.
â–¡
We note the following basic result (cf. [3, Lemma III.1.2] for the string case).
Lemma 6.2. Let  be a ranked alphabet, K and L two commutative semirings,  : K â†’L a semiring morphism, and
S âˆˆKrecâŸ¨âŸ¨TâŸ©âŸ©. Then the series (S) =  â—¦S : T â†’L with ((S), t) = ((S, t)) for every t âˆˆT is recognizable.
Proof. Let M be a wta over K which recognizes S. Applying  to all weights occurring in M yields a wta which
recognizes (S) (compare [8, Lemma 3]).
â–¡
Although most of the following result was shown in [32], we indicate an alternative proof, since this permits
straightforward effective constructions which we will need later on.
Lemma 6.3. Let  be a ranked alphabet.
(1) (Cf . [32]). Let S âˆˆZrecâŸ¨âŸ¨TâŸ©âŸ©and a, b âˆˆZ with b Ì¸= 0. Then Sâˆ’1(a + bZ) is a recognizable tree language.
(2) Let S âˆˆNrecâŸ¨âŸ¨TâŸ©âŸ©and a âˆˆN. Then the languages Sâˆ’1({n âˆˆN | nâ©¾a}), Sâˆ’1({n âˆˆN | nâ©½a}), and Sâˆ’1(a) are
recognizable tree languages.
M. Droste, H. Vogler / Theoretical Computer Science 366 (2006) 228â€“247
245
Proof. Analogous to the proof of [3, Corollaries III.2.4 and III.2.5], using Lemmas 6.1 and 6.2. 1
â–¡
Proposition 6.4. Let K be a locally ï¬nite commutative semiring,  :  â†’ a relabeling and S : T â†’K
a recognizable series. Then the series (S) : T â†’K deï¬ned by ((S), t) := 
sâˆˆâˆ’1(t) (S, s) (t âˆˆT) is
recognizable.
Proof. By Lemma 6.1, S has the form S = n
j=1 kj Â· 1Lj with n âˆˆN, kj âˆˆK and recognizable tree languages
Lj âŠ†T (j = 1, . . . , n) which form a partition of T. For any t âˆˆT, let mj(t) := |âˆ’1(t) âˆ©Lj|. Then ((S), t) =
n
j=1 k
mj (t)
j
. For each j âˆˆ{1, . . . , n}, the submonoid of (K, Â·, 1) generated by {kj} is ï¬nite. Choose a minimal aj âˆˆN
such that k
aj
j
= k
aj +x
j
for some x > 0 and let bj be the smallest such x > 0. Then âŸ¨kjâŸ©= {1, kj, k2
j, . . . , k
aj +bj âˆ’1
j
},
and for each t âˆˆT, we have k
mj (t)
j
= k
dj (t)
j
for some uniquely determined dj(t) âˆˆN with 0â©½dj(t)â©½aj + bj âˆ’1.
Note that if 0â©½d < aj, then k
mj (t)
j
= kd
j iff mj(t) = d, and if aj â©½d < aj +bj, then k
mj (t)
j
= kd
j iff mj(t) âˆˆd +bjN.
For each 0â©½d < aj + bj and 1â©½j â©½n let Mj
d := {t âˆˆT | dj(t) = d}. Then ((S), t) = n
j=1 k
dj (t)
j
=

d1,... ,dn:0â©½dj <aj +bj (j=1,... ,n) kd1
1 Â· . . . Â· kdn
n Â· (1M1
d1âˆ©Â·Â·Â·âˆ©Mn
dn, t).
For every 1â©½j â©½n, let 1â€²
Lj : T â†’N be the characteristic function of Lj with values 0, 1 âˆˆN. By Lemma
3.4 the series Sj := (1â€²
Lj ) : T â†’N is recognizable, and (Sj, t) = 
sâˆˆâˆ’1(t) (1â€²
Lj , s) = mj(t) (t âˆˆT). Hence
Mj
d = {t âˆˆT | mj(t) = d} = Sâˆ’1
j (d) if 0â©½d < aj, and Mj
d = {t âˆˆT | mj(t) âˆˆd + bjN} = Sâˆ’1
j (d + bjN) if
aj â©½d < aj + bj. In each case, Mj
d is recognizable by Lemma 6.3. Hence (S) is recognizable.
â–¡
As a consequence, we obtain for locally ï¬nite and commutative semirings that the semantics of all sentences of our
MSO-logic are recognizable series.
Theorem 6.5. Let K be a locally ï¬nite commutative semiring. Then KrecâŸ¨âŸ¨TâŸ©âŸ©= KmsoâŸ¨âŸ¨TâŸ©âŸ©.
Proof. The inclusion KrecâŸ¨âŸ¨TâŸ©âŸ©âŠ†KmsoâŸ¨âŸ¨TâŸ©âŸ©is immediate by Theorem 5.11. For the converse, we prove by structural
induction for any MSO(K, )-formula  that  is recognizable. We may apply Lemmas 5.2â€“5.4, and for universal
ï¬rst order quantiï¬cation we use Lemmas 6.1 and 5.5. The induction step for universal second-order quantiï¬cation
follows from Proposition 6.4, using a relabeling  : Vâˆª{X} â†’V which deletes X where V = Free() similarly as
in the proof of Lemma 5.4.
â–¡
Finally, we turn to constructibility and decision problems for computable locally ï¬nite commutative semirings K.
By Lemma 6.1, every MSO(K, )-formula  not containing universal second order quantiï¬ers is restricted. Hence the
set RMSO(K, ) is recursive.
Corollary 6.6. Let K be a computable locally ï¬nite commutative semiring. Given an MSO(K, )-formula , we can
effectively compute a wta M such that  = SM.
Proof. We follow the proof of Theorem 6.5. The constructions underlying the lemmata used are all effective.
We consider the case of universal ï¬rst order quantiï¬cation. If M is a wta, we can compute the ï¬nite subsemiring
Kâ€² of the proof of Lemma 6.1 and hence also the automata Mk for each k âˆˆKâ€². Now follow the proof of Lemma 5.5.
Finally, we consider universal second order quantiï¬cation. In the proof of Proposition 6.4, we obtain wta for the series
Sj. Following the proof of Lemma 6.3 we obtain bottom-up ï¬nite state tree automata for the languages Mj
d and hence
a wta for the series (S). Thus, the proof of Theorem 6.5 is constructive.
â–¡
Corollary 6.7. Let K be a computable locally ï¬nite commutative semiring. It is decidable whether two given
MSO(K, )-formulas  and  satisfy  = .
1 Lemma 6.3, part 2 is also stated in [32]. However, its proof uses the Inverse Image Theorem of [32] which requires the additional hypothesis
that the image of S is ï¬nite. This assumption is avoided here.
246
M. Droste, H. Vogler / Theoretical Computer Science 366 (2006) 228â€“247
Proof. By Corollary 6.6, construct two wta M and Mâ€² such that  = SM and  = SMâ€². It remains to decide
whether SM = SMâ€². For this, compute a ï¬nite subsemiring Kâ€² of K which contains all possible values of SM and
SMâ€². Now, following the proof of Lemma 6.1, check whether the tree languages Sâˆ’1
M (k) and Sâˆ’1
Mâ€² (k) are equal, for each
k âˆˆKâ€².
â–¡
7. Conclusions and open problems
The proof of Corollary 5.8 shows that if K is a ï¬eld, the set RMSO(K, ) is recursively enumerable. Two open
questions arise. First, the proof of Corollary 5.8 used a â€œbrute forceâ€ argument to show the effectiveness of Lemma 5.5.
For actual constructions, it would be desirable to have a more explicit method. Second, an open question is whether
for an arbitrary MSO(K, )-formula  we can decide whether  is restricted. Proceeding by structural induction, for
this one would need a method for deciding whether an effectively given tree series is a recognizable step function. For
weighted automata on words, this was achieved in [18] using results from the theory of formal power series, employing,
in particular, Burnside-type results on monoids of matrices over the ï¬eld K. For tree series, such a theory seems to be
lacking. Thus, we do not know whether the set RMSO(K, ) is recursive.
The present paper shows that the weighted logic introduced in [18] is robust, because it admits an extension to
trees. This motivates the question whether there is an equivalent weighted version of the characterization of the large
class of context-free graph languages (mentioned in the introduction) by images of MSO-deï¬nable functions on sets
of trees [22,23,14]. Also one might investigate the weighted extension of the difï¬cult result that particular attributed
tree transducers are characterized by MSO-deï¬nable graph transduction [4].
Acknowledgments
We are grateful to the referees for suggesting improvements to the ï¬rst version of the paper. Also we are grateful to
Andreas Maletti for pointing out a more succinct wta in Example 3.2.
References
[1] C. Baier, B. Haverkort, H. Herrmanns, J.-P. Katoen, Model-checking algorithms for continuous time markov chains, IEEE Trans. on Software
Eng. 29 (7) (2003) 1â€“18.
[2] J. Berstel, C. Reutenauer, Recognizable formal power series on trees, Theoret. Comput. Sci. 18 (2) (1982) 115â€“148.
[3] J. Berstel, Ch. Reutenauer, Rational Series and Their Languages, EATCS-Monographs, Vol. 12, Springer, Berlin, 1988.
[4] R. Bloem, J. Engelfriet, A comparison of tree transductions deï¬ned by monadic second order logic and by attribute grammars, J. Comput.
System Sci. 61 (2000) 1â€“50.
[5] B. Borchardt, A pumping lemma and decidability problems for recognizable tree series, Acta Cybernet. 16 (4) (2004) 509â€“544.
[6] B. Borchardt, The theory of recognizable tree series. Ph.D. Thesis, TU Dresden, 2004.
[7] B. Borchardt, Code selection by tree series transducers, in: Ninth Internat. Conf. on Implementation and Application of Automata (CIAAâ€™04),
Kingston, Canada, Proceedings, Lecture Notes in Computer Science, Vol. 3317, Springer, Berlin, 2005, pp. 57â€“67.
[8] B. Borchardt, A. Maletti, B. Å eÅ¡elja, A. TepavË‡cevic, H. Vogler, Cut sets as recognizable tree languages, Fuzzy Sets and Systems 157 (2006)
1560â€“1571.
[9] B. Borchardt, H. Vogler, Determinization of ï¬nite state weighted tree automata, J. Automata Languages and Combinatorics 8 (3) (2003)
417â€“463.
[10] S. Bozapalidis, Effective construction of the syntactic algebra of a recognizable series on trees, Acta Inform. 28 (1991) 351â€“363.
[11] S. Bozapalidis, Equational elements in additive algebras, Theory Comput. Systems 32 (1) (1999) 1â€“33.
[12] J.R. BÃ¼chi, Weak secondâ€“order arithmetic and ï¬nite automata, Z. Math. Logik Math. 6 (1960) 66â€“92.
[13] A.L. Buchsbaum, R. Giancarlo, J.R. Westbrook, On the determinization of weighted ï¬nite automata, SIAM J. Comput. 30 (5) (2000)
1502â€“1531.
[14] B. Courcelle, The monadic second-order logic of graphs V: on closing the gap between deï¬nability and recognizability, Theoret. Comput. Sci.
80 (1991) 153â€“202.
[15] K. Culik, J. Kari, Image compression using weighted ï¬nite automata, Comput. Graphics 17 (1993) 305â€“313.
[16] J. Doner, Tree acceptors and some of their applications, J. Comput. System Sci. 4 (1970) 406â€“451.
[17] M. Droste, P. Gastin, On aperiodic and star-free formal power series in partially commuting variables, in: Formal Power Series and Algebraic
Combinatorics (Moscow 2000), Springer, Berlin, 2000, pp. 158â€“169, full version in Theory of Computing Systems, to appear.
[18] M. Droste, P. Gastin, Weighted automata and weighted logics, in: Automata, Languages and Programmingâ€”32nd International Colloquium,
ICALP 2005, Lisbon, Portugal, 2005, Proceedings, Lecture Notes in Computer Science, Vol. 3580, Springer, Berlin, 2005, pp. 513â€“525, full
version in Theoretical Computer Science, to appear.
[19] M. Droste, C. Pech, H. Vogler, A Kleene theorem for weighted tree automata, Theory Comput. Systems 38 (2005) 1â€“38.
M. Droste, H. Vogler / Theoretical Computer Science 366 (2006) 228â€“247
247
[20] C.C. Elgot, Decision problems of ï¬nite automata design and related arithmetics, Trans. Amer. Math. Soc. 98 (1961) 21â€“52.
[21] J. Engelfriet, Bottom-up and top-down tree transformationsâ€”a comparison, Math. Systems Theory 9 (3) (1975) 198â€“231.
[22] J. Engelfriet, A characterization of context-free NCE graph languages by monadic second-order logic on trees, in: G. Rozenberg, H. Ehrig,
H.-J. Kreowski (Eds.), Graph Grammars and their Application to Computer Science Fourth Internat. Workshop, Bremen, Germany, 1990.
Proceedings, Lecture Notes in Computer Science, Vol. 532, 1991, pp. 311â€“327.
[23] J. Engelfriet, V. van Oostrom, Logical description of context-free graph languages, J. Comput. System Sci. 55 (1997) 489â€“503.
[24] Z. Ã‰sik, W. Kuich, Formal tree series, J. Automata Languages, Combinatorics 8 (2) (2003) 219â€“285.
[25] C. Ferdinand, H. Seidl, R. Wilhelm, Tree automata for code selection, Acta Inform. 31 (8) (1994) 741â€“760.
[26] F. GÃ©cseg, M. Steinby, Tree Automata, AkadÃ©miai KiadÃ³, Budapest, 1984.
[27] F. GÃ©cseg, M. Steinby, Tree languages, in: G. Rozenberg, A. Salomaa (Eds.), Handbook of Formal Languages, Vol. 3, Springer, Berlin, 1997,
pp. 1â€“68, Chapter 1.
[28] U. Hafner, Low bit-rate image and video coding with weighted ï¬nite automata, Ph.D. Thesis, UniversitÃ¤t WÃ¼rzburg, Germany, 1999.
[29] W. Kuich, Formal power series over trees, in: S. Bozapalidis (Ed.), Third Internat. Conf. on Developments in Language Theory, DLT 1997,
Thessaloniki, Greece, Proceedings, Aristotle University of Thessaloniki, 1998, pp. 61â€“101.
[30] W. Kuich, Tree transducers and formal tree series, Acta Cybernet. 14 (1999) 135â€“149.
[31] W. Kuich, A. Salomaa, Semirings, Automata, Languages, EATCS Monographs on Theoretical Computer Science, Springer, Berlin, 1986.
[32] O. Louscou-Bozapalidis, Some remarks on recognizable tree series, Internat. J. Computer Math. 70 (1999) 649â€“655.
[33] Chr. Pech, Kleene-type results for weighted tree automata. Ph.D. Thesis, TU Dresden, 2003.
[34] A. Salomaa, M. Soittola, Automata-Theoretic Aspects of Formal Power Series. Texts and Monographs in Computer Science, Springer, Berlin,
1978.
[35] M.P. SchÃ¼tzenberger, On the deï¬nition of a family of automata, Inform. and Control 4 (1961) 245â€“270.
[36] H. Seidl, Deciding equivalence of ï¬nite tree automata, SIAM J. Comput. 19 (3) (1990) 424â€“437.
[37] H. Seidl, Finite tree automata with cost functions, Theoret. Comput. Sci. 126 (1) (1994) 113â€“142.
[38] E. Stark, On behaviour equivalence for probabilistic i/o automata and its relationship to probabilistic bisimulation, J. Automata Languages
Combinatorics 8 (2003) 361â€“395.
[39] J.W. Thatcher, J.B. Wright, Generalized ï¬nite automata theory with application to a decision problem of second-order logic, Math. Systems
Theory 2 (1) (1968) 57â€“81.
