Theoretical Computer Science 405 (2008) 116–163
Contents lists available at ScienceDirect
Theoretical Computer Science
journal homepage: www.elsevier.com/locate/tcs
Fine hierarchies and m-reducibilities in theoretical computer science
$
Victor L. Selivanov
A.P. Ershov Institute of Informatics Systems, Siberian Division of the Russian Academy of Sciences, Russian Federation
a r t i c l e
i n f o
Keywords:
Hierarchy
m-reducibility
Topology
Logic
Computability
Complexity
Difference hierarchy
Fine hierarchy
Boolean term
Alternating tree
k-partition
Baire space
Baire domain
Language
ω-language
Automaton
a b s t r a c t
This is a survey of results about versions of fine hierarchies and many-one reducibilities
that appear in different parts of theoretical computer science. These notions and
related techniques play a crucial role in understanding complexity of finite and infinite
computations. We try not only to present the corresponding notions and facts from the
particular fields but also to identify the unifying notions, techniques and ideas.
© 2008 Elsevier B.V. All rights reserved.
1. Introduction
The notion of hierarchy appeared first in descriptive set theory (DST), in the work of E. Borel, H. Lebesgue, F. Hausdorff,
N. Luzin, M. Suslin and many others as a classification tool for characterizing complexity of sets studied in analysis.
Later, similar hierarchies were introduced and studied in computability theory by S. Kleene, A. Mostowski, J. Addison, Y.
Moschovakis and many others. S. Kleene has shown that the hierarchies in DST may be treated as in a sense ‘‘limit versions’’
of their computability-theoretic analogs. This was the first evidence that a ‘‘hierarchy theory’’ might really exist.
The notions of reducibility were introduced by S. Kleene and E. Post in computability theory where they play a central
role in classification of undecidable problems. One of the simplest and most important is the so called many-one reducibility
(m-reducibility for short). Later, W. Wadge considered a non-effective version of the m-reducibility and has shown that this
version is of primary importance for DST. In particular, he discovered in this way new interesting hierarchies.
Subsequently, different notions of hierarchies and reducibilities (especially m-reducibilities) were employed in different
branches of theoretical computer science and of definability theory (e.g., polynomial-time hierarchy and polynomial-time
m-reducibility in complexity theory, logical hierarchies and reducibilities in finite model theory, dot-depth hierarchy in
automata theory and so on). Some of these hierarchies and reducibilities turned out to be also quite important for the
corresponding fields.
Please note that our term ‘‘fine hierarchy’’ is used in two senses: it denotes a class of certain hierarchies specified below
as well as a particular element of this class — the fine hierarchy over a given ω-base, details are given below. Similarly, the
term ‘‘m-reducibility’’ may denote either a class of reducibilities having a common feature or the well-known m-reducibility
from computability theory.
$ Supported by a DAAD project within the program ‘‘Ostpartnerschaften’’, by DFG Mercator program, by DFG-RFBR Grant 06-01-04002 and by RFBR
Grant 07-01-00543a.
E-mail address: vseliv@ngs.ru.
0304-3975/$ – see front matter © 2008 Elsevier B.V. All rights reserved.
doi:10.1016/j.tcs.2008.06.031
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
117
The events mentioned above seem to support the idea that hierarchies and reducibilities are central unifying notions in
several branches of theoretical computer science and mathematics dealing with classification of objects according to their
complexity (in the general sense). To my knowledge, the idea to develop a general ‘‘hierarchy theory’’ was first formulated by
Addison [2–4]. He tried to develop a unified framework [3,5] for the hierarchies currently considered in DST, computability
theory and logic. Many researchers in different fields worked in this direction, probably following the logic of a particular
field rather than the Addison’s idea. But some (including the author) tried also to develop hierarchies and reducibilities
systematically, working towards a creation of a real theory.
In this survey we collect results from different fields (ranging from DST to automata theory) which, in our opinion, clearly
demonstrate that such a theory is really possible. We do not only consider many concrete hierarchies and m-reducibilities
but try to formulate general notions and unifying facts and ideas. We do not include proofs because we mention only
published results (with a couple of minor exceptions). Instead, we try to show the development of some key ideas and
techniques. We did not try to compile a comprehensive bibliography of the subject, which would be a hard and time-
consuming task. But we hope that tracing the bibliography in the mentioned sources the reader could obtain an adequate
impression of the history of our subject.
It was impossible to include all known numerous facts about hierarchies and m-reducibilities, even in any of the particular
fields. On the contrary, we tried to select the facts which seem to support the idea that the notions of hierarchy and m-
reducibility are central and efficient tools for several parts of theoretical computer science. Another reason to be selective
is the existence of several known books devoted to hierarchies in DST and computability theory, e.g. [66,95,107,100]. There
was of course, no need to repeat the well-known facts. On the contrary, we tried to make our text as complimentary as
possible. In particular, we discuss mostly fine hierarchies (roughly speaking, the hierarchies finer than hierarchies related to
the quantifier-alternation hierarchy of first-order formulas) while the existing texts put emphasis on the coarse hierarchies.
In contrast with some of the existing books, we put emphasis on the finite (rather than transfinite) versions of the considered
hierarchies; the reason is that the finite levels are more important for understanding the complexity of natural problems. We
also include some relatively recent results and results about hierarchies of k-partitions that provide a non-trivial interesting
generalization of the traditional hierarchies of sets. To my knowledge, the hierarchies of k-partitions were not mentioned
in the existing books so far.
The simplest and most important example of the fine hierarchy is the difference hierarchy first introduced and studied
by Hausdorff [54,55] in the context of DST and afterwards by many authors in different parts of mathematics and theoretical
computer science. Later, more complicated fine hierarchies were introduced independently by Wadge in DST [170,171], K.
Wagner in automata theory [173] and the author in computability theory [112]. The three approaches to the fine hierarchies
used different motivations and proof techniques. W. Wadge tried to understand the structure of Borel sets under the m-
reducibility by continuous functions (now known as the Wadge reducibility) and employed the game-theoretic technique.
K. Wagner tried to understand topological complexity of infinite behavior of finite automata by means of an effective
version of the Wadge reducibility and used combinatorial arguments. The author tried to identify a natural refinement of the
arithmetical hierarchy which can not be (in a sense) refined further and is sufficient for classifying the definable index sets;
the corresponding hierarchy was defined in terms of suitable jump operations. Nevertheless, the three resulted hierarchies
turned out to be closely interrelated. E.g., the Wagner hierarchy may be considered as an effective fragment of the Wadge
hierarchy and an initial segment of the author’s fine hierarchy [125], and the fine hierarchy (adjusted to the context of DST)
is in some exact sense the finite version of the Wadge hierarchy. Moreover, the fine hierarchies turned out useful in some
other situations, though technically they are in general much more involved than the difference hierarchy.
The modern research in DST often requires some strong set-theoretic assumptions beyond the Zermelo-Fraenkel set
theory with the axiom of choice ZFC. In contrast, most questions considered in theoretical computer science so far do not
need those strong assumptions. Since we address this survey mainly to computer scientists, we avoid interesting but rather
special considerations outside the scope of ZFC. Thus, we take ZFC as the foundation for results reported below. Actually, a
good acquaintance with the ‘‘naive’’ set theory is sufficient for understanding this paper.
The rest of the paper is organized as follows. Section 2 briefly summarizes some notation, notions and facts used
throughout the paper. Most of them are well-known but we also include some less known facts and propose some general
notions related to hierarchies and reducibilities. In the subsequent sections some of these notions are made more concrete
and better adjusted to the corresponding fields. In Section 3 we describe some general facts on the abstract hierarchies (i.e.
hierarchies in sets without additional structure). The subsequent Sections 4–9 depend on the previous two but may be read
relatively independently of each other (though some of them have non-trivial interesting relationships with other sections).
In those sections we discuss hierarchies and m-reducibilities in several branches of mathematics and computer science: DST,
logic, computability theory, complexity theory, automata on finite words and automata on infinite words. In the cases when
a field is already well presented in monographs and survey papers, we try to make our text complimentary, i.e. to minimize
the well-known material and maximize the number of less-known and recently published facts. We conclude in Section 10.
2. Notation and notions
In this section we introduce notation and terminology used throughout the paper. Some more special notation and facts
from concrete fields are recalled in the corresponding subsections devoted to hierarchies and m-reducibilities considered in
those fields. This section is probably not easy to read because it contains many technical definitions. Nevertheless, we kindly
118
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
ask the reader to look through it before going further, because along with the well-known notation and definitions it also
contains some facts frequently used in the sequel, definitions of the abstract central notions of hierarchy and m-reducibility
and informal discussions of some related ideas. Probably, it makes sense to return periodically to this section in order to
refresh definitions and to analyze the development of ideas and problems discussed here.
2.1. Logic
Here we recall some notation from logic. For detailed treatments see any of the available books, e.g. [33,146]. We use
the standard logical symbols ∧, ∨, →, ↔, ¬, ∀, ∃. By signature we mean a set of predicate, functional and constant symbols.
Structure of a signature σ is a pair A = (A; I), denoted also (A; σ) of just by A, consisting of a nonempty set A and an
interpretation I of σ-symbols in A; the interpretation of a symbol s ∈σ is denoted by sI, sA or (in most cases) simply by s
itself. We assume the reader to be familiar with the notions of isomorphism, homomorphism, congruence relation, term,
formula, sentence, and values of a term (or a formula) in a given structure. Recall that sentence is a formula without free
variables. Theory is a set of sentences closed under consequences.
Recall that a relation in a structure is definable if there is a first-order formula of signature of the structure true exactly
on the tuples that satisfy the relation. An element is definable if the corresponding singleton set is definable. A class C of
σ-structures is axiomatizable if there is a sentence φ of signature σ such that C coincides with the class of models of φ (note
that more exact term would be ‘‘finitely axiomatizable’’ but we will not consider the general axiomatizability). We will also
apply the term ‘‘axiomatizable’’ to the situation when C is a class of finite σ -structures.
Recall that first-order theory FO(A) of a structure A of signature σ is the set of first-order sentences of signature σ which
are true in A. The theory FO(A) is decidable if the set of Gödel numbers of the sentences in FO(A) is computable. A theory of
signature σ is hereditary undecidable if any of its subtheories of the same signature σ is undecidable. Of course, any hereditary
undecidable theory is undecidable.
For any theory T of signatureσ we denote by Bσ(T) the Lindenbaum algebra ofσ-sentences modulo T, i.e. the quotient-set
of the set of sentences by the equivalence of sentences in the theory T; this is a Boolean algebra with the Boolean operations
induced by ∧, ∨and ¬, the zero element being the equivalence class of an invalid sentence, and the unit element being the
equivalence class of a valid sentence. For T = ∅we write Bσ instead of Bσ(∅) and call the structure the Lindenbaum algebra
of σ -sentences. Similarly one can define the Lindenbaum algebra of formulas with a fixed tuple of free variables.
Any first-order formula is equivalent to a formula in prenex form where all quantifiers stand at the beginning. This fact
gives rise to the quantifier-alternation hierarchy of formulas (or sentences) of a given signature. For any n > 0, the level
Σ0
n of this hierarchy consists of the formulas equivalent to a Σ0
n -formula, i.e. to a formula in prenex form that starts with an
existential quantifier and has at most n −1 quantifier alternations. As usual, the dual class of formulas is denoted Π 0
n .
Along with the first-order logic (where only the first-order variables denoting the elements of structures are used), in
computer science people are interested also in many other logics. For instance, in second order logic one can use also the
(second-order) predicate variables ranging through the predicates of corresponding arity and quantify over them. Monadic
second order logic is the fragment of the second order logic in which (along with the first-order variables) only the second-
order predicate variables for the unary predicates are allowed. Infinitary logic Lω1,ω is the extension of the first-order logic
by the possibility to use countably infinite conjunctions and disjunctions. Also logics with new kinds of quantifiers (e.g.,
the modulo-counting quantifiers) and different versions of temporal and modal logics are quite important for theoretical
computer science.
2.2. Sets, spaces and k-partitions
We will consider hierarchies and reducibilities in many sets and (topological) spaces, but most attention is paid to only
few of them, namely the natural numbers, words over a given finite alphabet, the Baire and Cantor spaces and the Baire and
Cantor domains. In this subsection we briefly recall notation and definitions related to these sets and spaces.
We use the standard set-theoretical symbols ∅, ∪, ∩, −, \, ×, ⊆, and ⊂(strict inclusion). The cardinality of a set
A is denoted by |A|. We denote (sets and) spaces by M, X, Y, . . . , elements of spaces (points) by x, y, . . . (for concrete
examples of spaces also special notation may be used), subsets of spaces (pointsets) by A, B, . . . and classes of subsets of
spaces (pointclasses) by A, B, . . .. By P(X) we denote the powerset of X, i.e. the class of subsets of X. By A we denote the
complement of a set A ⊆X, i.e. A = X \ A and by co-A = {A | A ∈A} — the dual of a pointclass A. A pointclass A is self-dual
if A = co-A. By A△B we denote the symmetric difference (A \ B) ∪(B \ A) of A and B. The Boolean closure of a pointclass A
(i.e., the closure under finite unions and intersections and complement) is denoted BC(A).
Functions are sets of ordered pairs satisfying the usual ‘‘uniqueness’’ condition. The domain and range of a function f
are denoted dom(f ) and rng(f ), respectively. A function f with dom(f ) = A and rng(f ) ⊆B (rng(f ) = B) is called a
function from A to (respectively, onto) B, in symbols f : A →B; in case dom(f ) ⊆A we say that f is a partial function
from A to be B, in symbols f : A ⇀B. The composition of functions f and g is denoted by f ◦g or just by fg. The set of
functions from A to B is denoted by BA. Functions f ∈BA are identified with families {f (a)}a∈A. For a well-ordered set A, such
indexed families are called sequences or, if we want to be more precise, A-sequences. The usual notation f (a) for the value of
a function is sometimes simplified to fa, fa or f a. If f : A × B →C then λyf (x, y) denotes the function relating to any y ∈B
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
119
Fig. 1. 2∗and ω∗.
the corresponding value f (x, y), for a fixed x ∈A; this function is also denoted by y 7→f (x, y). Similarly we can use the
notation λxf (x, y).
Let ω∗be the set of finite sequences (strings) of natural numbers. The empty string is denoted by ∅, the concatenation of
strings σ, τ by σ ⌢τ or just by στ, the length of σ by |σ|. By ω+ we denote the set of finite non-empty strings in ω. By σ ⊑τ
we denote that the string σ is an initial segment of the string τ (please be careful in distinguishing ⊑and ⊆). Let ωω be the
set of all infinite sequences of natural numbers (i.e., of all functions ξ : ω →ω). For σ ∈ω∗and ξ ∈ωω, we write σ ⊑ξ
to denote that σ is an initial segment of the sequence ξ. Define a topology on ωω by taking arbitrary unions of sets of the
form {ξ ∈ωω | σ ⊑ξ}, σ ∈ω∗, as the open sets. The space ωω with this topology known as the Baire space is of primary
importance for DST.
For any n, 1 < n < ω, let n∗be the set of finite strings of elements of {0, . . . , n −1}, n∗⊆ω∗. E.g., 2∗is the set of finite
strings of 0’s and 1’s. For σ ∈n∗and ξ ∈nω, the relation σ ⊑ξ and the space nω are defined in the same way as in the
previous paragraph. It is well known that for each n, 2 ≤n < ω, the space nω is homeomorphic to the space 2ω called the
Cantor space. The Cantor space is a closed subspace of the Baire space. They are not homeomorphic because Cantor space is
compact while Baire space is not. In computer science people often consider the sets A∗, A+ and Aω of finite (respectively,
finite non-empty and infinite) words over a finite alphabet A. Mathematically, these sets are of course the same as n∗, n+
and nω respectively, where n = |A|.
The Cantor and Baire spaces are shown in Fig. 1 (they are the sets of paths through the corresponding full binary and
ω-ary trees).
The Baire domain is the set ω≤ω = ω∗∪ωω of finite and infinite strings of natural numbers, with the unions of sets of
the form {ξ ∈ω≤ω | σ ⊑ξ}, σ ∈ω∗, as open sets. For any 2 ≤n < ω, the Cantor domain is the set n≤ω = n∗∪nω of finite
and infinite words over the alphabet n considered as the subspace of the Baire domain. Note that the Cantor domains n≤ω
and m≤ω are not homeomorphic for distinct n and m.
For a given set or space X, we are interested in classification of subsets of X according to their ‘‘complexity’’. We
understand the last term in a broader sense than in the computation complexity theory. It might be the complexity
of computing a set, the complexity of its definition in some language or the topological complexity. But any possible
interpretation of this word gives rise to structures (hierarchies and reducibilities on P(X)) which have many common
features. These features are the main interest for the theory presented in this paper.
More generally, we consider hierarchies and m-reducibilities for the k-partitions of X. We identify a natural number k ∈ω
with the set {0, . . . , k −1}. By k-partitions of X we mean maps ν ∈kX; such maps are in a natural bijective correspondence
with the tuples (A0, . . . , Ak−1) of pairwise disjoint sets satisfying A0 ∪· · · ∪Ak−1 = X. Note that the 2-partitions of X
essentially coincide with subsets of X. For any class C ⊆P(X), let Ck denote the set of C-partitions (more exactly, C-
measurable k-partitions), i.e. partitions ν ∈kX such that ν−1(i) ∈C for each i < k.
The case of k-partitions of X for k > 2 is not often considered in the literature probably because many people feel that
it has nothing special compared with the case of subsets of X, while many others think that it is just a trivial particular case
of functions defined on X. The author belongs to those believing that the non-trivial k-partitions deserve special attention.
The study of arbitrary functions with domain X misses some important combinatorial features of the finite partitions while
sticking to the case of subsets of X oversimplifies things because for k > 2 many properties of k-partitions become much
more complicated than for the case of sets. E.g., k-partitions in computability theory and complexity theory are closely
related to such interesting notions as the multiple reducibility or separability of tuples of sets. For these reasons we pay
considerable attention below to hierarchies and reducibilities on k-partitions. We will see that in this context also the case
of k-partitions is much more complicated (but still manageable) than the case of sets.
2.3. Ordinals
We assume the reader to be acquainted with the notions of ordinal and cardinal (see e.g. [74]). Ordinals are important
for the hierarchy theory because levels of many hierarchies are often (almost) well ordered by inclusion. This opens the
possibility to estimate complexity of sets by ordinals.
120
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
Ordinals are denoted by α, β, γ , . . .. The successor α+1 of an ordinal α is defined by α+1 = α∪{α}. Every ordinal α is the
set of all smaller ordinals, i.e.α = {β | β < α}. E.g., 0 = ∅, 1 = {0}, 2 = {0, 1}, . . . , k+1 = {0, 1, . . . , k}, ω = {0, 1, 2, . . .}.
Ordinals may be considered as the order types of well orders (i.e., linear orders without infinite descending chains): any well
order (P; <) is isomorphic to (α; <) (i.e., to (α; ∈)) for a unique ordinal α.
Ordinals generalize natural numbers, and for them one can also use inductive definitions and proofs (for ordinals α > ω
such proofs are sometimes called proofs by transfinite induction). Inductive definitions and proofs over ordinals > ω are
quite similar to those over the naturals, only this time along with the successor ordinals α + 1 one has to deal also with the
limit ordinals (i.e. non-zero ordinals that are not successors).
We use some well-known facts about the ordinal arithmetic. As usual, α + β, α · β and αβ denote the ordinal addition,
multiplication and exponentiation of α and β, respectively. The context will help to distinguish the ordinal exponentiation
from the set exponentiation denoted in the same way but having a quite different meaning.
The ordinal addition is defined by induction as follows: α + β = α ∪sup{(α + γ ) + 1 | γ < β}. It is known and easy to
check by induction that α + 0 = 0, α + (β + 1) = (α + β) + 1 and α + λ = sup{(α + γ ) | γ < λ} for a limit ordinal λ.
Moreover, α + β is the order type of the order (C; ≺) defined by
C = ({0} × α) ∪({1} × β), (a, γ ) ≺(b, δ) ↔a < b ∨(a = b ∧γ < δ).
Note that ω + 1 ̸= 1 + ω, 0 + α = α, (α + β) + γ = α + (β + γ ), α < β →γ + α < γ + β, α ≤β →α + γ ≤β + γ ,
for α ≥β there is a unique γ (denoted by γ = α −β) with α = β + γ .
The ordinal multiplication is defined by induction α · β = sup{α · γ + α | γ < β}. It is well known that α · 0 = 0,
α(β + 1) = αβ + α and αλ = sup{αγ | γ < λ} for a limit ordinal λ. Moreover, αβ is the order type of (α × β; ≺) where
(γ , δ) ≺(ε, ζ) ↔δ < ζ ∨(δ = ζ ∧γ < ε). Note that ω · 2 ̸= 2 · ω, 0 · α = 0, α · 1 = 1 · α = α, (αβ)γ = α(βγ ),
α(β + γ ) = αβ + αγ , α < β ∧0 < γ →γ α < γ β, α ≤β →αγ ≤βγ , for all α and β > 0 there are unique γ , ρ with
α = βγ + ρ.
The ordinal exponentiation is defined by induction: α0 = 1 and αβ = sup{αγ · α | γ < β} for β > 0. It is well-
known that αβ+1 = αβ · α and αλ = sup{αγ | γ < λ} for a limit ordinal λ. It is easy to check that 01+β = 0, 1β = 1,
α < β ∧1 < γ →γ α < γ β, αβ+γ = αβ · αγ , (αβ)γ = αβγ .
We will often mention the ordinals ω, ω2, ω3, . . . and ωω. The last ordinal is the order type of finite sequences (k1, . . . , kn)
of natural numbers k1 ≥· · · ≥kn, ordered lexicographically. Any non-zero ordinal α < ωω is uniquely representable in the
form α = ωk1 + · · · + ωkn with ω > k1 ≥· · · ≥kn.
We will also use the bigger ordinal ε0 = sup{ω, ωω, ω(ωω), . . .}. It is well-known that any non-zero ordinal α < ε0 is
uniquely representable in the form α = ωγ0 + · · · + ωγk for a finite sequence γ0 ≥· · · ≥γk of ordinals < α. The ordinal ε0
is the smallest solution of the ordinal equation ω~ = ~.
All concrete ordinals considered above are computable, i.e. they are order types of computable well orders on computable
subsets of ω. The first non-computable ordinal ξ = ωCK
1 is also important for the hierarchy theory, it is known as the Church–
Kleene ordinal. This ordinal gives rise to some other interesting ordinals, e.g. ξ ω. Any non-zero ordinal α < ξ ω is uniquely
representable in the form α = ξ n0α0 + · · · + ξ nkαk where k < ω, ω > n0 > · · · > nk and 0 < αi < ξ.
All concrete ordinals mentioned above are countable. The first non-countable ordinal ω1 is also of primary importance
for the hierarchy theory. From this ordinal one can construct many other interesting ordinals, in particular ωω
1 , ωω1
1 ,
ω
(ωω1
1 )
1
, . . .. Similarly to the previous paragraph, any non-zero ordinal α < ωω
1 is uniquely representable in the form
α = ω
n0
1 α0 + · · · + ω
nk
1 αk where k < ω, ω > n0 > · · · > nk and 0 < αi < ω1.
Even much bigger ordinals (like the Wadge ordinal) are of interest for the hierarchy theory. Since those bigger ordinals
are defined in a more complicated way, we will give the corresponding exact references to the interested reader later, when
we will discuss the corresponding hierarchies.
2.4. Well posets
Here we briefly discuss the so called well posets which are an important generalization of ordinals. We will see below
that the levels of hierarchies of k-partitions are often well posets under inclusion.
We use some standard notation and terminology on partially ordered sets (posets) which may be found e.g. in [30]. Recall
that preorder is a structure (P; ≤) satisfying the axioms of reflexivity ∀x(x ≤x) and transitivity ∀x∀y∀z(x ≤y ∧y ≤z →
x ≤z). Partial order is a preorder satisfying the antisymmetricity axiom ∀x∀y(x ≤y ∧y ≤x →x = y). Linear order (or
chain) is a partial order satisfying the connectivity axiom ∀x∀y(x ≤y ∨y ≤x).
Any partial order ≤on P induces the relation of strict order < on P defined by a < b ↔a < b ∧a ̸= b and called the
strict order related to ≤. The relation ≤can be restored from < so we may safely apply the terminology on partial orders
also to the strict orders. A poset (P; ≤) will be often shorter denoted just by P. Any subset of a poset P may be considered
as a poset with the induced partial order. In particular, this applies to the ‘‘upper cones’’ ˇx = {y ∈P | x ≤y} defined by any
x ∈P.
It is well known that any preorder (P; ≤) induces the partial order (P∗; ≤∗) called the factorization or the quotient of P.
The set P∗is the quotient set of P under the equivalence relation defined by a ≡b ↔a ≤b ∧b ≤a; the set P consists of
all equivalence classes [a] = {x | x = a}, a ∈P. The partial order ≤∗is defined by [a] ≤∗[b] ↔a ≤b. We will not be very
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
121
pedantic when applying notions about posets also to preorders; in such cases we mean the corresponding quotient-poset
of the preorder.
A partial order (P; ≤) is called well-founded if it has no infinite descending chains. In this case there are a unique ordinal
rk(P) and a unique rank function rkP from P onto rk(P) satisfying a < b →rk(a) < rk(b). It is defined by induction
rkP(x) = sup{rkP(y) + 1 | y < x}. The ordinal rk(P) is called the rank of P, and the ordinal rkP(x) is called the rank of the
element x ∈P in P.
A well preorder is a preorder P that has neither infinite descending chains nor infinite antichains. With any well preorder
P we associate its rank and also its width w(P) defined as follows: if P has antichains with any finite number of elements,
then w(P) = ω, otherwise w(P) is the greatest natural number n for which P has an antichain with n elements. The theory
of well preorders is a well developed field with several deep results and applications, see e.g. [79]. It is also of great interest
to the hierarchy theory.
2.5. Discrete weak semilattices
Here we summarize some auxiliary algebraic notions and facts from [109,110,135,142] useful in the sequel, especially
for understanding the hierarchies of k-partitions. Recall that a semilattice is a structure (P; ≤, ∪) consisting of a preorder
(P; ≤) and a binary operation ∪of supremum in (P; ≤) (thus, we consider only upper semilattices). By a σ-semilattice we
mean a semilattice in which every countable set of elements has a supremum. With a slight abuse of notation, we apply the
operation ∪also to finite non-empty subsets of P. This causes no problem because the supremum of any non-empty finite
set is unique up to the equivalence relation ≡induced by ≤.
We start with a definition from [138] which is a slight modification of the corresponding notions introduced in [109,110].
Definition 2.1. Let I be a non-empty set. By I-discrete weak semilattice (dws, for short) we mean a structure (P; ≤, {Pi}i∈I)
with Pi ⊆P such that:
(i) (P; ≤) is a preorder;
(ii) for all n < ω, x0, . . . , xn ∈P and i ∈I there exists ui = ui(x0, . . . , xn) ∈Pi which is a supremum for x0, . . . , xn in Pi,
i.e. ∀j ≤n(xj ≤ui) and for any y ∈Pi with ∀j ≤n(xj ≤y) it holds ui ≤y;
(iii) for all n < ω, x0, . . . , xn ∈P, i ̸= i′ ∈I and y ∈Pi′, if y ≤ui(x0, . . . , xn) then y ≤xj for some j ≤n.
Though the notion of dws might seem rather exotic, it is closely related to hierarchies and m-reducibilities. The relation
is roughly a follows: if the elements x0, . . . , xn represent complete sets (or k-partitions) in some levels of a hierarchy then
the elements ui = ui(x0, . . . , xn), i ∈I, may represent sets (or k-partitions) complete in the levels of the hierarchy which
are minimal among the levels strictly above the levels of x0, . . . , xn.
By σ -dws we mean a dws (P; ≤, {Pi}i∈I) that has the same properties also for all ω-sequences x0, x1, . . . in P.
Throughout the paper, we are interested mostly in the case when I = k for some integer k ≥2; in this case we write
the dws also in the form (P; ≤, P0, . . . , Pk−1). Note that the operations ui above may be considered as n-ary operations of
P for each n > 0 (in σ -dws’s even as ω-ary operations). These operations are associative and commutative. The following
properties of dws’s are immediate (see [109,110]).
Proposition 2.2. Let (P; ≤, P0, . . . , Pk−1) be a dws and y, x0, . . . , xn ∈P0 ∪· · · ∪Pk−1.
(i) If xj ≤y for all j ≤n then ui(x0, . . . , xn) ≤y for some i < k.
(ii) If y ≤ui(x0, x . . . , xn) for all i < k then y ≤xj for some j ≤n.
(iii) If {x0, . . . , xn} has no greatest element then it has no supremum in P0 ∪· · · ∪Pk−1.
Note that if (P; ≤, P0, . . . , Pk−1) is a σ-dws then the last proposition holds also for the ω-sequences x0, x1, . . . ∈
P0 ∪· · · ∪Pk−1. Note also that for any dws the unary operations ui are closure operators on (P; ≤), i.e. they satisfy
∀x(x ≤ui(x)), ∀x∀y(x ≤y →ui(x) ≤ui(y)) and ∀x(ui(ui(x)) ≤ui(x)).
They have also the following discreteness property: ∀x∀y(ui(x) ≤uj(y) →ui(x) ≤y), for all i ̸= j. This shows a close
relation of dws’s to the so called semilattices with discrete closures (dc-semilattices for short) introduced in [110].
Definition 2.3. By dc-semilattice we mean a structure (S; ≤, ∪, p0, . . . , pk−1) satisfying the following axioms:
(1) (S; ∪) is an upper semilattice, i.e. it satisfies (x ∪y) ∪z = x ∪(y ∪z), x ∪y = y ∪x and x ∪x = x, for all x, y, z ∈S.
(2) ≤is the partial order on S induced by ∪, i.e. x ≤y iff x ∪y = y, for all x, y ∈S.
(3) Every pi, i < k, is a closure operation on (S; ≤), i.e. it satisfies x ≤pi(x), x ≤y →pi(x) ≤pi(y) and pi(pi(x)) ≤pi(x),
for all x, y ∈S.
(4) The operations pi have the following discreteness property: for all distinct i, j < k, pi(x) ≤pj(y) →pi(x) ≤y, for all
x, y ∈S.
(5) Every pi(x) is join-irreducible, i.e. pi(x) ≤y ∪z →(pi(x) ≤y ∨pi(x) ≤z), for all x, y, z ∈S.
By dcσ -semilattice we mean a dc-semilattice (S; ≤, ∪, p0, . . . , pk−1) such that (S; ∪) is a σ -semilattice and the axiom
(5) of dc-semilattices holds also for supremums of countable subsets of S, i.e. pi(x) ≤S
j<ω yj implies that pi(x) ≤yj for
some j < ω; we express this by saying that pi(x) is σ -join-irreducible.
The next easy assertion shows that dws’s that are semilattices essentially coincide with dc-semilattices.
122
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
Fig. 2. Infinite descending chain in (P2; ≤).
Proposition 2.4. (i) Let (P; ≤, P0, . . . , Pk−1) be a dws and (P; ≤, ∪) is a semilattice. Then the structure (P; ≤, ∪, u0, . . . , uk−1)
with the unary operations ui on P is a dc-semilattice.
(ii) If (P; ≤, ∪, p0, . . . , pk−1) is a dc-semilattice then (P; ≤, P0, . . . , Pk−1), where Pi = {pi(x) | x ∈P} is a dws.
(iii) The maps (P; ≤, ∪, P0, . . . , Pk−1) 7→(P; ≤, ∪, u0, . . . , uk−1)) and back are inverses of each other, up to isomorphism
of the quotient-structures.
(iv) Similar relationship exists between dcσ -semilattices and σ-dws’s.
In [110] we considered also some variations of dws’s and dc-semilattices. By 2-dws we mean a structure (P; ≤, {P
j
i}i,j∈I)
with the properties similar to those of dws’s with the only exception: this time the property (iii) states that for all n < ω,
x0, . . . , xn ∈P, i ̸= i′, j ̸= j′ and y ∈P
j′
i′ , if y ≤u
j
i(x0, . . . , xn) then y ≤xl for some l ≤n. By 2-dc-semilattice we mean a
structure (P; ≤, ∪, {r
j
i}i,j∈I) satisfying the same properties as dc-semilattices with a similar modification of the discreteness
property: for all x, y ∈P, if i ̸= i′, j ̸= j′ and r
j
i(x) ≤r
j′
i′ (y) then r
j
i(x) ≤y. Analogs of Propositions 2.2—2.4 are easily seen
to hold also for 2-dws’s and 2-dc-semilattices. We state also the following evident relationship between the introduced
notions.
Proposition 2.5. (i) If (P; ≤, {P
j
i}i,j∈I) is a 2-dws then (P; ≤, {Pi
i}i∈I) is a dws.
(ii) If (P; ≤, ∪, {r
j
i}i,j∈I) is a 2-dc-semilattice then (P; ≤, ∪, {ri
i}i∈I) is a dc-semilattice.
(iii) Similar relationship exists between 2-σdc-semilattices and 2-σ -dws’s.
In [138] it was shown that most non-trivial dws’s and 2-dws’s have undecidable first-order theories. In particular, the
following fact holds true.
Proposition 2.6. Let k ≥2 and let (P; ≤, P0, . . . , Pk−1) be a dws such that, for some i < k, (Pi; ≤) has antichains with any
finite number of elements. Then the first-order theory FO(P; ≤) is hereditary undecidable. In particular, if k ≥3 and P is a dws
or a 2-dws that is not linearly ordered then FO(P) is hereditary undecidable.
2.6. The h-preorder
Here we recall some definitions and facts about the so called h-preorders studied in [60,61,75,86,133,142,80,81] in
relation with the difference hierarchies and the Wadge reducibility of k-partitions, and make some additional remarks. The
h-preorders provide minimal models for some theories discussed in the previous section. Most posets considered here are
assumed to be (at most) countable and without infinite chains. The absence of infinite chains in a poset (P; ≤) is of course
equivalent to well-foundednes of both (P; ≤) and (P; ≥).
By forest we mean a poset without infinite chains in which every upper cone ˇx is a chain. Tree is a forest having the biggest
element (called the root of the tree). Let (T; ≤) be a tree without infinite chains; in particular, it is well-founded. As for each
well-founded partial order, there is a canonical rank function rkT from T to ordinals. The rank rk(T) of (T; ≤) is by definition
the ordinal rkT(r), where r is the root of (T; ≤). It is well-known that the rank of any countable tree without infinite chains
is a countable ordinal, and any countable ordinal is the rank of such a tree.
A k-poset is a triple (P; ≤, c) consisting of a poset (P; ≤) and a labeling c : P →k. Rank of a k-tree (or a k-poset)
(T; ≤, c) is by definition the rank of (T; ≤). Morphism f : (P; ≤, c) →(P′; ≤′, c′) between k-posets is a monotone function
f : (P; ≤) →(P′; ≤′) respecting the labelings, i.e. satisfying c = c′◦f . Let e
Pk, e
Fk, e
Tk and e
T i
k denote the classes of all countable
k-posets, countable k-forests, countable k-trees and countable i-rooted k-trees without infinite chains, respectively. The h-
preorder ≤on e
Pk is defined as follows: (P, ≤, c) ≤(P′, ≤′, c′), if there is a morphism from (P, ≤, c) to (P′, ≤′, c′). Let Pk,
Fk, Tk and T i
k be the subsets of the corresponding tilde-sets formed by finite posets only. Furthermore, let Lk and Ck be the
sets of finite k-lattices and k-chains, respectively. Note that the empty poset ∅is assumed to be in Fk but not in e
Tk; it is the
smallest element of ( e
Pk; ≤).
As observed in [75,133,138], the structure (Pk; ≤) for each k ≥2 and its substructure (Lk; ≤) for each k ≥3, contain
infinite antichains and infinite descending chains (see Figs. 2–5 where L1, L2, . . . is the sequence of k-lattices from Fig. 2).
Since the h-preorder is closely related to the order of levels of the hierarchies of k-partitions (and they are expected to be
well partial ordered), we think that such examples show that the structures (Pk; ≤) and (Lk; ≤) are probably too rich in
general for our purposes here.
In contrast, the following result from [142] shows that the structure of k-forests has much better properties. For this
reason we stick to the structure ( e
Fk; ≤) below.
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
123
Fig. 3. A sequence containing the infinite antichain {Cp | p prime} in (P2; ≤).
Fig. 4. Infinite descending chain in (Lk; ≤).
Fig. 5. Infinite antichain in (Lk; ≤).
Fig. 6. An initial segment of G e
F2.
Proposition 2.7. (i) For any k ≥2, ( e
Fk; ≤) is a well preorder of rank ω1.
(ii) For any k ≥2, (Fk; ≤) is an initial segment of ( e
Fk; ≤) that consists exactly of the elements of finite rank.
(iii) w( e
F2) = 2 and w( e
Fk) = ω for k > 2.
(iv) For any k ≥2, the quotient structure of ( e
Fk; ≤) is a distributive lattice and a σ -semilattice.
Pictures 6 and 7 show initial segments of the structures G e
F2 and G e
F3 (the circles depict h-equivalence classes).
Let P ⊔Q be the join of k-posets P, Q and F
i Pi = P0 ⊔P1 ⊔· · · the join of an infinite sequence P0, P1, . . . of k-posets. For
a k-forest F and i < k, let pi(F) be the k-tree obtained from F by adjoining a new biggest element and assigning the label i to
this element. It is clear that the introduced operations respect the h-equivalence and that any finite (countable) k-forest is
equivalent to a finite (respectively, countable) term of signature {⊔, p0, . . . , pk−1, 0, . . . , k −1} without free variables (the
constant symbol i in the signature is interpreted as the singleton tree carrying the label i). For k-trees T0, T1, . . . and i < k,
define the k-tree Ui(T0, T1, . . .) = pi(T0 ⊔T1 ⊔· · · ). The following facts were observed in [133,141,142].
Proposition 2.8. (i) The quotient structure of ( e
Fk; ⊔, p0, . . . , pk−1) (of (Fk; ⊔, p0, . . . , pk−1)) is a dcσ -semilattice (respectively,
a dc-semilattice).
(ii) The quotient structure of (e
Tk; ≤, e
T 0
k , . . . , e
T k−1
k
) (of (Tk; ≤, T 0
k , . . . , T k−1
k
)) is a σ -dws (respectively, a dws).
The following result from [141,142] shows that the structures from Proposition 2.8 have natural minimality properties.
124
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
Fig. 7. An initial segment of G e
F3.
Proposition 2.9. (i) Let (S; ≤, ∪, p0, . . . , pk−1) be a dcσ-semilattice and a be an element of S such that a < pi(a) for all i < k.
Then the sub-dcσ-semilattice (a) of S generated by a is isomorphic to the quotient structure of ( e
Fk; ≤, ⊔, p0, . . . , pk−1). A similar
assertion holds true for dc-semilattices and Fk.
(ii) Let (S; ≤, u0, . . . , uk−1) be a σ -dws and {a0, . . . , ak−1} an antichain in (S; ≤). Then the sub-σ-dws (a0, . . . , ak−1) of S
generated by {a0, . . . , ak−1} is isomorphic to the quotient structure of (e
Tk; ≤, U0, . . . , Uk−1). A similar assertion holds for dws’s
and Tk.
In [80,81] some facts about definability, automorphisms and undecidability in the introduced structures were established,
e.g.:
Proposition 2.10. For any k ≥3, each element of the quotient structure of (Fk; ≤, 0, . . . , k −1) is first-order definable. The
same is true for the quotient structure of (Tk; ≤, 0, . . . , k −1).
As was shown in the journal version of [81] written jointly with A. Zhukov, similar definability result holds also for
( e
Fk; ≤, 0, . . . , k −1) and (e
Tk; ≤, 0, . . . , k −1) but in this case we have to replace the first-order definability by the Lω1,ω-
definability.
Let Sk be the symmetric group on k elements, i.e. the group of permutations of elements 0, . . . , k −1. Let Aut(A) denote
the automorphism group of a structure A. By ≃we denote the isomorphism relation. The next result is a straightforward
generalization of the corresponding fact in [81].
Proposition 2.11. (i) For any k ≥2 we have Aut(Fk; ≤) ≃Aut(Tk; ≤) and Aut( e
Fk; ≤) ≃Aut(e
Tk; ≤).
(ii) Aut(T2; ≤) ≃Sω
2 and Aut(e
T2; ≤) ≃Sω1
2 .
(iii) For any k ≥3, Aut(Fk; ≤) ≃Sk ≃Aut( e
Fk; ≤).
(iv) For all k ≥2 and i < k, Aut(T i
k ; ≤) ≃Sk−1 ≃Aut(e
T i
k ; ≤).
From Proposition 2.6 it follows that first-order theories of (Fk; ≤) for each k ≥3 and of (Pk; ≤) for each k ≥2
are hereditary undecidable (for the first structure this was shown in [80], for the second this was shown recently by A.
Zhukov and myself (see [144] which is the journal version of [138]). For the first structure, the following strengthening was
established in [82].
Proposition 2.12. (i) For all k > 2 and i < k, the first-order theories of the quotient structures of (Fk; ≤) and (Tk; ≤) are
computably isomorphic to the first-order arithmetic FO(ω, +, ·).
(ii) For all k > 2 and i < k, FO(ω; +, ·) is m-reducible to FO( e
Fk; ≤) and FO(e
Tk; ≤).
Additional information on the h-preorder and its applications may be found in [87,88].
2.7. Hierarchies of sets
The word ‘‘hierarchy’’ is used in mathematics in many different senses. In the broadest sense, hierarchies are
identified with classifications of some objects (usually sets) by means of relations like the inclusion relation; the resulting
mathematical structure may be an arbitrary partial order. A more restricted use of the word (meaning a classification of some
objects by means of ordinals) appeared in DST and was used afterwards in several other fields, in particular in computability
theory. In this paper we use the word ‘‘hierarchy’’ only in this restricted sense.
Some of the notions introduced below are versions of the corresponding notions first proposed by Addison [5] in his
‘‘axiomatic approach to hierarchy theory’’, while some others were proposed by the author [119]. In fact, we formulate
here only the ‘‘abstract’’ version of the corresponding notions which apply to all concrete hierarchies considered below. The
hierarchies in concrete fields (e.g., in computability theory or DST) may have additional features, in such cases the notions
can be made more precise in the corresponding sections. We start with the notion of hierarchy.
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
125
Definition 2.13. (i) Let X be a set and η be an ordinal. By abstract η-hierarchy of sets in X we mean a sequence {Hα}α<η of
subsets of P(X) such that Hα ⊆Hβ ∩co-Hβ for all α < β < η.
(ii) The classes Hα \ co-Hα and co-Hα \ Hα are called non-self-dual constituents of {Hα}, while the classes (Hα ∩co-
Hα) \ (S
β<α Hβ ∩co-Hβ) are called self-dual constituents of {Hα}.
(iii) A hierarchy {Hα} does not collapse if Hα ̸⊆co-Hα for all α < η.
(iv) A hierarchy {Hα} is non-trivial if Hα ̸⊆co-Hα for some α < η.
Note that the definition does not require that any hierarchy does not collapse. In [5] the term ‘‘prehierarchy’’ is used
to denote hierarchies in the sense of our definition. We decided not to use it here in order to avoid conflicts with some
well-established terminology (i.e. on the polynomial-time hierarchy). Another reason is that when we consider abstract
hierarchies in the next section it is easier to develop the general theory for the case of possibly collapsing hierarchies (because
we usually do not know from the beginning if a given hierarchy collapses or not). Consequently, length of an η-hierarchy
{Hα}α<η (i.e., the rank of ({Hα | α < η}; ⊆)) is an ordinal γ satisfying γ ≤η, not necessarily γ = η.
Sometimes (e.g. in Section 5) we use a slightly more general version of the abstract hierarchy, when the levels Hα are
subsets of a Boolean algebra B. From the Stone representation theorem it follows that this seemingly more general notion
is in fact equivalent to the definition above.
For many concrete hierarchies people denote the α-th level by Σα, possibly with an upper index or using a different
font (e.g., the boldface 6α is the standard notation in DST). We will also follow this tradition when dealing with the
concrete hierarchies. Recall that in the ‘‘Σ-notation’’ the dual class for Σα is always denoted by Πα while ∆α denotes the
corresponding ‘‘ambiguous’’ class Σα ∩Πα.
Now we introduce an important for this paper notion of refinement, and actually it is useful to have two versions of this
notion. The next definition also contains some other relevant notions.
Definition 2.14. Let {Hα} and {Gβ} be hierarchies in X.
(i) {Hα} is a refinement of {Gβ} in a given level β if S
γ <β(Gγ ∪co-Gγ ) ⊆S
α Hα ⊆(Gβ ∩co-Gβ). Such a refinement is
called exhaustive if S
α Hα = Gβ ∩co-Gβ.
(ii) {Hα} is a (global) refinement of {Gβ} if for any β there is an α with Hα = Gβ, and S
α Hα = S
β Gβ.
(iii) A hierarchy is called discrete in a given level if it has no non-trivial refinements in this level. A hierarchy is (globally)
discrete if it is discrete in each level.
(iv) {Hα} is extension of {Gβ} if the sequence {Gβ} is an initial segment of the sequence {Hα}.
The readers acquainted with DST will immediately remember several natural examples for the introduced notions: the
transfinite Borel hierarchy is an extension of the finite Borel hierarchy, the Borel hierarchy is an exhaustive refinement of
the projective hierarchy in the first level (the Suslin theorem), the difference hierarchy over any non-zero level of the Borel
hierarchy is an exhaustive refinement of the Borel hierarchy in the next level (the Hausdorff–Kuratowski theorem). The
history of hierarchy theory shows that similar facts are not exceptions. Often, if a natural hierarchy in not discrete in a given
level, it has a natural exhaustive refinement in this level; hence, if such a refinement is not yet known it makes sense to
search for it. In the opposite direction, natural hierarchies are often exhaustive refinements of a natural coarser hierarchy
in some level; hence, if such a coarsification is not yet known it makes sense to search for it. In the sequel, we will see many
examples illustrating the described situation.
The following notion was introduced in [5].
Definition 2.15. (i) A hierarchy {Hα} is called perfect in a level β if S
γ <β(Hγ ∪co-Hγ ) = Hβ ∩co-Hβ. A hierarchy is (globally)
perfect if it is perfect in all levels.
Obviously, if a hierarchy is perfect in some level (globally perfect) then it is discrete in that level (respectively, globally
discrete).
2.8. Hierarchies of k-partitions
As we will see later, the structure of hierarchies of k-partitions for k > 2 is usually more complicated than the structure
of the hierarchies of sets. In this subsection we give a definition of hierarchy of k-partitions that covers all hierarchies we
discuss below. We will not try to define analogs of the other notions from the previous subsection because it is currently
not clear to the author which analogs are the ‘‘right’’ ones: the investigation of the hierarchies of k-partitions is still in its
beginning.
Levels of the hierarchies of sets are almost well-ordered by inclusion. A complication for the hierarchies of k-partition
is caused by the fact that the structure of their levels is often more complicated. To capture some essential properties of
this structure we introduce the notion of k-symmetric poset: this is a triple (P; ≤, ϕ) consisting of a poset (P; ≤) and an
isomorphic embedding ϕ : Sk →Aut(P) of the symmetric group Sk into the automorphism group of (P; ≤). Simplifying
notation, we sometimes denote (P; ≤, ϕ) just by P. The idea comes from the fact that the group Sk acts on the set kX of
k-partitions of X according to the rule h 7→λν.h ◦ν and hierarchies with the structure of levels P should somehow respect
this fact.
126
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
An example of a k-symmetric poset is (¯k · α; ≤, ϕ) where α is an ordinal, (¯k · α; <) is obtained by replacing any point
of α by the antichain with k elements and ϕ(h) permutes the elements of each copy of the antichain according to h. We use
the bar in ¯k in order to distinguish the antichain of k elements from the ordinal k which is a chain of k elements. Another
example is (Tk; ≤, ϕ) where (Tk; ≤) is the h-preorder of k-trees from Section 2.6 and ϕ(h) sends any k-tree (T, ≤, t) to the
k-tree (T, ≤, h ◦t).
Definition 2.16. Let (P; ≤, ϕ) be a k-symmetric poset. A P-hierarchy of k-partitions of X is a family {Hp}p∈P of subsets of kX
such that Hφh(p) = {h ◦ν | ν ∈Hp} for all h ∈Sk and p ∈P. We say that such a hierarchy does not collapse if p ≤q is
equivalent to Hp ⊆Hq.
Note that we will consider P-hierarchies of partitions mostly for the case when (P; ≤) is a well poset; then of course the
structure ({Hp | p ∈P}; ⊆) of levels of a P-hierarchy under inclusion is also a well poset. For k = 2 and P = ¯2 · η the notion
of P-hierarchy essentially coincides with the notion of η-hierarchy of sets. For k > 2 and P = ¯k · η the structure of levels
of the P-hierarchy of k-partitions is in a sense the simplest generalization of the η-hierarchy of sets. For P = (Tk; ≤, ϕ) the
structure of levels of the P-hierarchy of k-partitions is much more complicated. Note that (¯k·ω; ≤) is isomorphic to a cofinal
substructure of (Tk; ≤). An isomorphism is obtained by iterating the operation
(x0, . . . , xk−1) 7→(p0(x0, . . . , xk−1), . . . , pk−1(x0, . . . , xk−1))
starting form (0, . . . , k −1) (see Section 2.6).
2.9. m-reducibilities
In theoretical computer science, people are interested in different reducibilities, i.e. naturally defined preorders A ≤r B
on subsets of a given set X. The intuitive idea behind this notion is that A ≤r B is intended to mean that the ‘‘complexity’’
of a set A is less than or equal to that of B. The idea may be made precise in many different ways giving rise to a plenty
of reducibilities. Among those, most simple and useful turned out to be the so called many-one reducibilities (called m-
reducibilities for short). In this section, we define an abstract notion of m-reducibility. In the sequel, we will discuss several
concrete versions of m-reducibilities interesting for some fields of theoretical computer science.
Let F be a set of functions on X closed under composition and containing the identity function idX (intuitively, functions in
F are considered as ‘‘feasible’’ in some sense). We say that A is F-m-reducible to B (in symbols, A ≤F
m B) if A = f −1(B) for some
f ∈F. Obviously, ≤F
m is a preorder on P(X). Following the well-established jargon, we call elements of the corresponding
quotient-poset F-m-degrees. The degrees are assumed to be entities that ‘‘measure’’ the complexity of the corresponding sets.
This idea would work perfectly if the degree structure were simple (say, well-ordered or partially well-ordered): then we
could measure the complexity of sets by ordinals. Unfortunately, in most natural cases the degree structures are extremely
complicated and the idea in this simple version does not work.
Sometimes the situation becomes better if we restrict attention to a pointclass C ⊆P(X) (of course, this pointclass
should be in some respect interesting): it may turn out that the structure of F-m-degrees of sets in C is well-ordered (or
almost well-ordered, or partially well-ordered...).
Another approach to measuring complexity uses the well-known notion of complete set. We say that a pointclass
C ⊆P(X) is closed under F-m-reducibility if B ∈C and A ≤F
m B imply A ∈C. A set C is F-m-hard for C (in symbols,
C ≤F
m C) if A ≤F
m C for all A ∈C. A set C is F-m-complete for C (in symbols, C ≡F
m C) if C ∈C and C is F-m-hard for C. Note
that C = {A | A ≤F
m C} (i.e., C is a principal ideal of (P(X); ≤F
m) generated by C) iff C is closed under F-m-reducibility and
C ≡F
m C. These notions work especially well if a reducibility under consideration is related to a hierarchy in the sense of the
following definition.
Definition 2.17. Let {Hα}α<η be a hierarchy of sets in X and ≤F
m be an m-reducibility on P(X).
(i) We say that the reducibility fits the hierarchy (or, symmetrically, the hierarchy fits the reducibility) if any level Hα is
a principal ideal of (P(X); ≤F
m). Note that the dual levels will then also have this property.
(ii) We say that the reducibility perfectly fits the hierarchy if it fits the hierarchy, any non-self-dual constituent of the
hierarchy is an F-m-degree, and any non-empty self-dual constituent of the hierarchy is an F-m-degree.
(iii) The hierarchy is called F-m-discrete in a level α if it has no non-trivial refinement in that level which fits the F-m-
reducibility.
The relationship between hierarchies and reducibilities is illustrated by Fig. 8 (assume that the hierarchy fits the
reducibility and the points denote the complete sets for the levels). The complete sets for levels of the hierarchy pick up
from the (usually complicated) degree structure elements which are hopefully useful for estimation the complexity of sets
in C = S
α Hα. There are numerous examples when sets which are interesting in some sense turn out to be complete in a
level of a natural hierarchy under a natural reducibility; we then have some intuitive understanding of the complexity of the
set. Moreover, if a natural set A can not be ‘‘measured’’ in this sense by a hierarchy {Hα} (e.g., if Cn, Cn <F
m A <F
m Cn+1, Cn+1 for
some n < ω) then A may turn out to be F-m-complete in Hn+1 ∩co-Hn+1, or it is possible to find a natural refinement of {Hα}
in the level n+1 and estimate A by this refinement. Thus, if we consider hierarchies as ‘‘scales’’ for measuring the complexity
of sets, the situation becomes analogous to the well-known situation with using number systems to measure geometrical
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
127
Fig. 8. A hierarchy and an m-reducibility.
of physical entities: the impossibility to measure an important entity by a given number system, taken optimistically, may
mean that some richer number system has to be searched for. This analogy turns out very fruitful and sometimes leads to
a complete (in a natural sense) hierarchical classification of a given pointclass C. Such a full classification is, in the above
analogy, similar to the set of reals (or to the algebraic reals). We will see some examples below.
Remarks. 1. Let {Hα} fits F-m-reducibility, (P(X); ≤F
m) is an upper semilattice with an operation ⊕of supremum, and
Cα ⊕Cα ≡F
m Hα+1 ∩co-Hα+1 Then it is easy to see that {Hα} is F-m-discrete in the level α + 1. This situation often appears
in the concrete examples below (moreover, the similar fact usually holds also for the limit levels).
2. Let ≤F
m perfectly fit a hierarchy {Hα} and let C = S
α Hα. In the concrete examples below we will usually have one
of the following alternatives: 1) all self-dual constituents of {Hα} are empty; (2) all self-dual constituents of {Hα} are non-
empty. In case (1), {Hα} is perfect in all non-zero levels and the quotient-structure of (C; ≤F
m) has the order type ¯2 × η. The
case (2) will hold when the structure of F-m-degrees is an upper semilattice. Then it is easy to see that {Hα} is F-m-discrete
in all successor levels (in the concrete examples sometimes even in all non-zero levels). In both cases, we have a complete
understanding of the quotient-structure of (C; ≤F
m).
Notions of this subsection are extended to k-partitions in a straightforward way. For µ, ν ∈kX, µ ≤F
m ν means that
µ = ν ◦f for some f ∈F. Again, ≤F
m is a preorder on kX. Observe that if ν is F-m-complete in C ⊆kX and h ∈Sk then h ◦ν is
F-m-complete in Ch = {h ◦µ | µ ∈C}. For a k-symmetric poset (P; ≤, ϕ), we say that F-m-reducibility fits a P-hierarchy
of k-partitions if any level of the hierarchy is a principal ideal of (kX; ≤F
m).
2.10. Bases and fine hierarchies
Here we discuss a technical notion of base. It is important for this paper because our fine hierarchies are constructed
from a given base.
By base in X we mean a class L ⊆P(X) closed under finite unions and intersections (in other words, L is closed under
binary unions and intersections and ∅, X ∈L). For an ordinal α, by α-base in X we mean an α-hierarchy L = {Lβ}β<α
in X such that each level Lβ is a base. In particular, for any n < ω the (n + 1)-bases are sequences of bases of the form
(L0, . . . , Ln), with the corresponding inclusions. The bases L are naturally identified with the 1-bases. Note that any (n+1)-
base (L0, . . . , Ln) may be extended to the ω-base {Lk}k<ω (or even to a longer base) by setting Lk = BC(Ln) for all k > n.
In the sequel we deal mostly with bases, 2-bases, ω-bases and ω1-bases.
Next we define some special types of bases which are interesting for subsequent discussion. But first we recall definitions
of some so called ‘‘structural properties’’ which are important for the hierarchy theory. In DST, several structural properties
are known, e.g. separation, reduction, uniformization and norm properties [72]. Moreover, each property is known in several
variations. We will often mention the following simplest versions of the first two properties. The separation and reduction
properties are illustrated by Fig. 9.
Definition 2.18. Let X be a set and C ⊆P(X).
(i) The class C has the separation property if for every two disjoint sets A, B ∈C there is a set C ∈C ∩co(C) with
A ⊆C ⊆B. We say that C separates A from B (note that it is equivalent to say that C separates B from A).
(ii) The class C has the reduction property i.e. for all C0, C1 ∈L there are disjoint C′
0, C′
1 ∈L such that C′
i ⊆Ci for both
i < 2 and C0 ∪C1 = C′
0 ∪C′
1. The pair (C′
0, C′
1) is called a reduct for the pair (C0, C1).
(iii) The class C has the σ -reduction property if for each countable sequence C0, C1, . . . in C there is a countable sequence
C′
0, C′
1, . . . in C (called a reduct of C0, C1, . . .) such that C′
i ⊆Ci, C′
i ∩C′
j = ∅for all i ̸= j and S
i<ω C′
i = S
i<ω Ci.
It is well-known and easy to see that if C has the reduction property then the dual class co-C has the separation property,
but not vice versa. It is also well known that if C has the σ -reduction property then C has the reduction property but not
vice versa. Nevertheless, if C has the reduction property then for any finite sequence (C0, . . . , Cn) in C there is a reduct
C′
0, . . . , C′
n ∈C for (C0, . . . , Cn) which is defined similarly to the countable reduct above.
The following types of ω-bases will be frequently mentioned in the sequel.
128
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
Fig. 9. Separation and reduction properties.
Definition 2.19. Let L be an ω-base.
(i) L is reducible if any Ln has the reduction property.
(ii) L is interpolable if for each n < ω any two disjoint sets in co-Ln+1 are separable by a Boolean combination of elements
of Ln (equivalently, if for any n < ω the class co-Ln+1 has the separation property and BC(Ln) = Ln+1 ∩co-Ln+1).
We conclude this subsection by defining notions of the fine and coarse hierarchies.
Definition 2.20. Let L be an ω-base and H a hierarchy.
(i) We call H a fine hierarchy (w.r.t. L) if it is a refinement of L in some level or a global refinement.
(ii) We call H a coarse hierarchy (w.r.t. L) if L is a refinement of H in some level.
Analogs of the last two definitions may be formulated also for the important case of ω1-bases. We will skip these analogs
because, in this paper we concentrate on the technically easier ω-bases.
In subsequent sections we will concentrate mainly on the fine hierarchies w.r.t. a given ω-base L of interest for a branch
of theoretical computer science. Usually we start with some easy refinements of L, then proceed to more complicated
ones and arrive finally to a maximal (in some sense) refinement: the fine hierarchy over L which, in general, cannot be
further refined. In some ‘‘lucky’’ cases this refinement process leads to a complete classification of sets under consideration
according to their ‘‘complexity’’.
3. Abstract hierarchies
In this section we present some general notions and facts on the fine hierarchies in the abstract setting, i.e. over arbitrary
bases in arbitrary sets. This is useful because applicable to all ‘‘concrete’’ hierarchies discussed in the subsequent sections.
In a sense, the notions and results of this section describe a ‘‘common part’’ of the notions and results in the subsequent
sections.
3.1. Difference hierarchy
Here we discuss the difference hierarchies (DH) which form the simplest and most important class of the fine hierarchies.
DH’s were first introduced and studied by Hausdorff [54,55] in an abstract setting and in the topological context. In the
1960-s, the DH’s were studied by Addison [5] in the context of logic and by Putnam [106] Ershov [38] in the context of
computability theory. Later, DH’s were considered by many authors working in different fields of mathematics and computer
science.
Let X be a set and L a base in X. For any k < ω, let L(k) be the class of sets of the form S
i(L2i\L2i+1), where L0 ⊇L1 ⊇· · ·
is a descending sequence of sets from L and Li = ∅for i ≥k. The sequence {L(k)}k<ω is known as the difference hierarchy
over L. We start with formulating the well-known basic properties of the DH.
Proposition 3.1. DH over L is a hierarchy, i.e. L(k) ∪co-L(k) ⊆L(k + 1) for each k < ω. The class S
k L(k) coincides with
the Boolean closure BC(L) of L.
It is easy to check the following sufficient condition for the perfectness of the DH:
Proposition 3.2. Let L be a base in X such that X is join-irreducible in (L; ∪). Then the DH over L is perfect and hence has no
non-trivial refinements.
Now we formulate probably the most interesting characterization of the DH using Boolean terms, i.e. terms of the
signature {∪, ∩,¯, 0, 1}. It is not obvious who exactly should be credited personally for this characterization because several
people obtained close results independently (for additional information on this see [122]). Let T be the set of finite Boolean
terms with variables vk(k < ω). Relate to any t ∈T the set t(L) of all values of t when its variables range over L. We call
the sets t(L) levels of the Boolean hierarchy over L.
Theorem 3.3. The collections of levels of the difference and Boolean hierarchies over arbitrary base L coincide i.e. {t(L) | t ∈
T} = {L(n), co-L(n) | n < ω}.
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
129
The last result explains why many equivalent characterizations of the DH are possible. We mention the following three
well-known characterizations:
L(n) = tn(L), where t1 = v0, t2 = v0 \ v1, t3 = (v0 \ v1) ∪v2, t4 = (v0 \ v1) ∪(v2 \ v3), and so on (this characterization
is obtained in [38]);
L(n) = sn(L), where s1 = v0 and sn+1 = vn \ sn (this characterization is obtained in [83]);
L(n) = L + · · · + L (n summands) where A + B = {A△B | A ∈A, B ∈B} for any pointclasses A and B (this
characterization is obtained in [83]).
Of course, the DH over L may collapse (e.g., if L is a Boolean algebra then L = BC(L) and the DH over L collapses to
the first level). But many concrete DH’s do not collapse, and next we discuss a notion, variants of which are often used in
proving the non-collapse property, as well as other non-trivial facts on the DH. Namely, the DH’s are closely related to the
so called alternating chains. Since similar objects are useful also in dealing with other fine hierarchies, we illustrate them
for a rather general situation.
Relate to any poset P = (P; ≤) the base L in P consisting of all upper sets of P, including the empty set. Recall that a set
L ⊆P is called upper set if x ∈L and x ≤y imply y ∈L. By alternating chain of length k for a set K ⊆P we mean a sequence
(x0, . . . , xk) of elements of P such that x0 ≤· · · ≤xk and xi ∈K iff xi+1 ̸∈K, for each i < k. Such a chain is 1-alternating
chain if x0 ∈K, otherwise it is called a 0-alternating chain. The next easy fact is from [145].
Proposition 3.4. Let P = (P; ≤) be a partial order and L the base of upper sets in P. For all K ⊆P and k < ω, K ∈L(k) iff K
has no 1-alternating chains of length k.
Using this characterization it is easy to construct a base such that the corresponding DH does not collapse. Note that
only in rare cases the last proposition applies directly, often some ‘‘local’’ version should be found. E.g., already the proof of
Theorem 3.3 relies on some alternating chains related to the Boolean terms (see e.g. [122]).
In the particular case when (P; ≤) is a well poset it is also possible [145] to give a similar characterization of the class
BC(L) which is sometimes also of use. By ω-alternating chain for a set K ⊆P we mean an ω-sequence x0, x1, . . . of elements
of P such that x0 ≤x1 ≤· · · and xi ∈K iff xi+1 ̸∈K, for each i < ω.
Proposition 3.5. Let P = (P; ≤) be a well poset and L the base of upper sets in P. For all K ⊆P, K ∈BC(L) iff K does not have
ω-alternating chains.
Now we formulate two facts related to the structural properties introduced in Section 2.10. First, if the base L has the
reduction property then each level L(n), n < ω of the DH over L also has the reduction property. This fact is probably new
here, but it is checked in the same way as the known analogous facts in DST [92] and computability theory [119] which we
state in the corresponding sections below. The second fact from [122,145] characterizes the ambiguous levels of the DH over
bases with the separation property. It is useful in establishing the discreteness properties of the DH’s.
Proposition 3.6. Let L be a base with the separation property and k < ω. Then L(k+ 1)∩co-L(k+ 1) coincides with the class
of sets of the form (U ∩L) ∪(U ∩K), where U ∈L ∩co-L, L ∈L(k) and K ∈co-L(k).
We conclude this subsection by a short discussion of the transfinite versions of the DH’s. First we recall the well-known
definition of the Hausdorff difference operation. An ordinal α is called even (odd) if α = λ + n where λ is not a successor,
n < ω and n is even (resp., odd). For an ordinal α, let r(α) = 0 if α is even and r(α) = 1, otherwise.
Definition 3.7. (i) For any ordinal α, define the operation Dα sending sequences of sets {Aβ}β<α to sets by
Dα({Aβ}β<α) =
[
{Aβ \ ∪γ <βAγ | β < α, r(β) ̸= r(α)}.
(ii) For all ordinals α and classes of sets C, let Dα(C) be the class of all sets Dα({Aβ}β<α), where Aβ ∈C for all β < α.
Notice that if the class C above is closed under countable unions then the class Dα(C) coincides with the class of all sets
Dα({Aβ}β<α), where Aβ ∈C for all β < α and Aβ ⊆Aγ for β < γ < α.
Now, let L be a base in X closed under countable unions. Relate to any α < ω1 the class L(α) = {Dα({Aβ}β<α) | ∀β <
α(Aβ ∈L)} called the α-th level of the DH over L. It is easy to check that {L(α)} is indeed an ω1-hierarchy. We will discuss
some concrete versions of the transfinite DH in DST and computability theory in the corresponding sections below.
3.2. Long difference hierarchy
Here we mention a simple natural global refinement of an arbitrary ω-base L (recall that we are interested in natural
refinements of L). For each n < ω, we can of course form the DH {Ln(m)}m over Ln; this is a refinement of L in the (n+ 1)-
st level. We can also define a global refinement of L, namely the sequence {Ln(m)}n,m<ω which we call the long DH over
L (actually, in order to obtain a hierarchy in the sense of definition in Section 2.7, we have to renumerate the levels by
ordinals α < ω2 in the obvious way). This hierarchy has the length at most ω2 because, in case it does not collapse, we have:
Ln(m) ⊆Ln1(m1) iff n < n1 or n = n1 ∧m ≤m1, for all n, m, n1, m1 < ω, m, m1 > 0. We will see below that some
concrete versions of the long DH are useful.
130
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
Note that if L is an ω1-base all levels of which are σ-semilattices then one can in the obvious way define the transfinite
long DH over L. The length of this hierarchy is at most ω2
1.
Next we illustrate the method of alternating chains in the case of the long DH. This is mainly for methodical reasons, in
order to make preparations for similar technically more complicated notions for the finer hierarchies to be discussed later.
By ω-preorder we mean a structure P = (P; ≤0, ≤1, . . .) where ≤n are preorders on P such that x ≤n+1 y →x ≡n y, for
each n < ω. With any ω-preorder P we associate the ω-base L on P where for each n < ω the level Ln consists of the upper
sets in (P; ≤n). In Section 9 we will meet also a bounded version of the introduced notion. Namely, by 2-preorder we mean
a structure P = (P; ≤0, ≤1) with two preorders on P such that x ≤1 y →x ≡0 y. Proposition 3.5 is obviously extended to
the following:
Proposition 3.8. In notation of the last paragraph, for all n, m < ω the class Ln(m) coincides with the class of subsets of P that
have no 1-alternating chains in (P; ≤n) of length m.
Using the last assertion it is easy to construct an ω-base such that the corresponding long DH does not collapse.
In many concrete examples of the long DH below the DH over L0 will be discrete (or m-discrete for a suitable m-
reducibility). In contrast, the DH’s over Ln for n > 0 usually have natural refinements. We discuss some of them in the
next subsections.
3.3. Symmetric difference hierarchy
Here we discuss a fine hierarchy that is a bit less obvious to discover than the long DH. It was introduced in [120,122,
126] under the name ‘‘plus-hierarchy’’ and renamed in [174] to the ‘‘symmetric-difference hierarchy’’; we use the last name
in this paper.
Let L be an ω-base. By a result in Section 3.1, for all n, m < ω, m > 0, we have Ln(m) = Ln + · · · + Ln (m summands)
or, more compactly, Ln(m) = m · Ln. It is natural to ask what classes do we get if we add also the levels Ln for different n.
Let Alg denote the collection of classes obtained in this way. Let Seq be the set of finite non-empty strings σ = (n0, . . . , nk)
of natural numbers satisfying n0 ≥· · · ≥nk, and let < be the lexicographic order on Seq. For σ = (n0, . . . , nk) ∈Seq, let
Pσ = Ln0 +· · ·+ Lnk; we call the classes Pσ levels of the symmetric-difference hierarchy over L. In other words, the non-zero
levels of the symmetric-difference hierarchy are classes of the form Ln0(k0) + · · · Lnl(kl), for some n0 > · · · > nl and
k0, . . . , kl > 0. Let us state some easy properties of the defined objects from [126].
Proposition 3.9. (i) The structure (Seq; <) is well-ordered with the corresponding ordinal ωω.
(ii) {Pσ | σ ∈Seq} = Alg.
(iii) The symmetric-difference hierarchy is a refinement of the long difference hierarchy.
(iv) For all σ, τ ∈Seq, if σ < τ then Pσ ∪co-Pσ ⊆Pτ , i.e. the symmetric-difference hierarchy is a hierarchy of length ≤ωω.
Note that in case when the symmetric-difference hierarchy does not collapse we haveσ < τ iff Pσ ⊆Pτ , for allσ, τ ∈Seq.
We conclude this section by adapting the alternating chains to the context of symmetric-difference hierarchy. This is
mainly also for methodical reasons, as a particular case of a more general notion in the next section. Let P = (P; ≤0, ≤1, . . .)
be an ω-preorder and L the corresponding ω-base of the upper sets (see the previous section).
Definition 3.10. Define chains of type ((n0, k0), . . . , (nl, kl)), for all l < ω, n0 > · · · > nl and k0, . . . , kl > 0, by induction
on l as follows:
(i) Chain of type (n0, k0) is a sequence (x0, . . . , xk0) in P satisfying x0 ≤n0 · · · ≤n0 xk0. Atoms of such a chain are by
definition the components x0, . . . , xk0.
(ii) For l
>
0, chain of type ((n,k0), . . . , (nl, kl)) is by definition a sequence (X0, . . . , Xkl) of chains of type
((n0, k0), . . . , (nl−1, kl−1)) satisfying X0 ≤nl · · · ≤nl Xkl where Xi ≤nl Xj means that for some (equivalently, for all) atoms x
of Xi and y of Xj it holds x ≤nl y. Atoms of (X0, . . . , Xkl) are the atoms of the components.
Now we generalize the notion of 1-alternating chain from Section 3.1.
Definition 3.11. Let A ⊆
P, l < ω, n0 > · · · >
nl and k0, . . . , kl >
0. We define 1-alternating chains of type
((n0, k0), . . . , (nl, kl)) for A by induction on l as follows:
(i) 1-Alternating chain of type (n0, k0) for A is a chain (x0, . . . , xk0) in P such that x2i ∈A and x2i+1 ̸∈A.
(ii) For l > 0, 1-alternating chain of type ((n0, k0), . . . , (nl, kl)) for A is a chain (X0, . . . , Xkl) of type ((n0, k0), . . . , (nl, kl))
such that X2i are 1-alternating chains for A and X2i+1 are 1-alternating chains for A.
Remark. 1. Chains of type ((1, k0), (0, k1)) essentially coincide with the corresponding superchains introduced in [173],
see also Section 9.5.
The next result extends Propositions 3.4 and 3.8 to the context of the symmetric-difference hierarchy. This result itself
was not presented in the literature so far but it is a particular case of the corresponding known fact about the fine hierarchy
[125] (see the next subsection).
Proposition 3.12. Let P = (P; ≤0, ≤1, . . .) be an ω-preorder, L the corresponding ω-base of upper sets in P, l < ω,
n0 > · · · > nl and k0, . . . , kl > 0. Then the level Ln0(k0) + · · · Lnl(kl) of the symmetric-difference hierarchy over L coincides
with the class of subsets of P that have no 1-alternating chains of type ((n0, k0), . . . , (nl, kl)).
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
131
3.4. Fine hierarchy
Are there other natural refinements of a given ω-base L in X? The answer is positive, and in principle we could continue
the sequence long DH, symmetric-difference hierarchy, . . . indefinitely. Since any next element of this sequence would have
more and more involved definitions, we choose another possibility. Namely, in this subsection we introduce a refinement
which is in many cases the richest one, i.e. it refines all other reasonable (in a sense) refinements. We call this richest
refinement the fine hierarchy over L. It was first discovered by the author in the context of computability theory [112]
in terms of some jump operations (for more details see Section 6.4). After acquaintance with some set-theoretic operations
(like sep and bisep) identified by Wadge [171,91], the author [115,122] characterized the fine hierarchy in terms of (some
versions) of these operations and developed the abstract version of the fine hierarchy which we consider next. This has
shown that the fine hierarchy is in a sense the abstract finite version of the Wadge hierarchy (this point will be explained
below).
We need the following (rather exotic) operation Bisep [115,122] on pointclasses defined as follows: Bisep(A, B0, B1, B2)
is the class of sets
(A0 ∩B0) ∪(A1 ∩B1) ∪(A0 ∩A1 ∩B2)
where Ai ∈A for i ≤1, Bj ∈Bj for j ≤2, and A0 ∩A1 ∩B0 = A0 ∩A1 ∩B1. The operation Bisep is a version of the following
operation of W. Wadge [171,91]: bisep(A, B0, B1, B2) equals
{(A0 ∩B0) ∪(A1 ∩B1) ∪(A0 ∩A1 ∩B2) | Ai ∈A, Bj ∈Bj, A0 ∩A1 = ∅}.
Definition of the fine hierarchy below uses the ordinal ε0 = sup{ω, ωω, ωωω, . . .} from Section 2.3.
Definition 3.13. Let L be an ω-base in X. By the fine hierarchy over L we mean the sequence {Sα}α<ε0, where Sα = S0
α and
the classes Sn
α(n < ω) are defined by induction on α as follows:
Sn
0 = {∅};
Sn
ωγ = Sn+1
γ
for γ > 0;
Sn
β+1 = Bisep(Ln, Sn
β, co-Sn
β, Sn
0) for all β < ε0, and
Sn
β+ωγ = Bisep(Ln, Sn
β, co-Sn
β, Sn
ωγ ) for γ > 0 and β of the form β = ωγ · β1 > 0.
To see that this definition is correct recall that any non-zero ordinal α < ε0 is uniquely representable in the form
α = ωγ0 + · · · + ωγk for a finite non-empty sequence γ0 ≥· · · ≥γk of ordinals < α. Applying Definition 3.13 we
subsequently get Sn
ωγ0 , Sn
ωγ0+ωγ1 , . . . , Sn
α. The classes Sn
γ for n > 0 play only a technical role, they are all among the levels
Sα of the fine hierarchy.
Note that for the fine hierarchy over a 2-base (L0, L1) (see Section 2.10) we have Sα = BC(L1) for all α ≥ωω, hence
only the levels Sα, α < ωω, are interesting (we will meet this case in Section 9).
Let us formulate some properties of the fine hierarchy over arbitrary ω-base.
Proposition 3.14. (i) We have Sα ∪co-Sα ⊆Sβ for all α < β < ε0.
(ii) The fine hierarchy is a refinement of the symmetric-difference hierarchy. In particular, Ln = Sf (n) for all n < ω where
f : ω →ε0 is the monotone function defined by induction f (0) = 1 and f (n + 1) = ωf (n).
(iii) Let L and L′
n be ω-bases in X and X′ respectively and g : P(X) →P(X′) be a homomorphism of Boolean algebras
satisfying g(Ln) ⊆L′
n for all n < ω. Then g(Sα) ⊆S′
α for all α < ε0.
(i) If any level of L is closed under an F-m-reducibility on P(X) then so are also all levels of the fine hierarchy over L.
Remark. It is easy to find the explicit formula relating the symmetric-difference and fine hierarchies, (see the assertion
(ii) above). The formula is very clear for the long DH, namely Ln(m) = Sg(n,m) for all n < ω and m > 0, where
g : ω × ε0 →ε0 is defined by g(0, α) = α and g(n + 1, α) = ωg(n,α). For the symmetric-difference hierarchy we
have (in the notation of the previous section) Ln0(k0) + · · · Lnl(kl) = Sh((n0,k0),...,(nl,kl)) where h is defined by induction on l
as follows: h((n0, k0)) = g(n0, k0) and, for l > 0,
h((n0, k0), . . . , (nl, kl)) = g(nl, h((n0 −nl, k0), . . . , (nl−1 −nl, kl−1))) · (kl + 1).
Since the exact formula is a bit complicated, a more rough formula from [122] might be helpful:
{Ln0 + · · · + Lnk | k < ω, nk ≤· · · ≤n0 < ω} = {Sα | α ∈A}
where A is the subalgebra of algebra (ε0; λx.ωx, ·) generated by the set {1, 2, . . .}.
The last proposition and remark lead to some equivalent characterizations of the fine hierarchy. E.g., the levels Sα,
α < ωω, of the fine hierarchy over a 2-base (L0, L1) might be equivalently defined as follows:
An = Dn(L0) for n < ω;
Aωn = Dn(L1) for 0 < n < ω;
Aβ+ωn = Bisep(L0, Aβ, co-Aβ, Aωn) for 0 < n < ω and β of the form β = ωn · β1 for some β1, 0 < β1 < ωω;
Aβ+1 = Bisep(L0, Aβ, co-Aβ, A0) for ω ≤β < ωω.
Properties of the fine hierarchy strongly depend on the properties of the corresponding ω-base. First we consider the
interpolable ω-bases (see Section 2.10). It turns out that in this case the fine hierarchy is often the finest possible.
132
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
Theorem 3.15. Let L be an interpolable ω-base in X. Then the fine hierarchy over L is perfect in all limit levels, i.e. Sα ∩co-
Sα = S
β<α Sβ for all limit ordinals α < ε0. If, in addition, X is join-irreducible in (L0; ∪) then the fine hierarchy is perfect and,
consequently, has no non-trivial refinements.
Remark. The sequence {Sα} may be also obtained as union of all levels of a series of refinements starting with the ω-base
L, the first refinement (in each non-zero level) being the DH (over the previous level). By Proposition 3.2, the DH over L0 is
perfect. The next refinement is the symmetric-difference hierarchy, and so on. Under the assumptions of the last theorem,
we will obtain longer and longer perfect subsequences of {Sα}. In this way we finally obtain in a sense a full hierarchical
classification of the class S
n Ln (see also Section 6.4).
Next let us consider the reducible ω-bases. In this case it is possible to simplify definition of the fine hierarchy and to
characterize it by Boolean terms.
Proposition 3.16. Let L be a reducible ω-base in X.
(i) Levels of the fine hierarchy over L coincide with the corresponding classes obtained by using the simpler operation bisep in
place of Bisep.
(ii) All dual levels co-Sα, α < ε0, of the fine hierarchy over L have the separation property. In general, not all levels Sα have
the reduction property.
The fine hierarchy as defined above seems rather artificial. It turns out that the fine hierarchies over reducible ω-bases
have a very nice characterization similar to the characterization of the DH by Boolean terms. Let T ∗be the set of terms of
signature {∪, ∩,¯, 0, 1} with variables vn
k(k, n < ω); we call them typed Boolean terms. Relate to any t ∈T ∗the set t(L) of
values of t when the variables vn
k (k < ω) of type n range through Ln, for each n < ω. The next result is obtained in [122,
124].
Theorem 3.17. Let L be a reducible ω-base in X. Then {Sα, co-Sα | α < ε0} = {t(L) | t ∈T ∗} and there are algorithms that
compute from any ordinal α < ε0 the corresponding Boolean term t ∈T ∗and vice versa.
Now let us return to the general case and give a characterization of the fine hierarchy in terms of trees obtained in [115,
122,124] that resembles definition of the DH of k-partitions.
For any string τ ∈ω∗and any ω-base L, by τ-tree in L we mean a family {Aσ}σ∈2∗of sets such that Aσ = ∅for |σ| > |τ|,
Aσ k ∈Lτ(|σ|) for |σ| < |τ| and k < 2, and Aσ ⊇Aσ k. A tree is reduced, if Aσ0 ∩Aσ 1 = ∅for all σ . We say that a set A is defined
by a tree {Aσ} as above, if A ⊆A0 ∪A1, A ∩Aσ 0 ⊆Aσ 00 ∪Aσ 01 and A ∩Aσ1 ⊆Aσ 10 ∪Aσ11. This notion does not depend on
A∅; applying it we usually think that A∅= X (if not, just replace A∅by X).
Define strings τ n
α(n < ω) by induction on α as follows: τ n
0 = ∅, τ n
α+1 = nτ n
α, τ n
ωγ = τ n+1
γ
for γ > 0, and τ n
δ+ωγ = τ n
ωγ nτ n
δ
for δ = ωγ · δ′ > 0, γ > 0. Let τα = τ 0
α. Then we have the following characterization of the fine hierarchy:
Theorem 3.18. Let L be an ω-base and α < ε0. Then Sα coincides with the class of sets defined by τα-trees in L. If, in addition,
L is reducible then Sα coincides with the class of sets defined by the reduced τα-trees in L.
We conclude this subsection by extending Propositions 3.4 and 3.12 to the context of the fine hierarchy. The alternating
chains are now extended to the alternating trees as follows. Let P = (P; ≤0, ≤1, . . .) be an ω-preorder, A ⊆X and τ ∈ω∗.
By τ-aternating tree for A we mean a family {pσ | σ ∈2∗, |σ| ≤|τ|} of elements of P such that p∅̸∈A and pσ 0 ̸∈A, pσ 1 ∈A,
pσ ≤τ(|σ|) pσk for |σ| < |τ| and k < 2. Let τα be the string defined above. The next result from [125] characterizes the fine
hierarchy in terms of the alternating trees. The typed chains for the symmetric-difference hierarchy are easily seen to be
equivalent to the alternating trees for the corresponding levels of the fine hierarchy. It may be shown that among levels of
the fine hierarchy only the levels of the symmetric-difference hierarchy can be characterized by the alternating chains; for
all other chains do not suffice. The proof uses the previous theorem.
Theorem 3.19. Let P = (P; ≤0, ≤1, . . .) be an ω-preorder and L the corresponding ω-base of upper sets in P. Then the level Sα
of the fine hierarchy over L coincides with the class of subsets of P that do not have τα-alternating trees.
Again, several fine hierarchies over concrete ω-bases have characterizations of this kind. In particular, proof of
Theorem 3.17 uses similar invariants related to the typed Boolean terms.
3.5. Difference hierarchies of k-partitions
Here we extend the DH of sets to the DH of k-partitions introduced and studied for the case of finite k-posets in [75,
86,133] and for the countable case in [142]. Note that in the source papers the hierarchy is called Boolean hierarchy of
k-partitions.
Let P = (P; ≤) be a countable poset without infinite chains, X a set and L a σ-base in X. Functions of the form S : P →L
are called P-families and are denoted also by {Sp}p∈P. A P-family is monotone if it is a monotone function from (P; ≤) into
(L; ⊆). A P-family S is admissible if S
p Sp = X and Sp ∩Sq = S{Sr | r ≤p, q} for all p, q ∈P. Note that any admissible
P-family is monotone. Note also that if P is a forest then P-family S is admissible iff it is monotone, S
p Sp = X and Sp∩Sq = ∅
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
133
for all p, q incomparable in P. For any P-family S, define the map ˜S : P →P(X) by ˜Sp = Sp \ S
q<p Sq. It is easy to see that if
S is admissible then {˜Sp}p∈P is a partition of X.
For a countable k-poset (P, c) without infinite chains, let L(P, c) = {c ◦˜S | S ∈H(P, L)} where H(P, L) is the set of
admissible P-families and ˜S is identified with the function from X to P sending x ∈X to the unique p ∈P with x ∈˜Sp.
Note that L(P, c) ⊆kX, i.e. L(P, c) is a class of k-partitions of X. Difference hierarchy of k-partitions over L is by definition
the family {L(P)}P∈e
Pk; by BHk(L) we denote the collection {L(P) | P ∈e
Pk} of levels of this hierarchy. We consider also a
smaller collection of classes of k-partitions FBHk(L) = {L(P) | P ∈e
Fk} defined by the k-forests. If we take Pk and Fk in
place of e
Pk and e
Fk we obtain the finite versions of the DH’s. In the same way one can define the DH’s LBHk(L) over k-lattices
and CBHk(L) over k-chains (see Section 2.6).
In [75,142] it was observed that the DH of k-partitions is closely related to the h-preorder, namely for all countable k-
posets P and Q without infinite chains P ≤Q implies L(P) ⊆L(Q). For the reasons explained in Section 2.6 we are mostly
interested in the families {L(P) | P ∈Fk} and {L(P) | P ∈e
Fk} as definitions of the (finite and transfinite, respectively)
DH’s. In subsequent sections we will see that we really obtain interesting hierarchies in this way.
We conclude this subsection by a result from [133,142] showing that both DH’s of k-partitions over k-forests coincide
with those for k-posets, provided the base is reducible.
Theorem 3.20. (i) Over any reducible base L, {L(P) | P ∈Pk} = {L(F) | F ∈Fk}, and hence the structure ({L(P) | P ∈
Pk}; ⊆) is a well poset of rank ≤ω.
(ii) Over any σ -reducible base L closed under countable unions, {L(P) | P ∈e
Pk} = {L(F) | F ∈e
Fk}, and hence
({L(P) | P ∈e
Pk}; ⊆) is a well poset of rank ≤ω1.
(iii) For k = 2, the hierarchies in (i) and (ii) essentially coincide with the DH’s of sets over L.
It is easy to see that the hierarchies from the last theorem are Fk- and e
Fk-hierarchies in the sense of Section 2.8. In several
concrete examples below we will see that these hierarchies do not collapse.
3.6. Future work
The general program about the abstract hierarchies is to extend to them as many as possible results known about the
concrete hierarchies. E.g., we have mentioned only the easy inclusion result about the transfinite DH; it seems that, under
some reasonable additional assumptions on the base, it should be possible to prove some less trivial properties of the abstract
transfinite DH generalizing those from the next section.
We know that the fine hierarchy and the typed Boolean ‘‘hierarchy’’ {t(L) | t ∈T ∗} coincide over any reducible base. For
the non-reducible bases it was shown in [122] that the collections of levels of these hierarchies can be incomparable under
inclusion and that there can exist three pairwise incomparable levels of the typed Boolean ‘‘hierarchy’’. At the same time,
we have currently no answer to the following natural question: is the collection of levels of the typed Boolean ‘‘hierarchy’’
over arbitrary ω-base well-founded or even well partial ordered?
It seems interesting to develop an abstract transfinite version of the fine hierarchy (i.e., the transfinite fine hierarchy
over an arbitrary ω1-base with suitable properties). One could hope to develop a kind of the abstract Wadge hierarchy in
this way.
We know that the DH of k-partitions over k-forests has good properties over reducible bases. Over arbitrary base, this
hierarchy can be too restrictive. It seems interesting to know which properties of the non-reducible bases imply good
properties (like well-foundedness) of the corresponding DH’s of k-partitions over (reasonable classes of) k-posets.
4. Descriptive set theory
In this section, we discuss some fine hierarchies in DST. The basic facts on hierarchies of classical DST were obtained in
the beginning of the 20th century by E. Borel, H. Lebesgue, F. Hausdorff, N. Luzin, M. Suslin and many others. In this paper,
we concentrate on the Hausdorff DH and later results of W. Wadge, D. Martin and others related to the Wadge reducibility.
The standard reference on the classical DST is [72].
Along with the classical DST we discuss also some results of the so called domain DST, a topic that tries to develop a DST
for the domain-like structures which are of interest for computer science. In contrast with the well-developed classical DST,
domain DST is still in its beginning. Some impression about this theory may be obtained from [137]. Standard references in
domain theory are [6,53].
DST is important for theoretical computer science because several ‘‘more effective’’ hierarchies of computer science are
often defined and studied by analogy with the corresponding objects from DST. DST is fundamental for such fields as theory
of infinite behavior of computing devices (and hence it is relevant to the formal specification, verification and synthesis of
reactive systems) and computability and complexity in analysis [176], topology and domain theory.
134
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
4.1. Preliminaries
In this subsection we briefly recall some topological notions studied in the sequel. Classical DST concentrates on the so
called Polish spaces, but some important facts (e.g. about the structure of Wadge degrees) hold true only for spaces closely
related to the Baire and Cantor spaces. Recall that metric space is a pair (X, d) with X a set and d a function (called metric)
from X × X to the nonnegative reals such that: d(x, y) = 0 iff x = y, d(x, y) = d(y, x) and d(x, y) ≤d(x, z) + d(z, y). A
metric space is complete if any Cauchy sequence in X converges to a point in X.
Topological space (or simply space) is a pair (X, T ) with X a set and T a collection of subsets of X closed under arbitrary
unions and finite intersections. Such a collection is called topology on X and its elements open sets. A subset of X is closed
(clopen) if its complement is open (respectively, if it is both open and closed). As is well known, any metric on a set X induces
a topology on this set. When a metric (a topology) on X is clear from the context we do not mention it explicitly and refer
to X as a metric (respectively, a topological) space.
A space X is metrizable if there is a metric d on X such that every open set is a union of sets of the form {y ∈X | d(x, y) < r},
where x ∈X and r is a positive real. A space X is Polish if it is countably based and metrizable with a metric d such that (X, d)
is a complete metric space. The most important (for DST) examples of Polish spaces are the Baire and Cantor spaces and many
spaces of interest in analysis, including of course the space of reals. A function f : X →Y between spaces is continuous if
the preimage f −1(A) of every open set A in Y is an open set in X. A function f : X →Y is called homeomorphism if it is
bijective, continuous and the inverse function f −1 : Y →X is continuous. A subspace of a space (X, T ) is a subset A ⊆X
equipped with the topology {A ∩B | B ∈T }. Spaces X and Y are homeomorphic if there is a homeomorphism of X onto Y.
There are many interesting constructions on spaces of which we mention only the cartesian product X × Y and the space
Y X of continuous functions from X to Y with the topology of pointwise convergence. For definitions see any standard text
in topology, say [84].
It is well-known and easy to see that the function ⟨ξ, η⟩= ξ ⊕η, defined by (ξ ⊕η)(2n) = ξ(n) and (ξ ⊕η)(2n + 1) =
η(n), is a homeomorphism between ωω × ωω and ωω; this function plays in DST the role of the Cantor pairing function in
computability theory. For A, B ⊆ωω, let A ⊕B = {0 · ξ, i · η | 0 < i, ξ ∈A, η ∈B}. For a sequence A0, A1, . . . of subsets
of ωω, let L
i<ω Ai denote the set {i · ξ | i < ω, ξ ∈Ai}. These join operations are extended to the k-partitions of ωω in a
straightforward way, namely (µ ⊕ν)(0 · ξ) = ν(ξ) and (µ ⊕ν)(i · ξ) = ν(ξ) for all 0 < i < ω and ξ ∈ωω. For a sequence
ν0, ν1, . . . of k-partitions of ωω, define a k-partition ν = L
i<ω νi by ν(i · ξ) = νi(ξ), for all i < ω and ξ ∈ωω. Note that the
definition of the binary join operation µ ⊕ν applies also to the Cantor space but the ω-ary one does not.
Now we recall some notions of the domain theory. Let X be a T0-space, i.e. for any distinct points x, y ∈X there is an
open set containing exactly one of them. For x, y ∈X, let x ≤y denote that x ∈U implies y ∈U, for all open sets U. The
relation ≤is a partial order known as specialization order. Let F(X) be the set of finitary elements of X (known also as compact
elements), i.e. the elements p ∈X such that the upper cone {x | p ≤x} is open. Such open cones are called f -sets. The space
X is called ϕ-space if every open set is a union of f -sets. A ϕ-space X is called ϕ0-space if (X; ≤) contains a least element
(usually denoted ⊥). Note that any non-discrete ϕ-space is not Hausdorff. The term ‘‘ϕ-space’’ was coined in [42].
A ϕ-space X is complete if any non-empty directed set S without greatest element has a supremum supS ∈X, and supS
is a limit point of S (notice that supS ̸∈F(X) and for each finitary element p ≤supS there is an s ∈S with p ≤s). As is well
known, every ϕ-space is canonically embeddable in a complete ϕ-space which is called the completion of X (see e.g. [42,6,
53]). An ω-algebraic domain is a complete countably based ϕ0-space.
Next we define two classes of ω-algebraic domains introduced and studied in [135]. By reflective domain we mean an
ω-algebraic domain X such that for some continuous functions q0, e0, q1, e1 : X →X there hold q0e0 = q1e1 = idX, and
e0(X), e1(X) are disjoint open sets. Examples of reflective domains are the Baire and Cantor domains, the domain ωω
⊥of
partial functions g : ω ⇀ω (the finitary elements are the finite functions and the inclusion is the specialization order), and
many other natural (in particular, functional) domains [135].
In [135] also another class of domains was considered. By 2-reflective domain we mean an ω-algebraic domain X with a top
element ⊤such that there exist continuous functions q0, e0, q1, e1 : X →X and open sets B0, C0, B1, C1 with the following
properties: q0e0 = q1e1 = idX; B0 ⊇C0 and B1 ⊇C1; e0(X) = B0 \ C0 and e1(X) = B1 \ C1; B0 ∩B1 = C0 ∩C1. An example of
2-reflective domains is the domain Pω of subsets of ω (the finitary elements are the finite sets and the specialization order
is the inclusion relation).
We conclude this subsection by formulating the Martin determinacy theorem which is one of the main facts of DST,
playing an important role in proving facts about the Wadge reducibility in the Baire and Cantor spaces (we provide some
details only for the Baire space). It concerns a class of infinite games with full information introduced by D. Gale and F.M.
Stewart.
Relate to any set A ⊆ωω the game G(A) for two players denoted by 0 and 1, as follows. A play of such a game is a sequence
of numbers {ai} constructed in the following way: the player 0 chooses a0, then the player 1 chooses a1, then 0 chooses a2
and so on ad inifinitum; at each move every player knows the previous moves of his/her opponent. If the resulting function
λn.an belongs to A then player 1 wins the play, otherwise 0 wins the play. Notice that any sequence σ ∈ω∗may be thought
of as a possible position in the game G(A). If |σ| is even (odd) then the player 0 (1) must make his/her move a ∈ω to get
the next position σ ⌢a. Sometimes it is more convenient to describe the game G(A) in slightly different terms: we say that 0
plays a function ξ = λn.a2n, while 1 plays a function η = λn.a2n+1; then the resulting play of the game will be the function
ξ ⊕η.
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
135
Now let us define the notion of strategy for a player in a game. A strategy for player 0 (1) assumes that (s)he makes
his/her move at a position σ depending on this position. Hence, strategy is essentially a function from strings to numbers
which ‘‘prompts’’ the next move to a player. One may also equivalently think that the strategy depends not on the whole
position σ but only on the previous moves of the opponent. More formally, by a strategy for player 0 (1) we mean a function
f : ω∗→ω (respectively, a function f : ω+ →ω). Hence, if the player 0 (1) follows a strategy f and his/her opponent 1 (0)
plays a function {an} then the resulting play is f (∅), a0, f (a0), a1, f (a0, a1), . . . (respectively, a0, f (a0), a1, f (a0, a1), . . .). A
strategy for a player is winning if (s)he wins any play when following the strategy.
A set A ⊆ωω is determined if one of the players has a winning strategy in the game G(A). To understand which subsets of
the Baire space are determined turned out to be an interesting, important and hard problem. One of the most useful results
in this direction is the Martin determinacy theorem stating that any Borel subset of the Baire (or Cantor) space is determined.
This theorem is a main tool for proving results about the Wadge reducibility on the Borel sets.
4.2. Bases and reducibilities
Let us recall definition of the Borel hierarchy in arbitrary space X. This hierarchy will provide main bases for this section.
Definition 4.1. Define a sequence {60
α}α<ω1 of pointclasses in an arbitrary space X by induction on α as follows: 60
0 = {∅},
60
1 is the class of open sets, 60
2 is the class of countable unions of finite Boolean combinations of open sets, and 60
α(α > 2)
is the class of countable unions of sets in S
β<α 50
β, where 50
β = {A | A ∈60
β}.
The sequence {60
α}α<ω1 is called Borel hierarchy in X, the classes 60
α, 50
α and 10
α = 60
α ∩50
α are called levels of the Borel
hierarchy. If we want to stress the space X in which the levels are considered we can use a more complicated notation like
60
α(X). The class B = B(X) of Borel sets in X is the union of all levels of the Borel hierarchy, it coincides with the σ-algebra
generated by the open sets. It is well-known and easy to see that the Borel hierarchy is a hierarchy in the sense of our general
definition, i.e. 60
α ⊆10
β for all α, β with α < β < ω1. This hierarchy (more exactly, the sequence {60
1+α}α<ω1) and its initial
segment {60
n+1}n<ω known as the finite Borel hierarchy, are the main ω1-base and ω-base for this section.
A classical result of DST [72] states that the Borel hierarchy does not collapse in any non-countable Polish space. In [137]
it was shown that it also does not collapse in all reflective and 2-reflective domains. An important theorem of M. Suslin
(see [72]) states (in our terminology) that, in any Polish space, the Borel hierarchy is an exhaustive refinement of the so
called projective hierarchy {61
n} in the first level, i.e. S
α<ω1 60
α = B = 11
1. The projective hierarchy is one of the most
important objects of classical DST. We will not consider (and even define!) it here because many of its properties depend on
the set-theoretic assumptions and seem (at least so far) to be not very useful in computer science. Only the first level of the
projective hierarchy and some sets in its ‘‘neighborhood’’ appear from time to time in the literature on theoretical computer
science.
It is well-known [72] that any class 60
α, α > 1, has the σ -reduction property (in any space). For the class 60
1 of open sets
the situation is more subtle: it has the σ -reduction property for some natural spaces (e.g., for the Baire and Cantor spaces
[72] and for the Baire and Cantor domains [141]) while it does not have the reduction property for some other natural spaces
(e.g., for the space of reals).
As the notion of reducibility for this section, we take the Wadge reducibility ≤W , i.e. the m-reducibility by continuous
function (on any space X). Thus, continuous functions are taken as ‘‘feasible’’ in DST. Obviously, any level of the Borel
hierarchy is closed under the Wadge reducibility. The same applies to all hierarchies we will consider in this section. The
structure of Wadge degrees of subsets (and even of k-partitions) of the Baire space is an upper semilattice w.r.t. the operation
⊕from Section 6.1. The fact that the definition of binary join operation µ ⊕ν applies also to the Cantor space but the ω-ary
one does not implies some minor distinctions in the structures of Wadge degrees in the Baire and Cantor spaces.
For the Baire and Cantor spaces, it is well-known [72] that the Wadge reducibility fits the Borel hierarchy. Moreover, any
level of the Borel hierarchy is a classical pointclass. We define the last notion for the Baire space, for the Cantor space it may be
defined similarly. Classical pointclass in ωω is a pointclass C closed under ≤W and such that there is a surjection ν : ωω →C
and a continuous function f on ωω with the following properties: the so called universal set Uν = {⟨ξ, η⟩| η ∈νξ} of ν is in
C and νξ(⟨η, ζ⟩) = νf ⟨ξ,η⟩(ζ) for all ξ, η, ζ ∈ωω. The last condition is an analog of the smn-theorem in computability theory.
It is easy to show that such a surjection ν (called acceptable coding of C) is unique, up to the Wadge equivalence. Moreover, it
is easy to show by diagonalization that any classical pointclass is non-self-dual. The notion of a classical pointclass extends
to classes of k-partitions in a straightforward way.
When considering hierarchies in the Baire and Cantor spaces, we will assume that they fit the Wadge reducibility;
moreover, all hierarchies we consider will have the stronger property that all their non-self-dual levels are classical
pointclasses. Thus, for the Baire and Cantor spaces it seems reasonable to include the last property in the definition of
hierarchy.
4.3. Difference hierarchies
Recall from Section 3.1 that, for all α, β < ω1, β > 0, the α-th level of the DH over 60
β in a given space X is denoted by
60
β(α). The difference hierarchy over 60
1 is sometimes simply called the difference hierarchy in X and denoted by {6−1
α }α<ω1.
136
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
The notation with the upper index −1 was coined by Yu.L. Ershov, the index has probably to stress that the DH is a refinement
of the Borel hierarchy. As usual, 5−1
α
denotes the dual class for 6−1
α , and 1−1
α
= 6−1
α ∩5−1
α .
It is well-known and easy to see that the DH over any level 60
β, β > 0, in any space is a hierarchy that refines the Borel
hierarchy in the level β + 1. It does not collapse in all non-countable Polish spaces [72], and also in all reflective and 2-
reflective domains [137]. In the Baire and Cantor spaces, the DH over any 60
β fits the Wadge reducibility, and the DH over
open sets has Wadge complete sets in any non-zero 1-level (hence, it is W-discrete, see Section 2.9). The next result in [134]
shows the even stronger discreteness property of the DH in domains.
Theorem 4.2. Let X be an ω-algebraic domain. Then the DH over open sets in X is perfect, i.e. S{6−1
β ∪5−1
β
| β < α} = 1−1
α
for all α < ω1. Hence, it is discrete.
Note that for β > 1 the DH over 60
β is usually not discrete. In [92] it was shown that any level 60
β(α) of the DH in the
Baire or Cantor space has the reduction property.
One of the most important facts about the DH is the following Hausdorff–Kuratowski theorem (see [72]):
Theorem 4.3. In any Polish space, the DH over any 60
β, β > 0, is an exhausting refinement of the Borel hierarchy in the next
level, i.e. S
α<ω1 60
β(α) = 10
β+1 for all β, 0 < β < ω1.
In the domain DST, the analog of the last theorem is currently known [134] (see also a particular case in [161]) only for
the DH over open sets: in any ω-algebraic domain, S
α<ω1 6−1
α
= 10
2. In [134] the following characterization of the last DH
in terms of an analog of alternating chains (see Section 3.1) was obtained. The characterization is useful, in particular, for
proving the results about the DH over open sets in domains mentioned above. We call a subset A of an ω-algebraic domain
X approximable if for any x ∈A there is a finitary element p ≤x with {y ∈X | p ≤y ≤x} ⊆A. By alternating tree for A
we mean a monotone function f : (T; ⊑) →(F(X); ≤) from a tree T ⊆ω∗without infinite chains to the finitary elements
such that f (σ) ∈A iff f (σ ⌢n) ̸∈A, for each σ ⌢n ∈T. The rank of f is the rank of the tree T. An alternating tree f is called
1-alternating if f (∅) ∈A.
Theorem 4.4. Let X be an ω-algebraic domain, α < ω1, T a tree of rank α and A ⊆X. Then the following assertions are
equivalent:
(i) A ∈6−1
α ;
(ii) both sets A, A are approximable and there is no 1-alternating tree f : T →F(X) for A;
(iii) both sets A, A are approximable and there is no 1-alternating tree for A of rank α.
We conclude this subsection by a discussion of relationship of the Wadge reducibility to the DH in the Baire space
established in Section C of Chapter I of [171]. It shows that the first ω1 non-selfdual sets in the preorder (B(ωω); ≤W) (in the
next subsection we will see that the last structure is almost well-ordered) correspond precisely to the levels of the difference
hierarchy in the following sense.
Theorem 4.5. (i) For each α < ω1 there exists a set Aα ⊆ωω Wadge complete in 6−1
α , i.e. 6−1
α
= {B | B ≤W Aα}. Moreover, the
set Aα ⊕Aα is Wadge complete in 1−1
α+1 and, for a limit ordinal α, the set L
β<α Aβ is Wadge complete in 1−1
α .
(ii) For any B ⊆ωω, B ∈10
2 iff B has a countable rank in (B(ωω); ≤W) iff B is Wadge complete in one of levels 6−1
α , 5−1
α , 1−1
α ,
α < ω1.
The last result shows that the DH over open sets in the Baire (and also in the Cantor) space perfectly fits the Wadge
reducibility (see Section 2.9), and that the initial segment of the preorder (B; ≤W) formed by the elements of countable
rank provides an alternative characterization of the DH in the Baire space.
The next result from [135] shows that the structure of Wadge 10
2-degrees in the Baire domain ω≤ω looks very similar,
one has only to delete all the self-dual degrees. In particular, the DH over open sets in the Baire and Cantor domains also
perfectly fits the Wadge reducibility.
Theorem 4.6. In the Baire and Cantor domains, the difference hierarchy perfectly fits the Wadge reducibility. In particular, the
order type of the quotient structure (10
2(ω≤ω); ≤W) is ¯2 × ω1 (see Section 2.9).
4.4. Wadge hierarchy and fine hierarchy
Here we discuss the Wadge reducibility in the Baire space (with minor differences, similar results hold also for the Cantor
space).
In [170,171] Wadge (with a heavy use of the Martin determinacy theorem) proved the following deep result:
Theorem 4.7. The structure (B; ≤W) of the Borel sets in the Baire space is almost well-ordered (i.e., it is well-founded and for all
A, B ∈B we have A ≤W B or B ≤W A.
He has also computed the corresponding (large) ordinal ν. In [169,152] the following deep relation of the Wadge
reducibility to the separation property from Section 2.10 was established:
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
137
Theorem 4.8. For any Borel set A which is non-self-dual (i.e., A ̸≤W A) exactly one of the principal ideals {X | X ≤W A},
{X | X ≤W A} has the separation property. The result does not generalize to the reduction property.
The last two theorems give rise to the Wadge hierarchy which is, by definition, the sequence {6α}α<ν of all non-self-dual
principal ideals of (B; ≤W) that do not have the separation property and satisfy for all α < β < ν the strict inclusion
6α ⊂1β. As usual, we set 5α = {A | A ∈6α} and 1α = 6α ∩5α. Note that the constituents of the Wadge hierarchy are
exactly the equivalence classes induced by ≤W on Borel subsets of the Baire space. Thus, the Wadge hierarchy perfectly fits
the Wadge reducibility and is W-discrete (see Section 2.9). Furthermore, any non-self-dual level of the Wadge hierarchy is
a classical pointclass [169].
By the results at the end of the previous section, 6α = 6−1
α
for each α < ω, i.e. the DH over open sets is an initial
segment of the Wadge hierarchy. In order to see how much finer is the Wadge hierarchy compared with the Borel hierarchy,
we mention the equalities from [171] relating both hierarchies: 61 = 60
1, 6ω1 = 60
2, 6ωω1
1
= 60
3 and so on. Thus, sets of the
finite Borel rank coincide with the sets of Wadge rank less than λ = sup{ω1, ωω1
1 , ω
(ωω1
1 )
1
, . . .}. Note that λ is the smallest
solution of the ordinal equation ω~
1 = ~. Hence, we warn the reader not to mistake 6α with 60
α. To give the reader a first
impression about the Wadge ordinal we note that the rank of the preorder (10
ω; ≤W) is the ω1-st solution of the ordinal
equation ω~
1 = ~ [171].
As we know from Section 3, there is a close relationship of the DH to finite Boolean terms and of the fine hierarchy to
finite typed Boolean terms. Is there a similar relationship of the hierarchies considered in this section to, say, infinite Boolean
terms? In [171] (see also [91]) it is shown that in this way we obtain exactly the Wadge hierarchy (the theorem below is
actually a slight reformulation of this result, see [122] for details).
Define ω1-terms by induction as follows: constants 0, 1 and variables vk (k < ω) are ω1-terms; if ti (i < ω) are ω1-terms,
then so are the expressions ¯t0, t0 ∪t1, t0 ∩t1, S
i<ω ti and T
i<ω ti. The notion of typed ω1-term is defined in the same way but
as variables we take now the typed variables vα
k (k < ω), for each type α < ω1. Denote by T1 (by T ∗
1 ) the set of all (typed)
ω1-terms. For t ∈T1, let t(60
1) be the set of all values of t when the variables range over 60
1. For t ∈T ∗
1 and the ω1-base
L = {60
1+α}α<ω1, let t(L) be the set of all values of t when the variables of type α range over 60
1+α, for each α < ω1.
Theorem 4.9 ([171]). For any C ⊆P(ωω), the following conditions are equivalent:
(i) C = {B | B ≤W A} for some non-self-dual Borel set A;
(ii) C = t(60
1) for some t ∈T1;
(iii) C = t(L) for some t ∈T ∗
1 .
Let now {Sα}α<ε0 be the fine hierarchy over the reducible ω-base {60
n+1}n<ω (see Section 3.4). Comparing Theorems 3.17
and 4.9 and taking into account Proposition 3.16 we see that this fine hierarchy may be considered as the finite version of
the Wadge hierarchy. From Theorem 4.9 it follows that {Sα}α<ε0 is a subsequence of the Wadge hierarchy. It is not hard to
show that Sα = 6f (α) for each α < ε0 where f : ε0 →ν is a monotone function defined by induction as follows: f (0) = 0
and
f (ωα1 · k1 + ωα2 · k2 + · · · ) = ω
f (α1)
1
· k1 + ω
f (α2)
1
· k2 + . . . ,
for any non-empty sequence α1 > α2 > · · · of ordinals < ε0, and for all ki < ω (recall that any non-zero ordinal α < ε0 is
uniquely representable in the form α = ωα1 · k1 + ωα2 · k2 + . . .).
In [134,137] the reader could find some additional information on applications of the hierarchies discussed in this section
in theoretical computer science, and also on relationships between hierarchies in the domain DST to those in the classical
DST, via the ω1-terms.
4.5. Hierarchies of k-partitions
Here we consider some hierarchies of the 10
2-measurable k-partitions in the Baire space and domain (with small
modifications similar facts hold also for the Cantor space and domain). Sometimes we mention also other spaces.
It is well-known that the difference hierarchy is closely related to limiting ‘‘computations’’ [72]. In [35,113,114] this
relationship was used to extend the Ershov hierarchy of subsets of ω to the case of functions on ω, which applies in particular
to the k-partitions of ω (see Section 6.3). In the manuscript [119] (available to several computability theorists) this was
extended to functions from the Baire space to ω, hence also to the k-partitions of the Baire space (see also [131,57]). Here
we follow a more general approach of [57].
In the next proposition, it is technically convenient to consider not only (total) k-partitions, as we were doing before, but
also partial k-partitions f : X ⇀k or, more generally, partial functions f : X ⇀Y; we always assume that the domains of
such partial functions are open sets.
Definition 4.10. Let X, Y be spaces and α an ordinal. A partial function f : X ⇀Y is called α-continuous, if there is a
sequence {fβ}β<α of continuous partial functions from X to Y such that dom(f ) = S
β<α dom(fβ) and f (x) = fβ(x) for each
x ∈dom(f ), where β is the least ordinal satisfying x ∈dom(fβ).
138
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
For a partial function f : X ⇀Y and an element y ∈Y, let f y : X →Y denote the y-totalization of f defined by
f y(x) = f (x) for x ∈dom(f ) and f y(x) = y otherwise. For k ≥2, i < k and α < ω1, let Ci
k,α be the set of i-totalizations of
α-continuous partial functions from X to k, and Ck,α be the set of α-continuous total functions from X to k.
Similar to the corresponding facts in [114,119,131], it is easy to show that for any space X and any ordinal α we have
6−1
α
= C0
2,α, 5−1
α
= C1
2,α and 1−1
α
= C2,α. This shows that the sequence {Ci
k,α}α, which we call here the limit-hierarchy
of k-partitions, generalizes the difference hierarchy. The next assertion from [61,62,143] shows that main properties of the
DH in Section 4.3 are lifted to the limit-hierarchy in a natural way. In particular, it is a ¯k × ω1-hierarchy in the sense of
Section 2.8.
Proposition 4.11. Let X be a Polish space, k ≥2 and i < k.
(i) If α < β < ω1 then Ck,α ⊆Ci
k,α ⊆Ck,β.
(ii) S
α<ω1 Ck,α = (10
2)k.
(iii) If X is non-countable then Ci
k,α ̸⊆C
j
k,α for all α < ω1 and j < k, j ̸= i.
In [70,61,62,57,58] the authors consider a very relevant level-hierarchy that turns out to be related to the analysis of
discontinuity problems in computational geometry.
Now let us consider the DH of k-partition over the σ -reducible base of open sets in the Baire space FBHk(L) = {L(P) |
P ∈e
Fk} defined by the k-forests (see Section 2.8). For i < k and α < ω1, define a k-tree T i
α by induction on α as follows:
T i
0 = i, T i
α+1 = pi(T 0
α ⊔· · · ⊔T k−1
α
), and T i
α = pi(F
β<α T 0
β) for a limit ordinal α. It is easy to show that for any Polish
space X i < k and α < ω1 we have 60
1(T i
α) = Ci
k,α and S{60
1(F) | F ∈e
Fk} = (10
2)k. Thus, the DH is a refinement of the
limit-hierarchy.
In [133,143] the following extension of Proposition 4.5(i) was established.
Theorem 4.12. Let F ∈e
Fk, F ̸= ∅, and 60
1 = 60
1(ωω). Then the class 60
1(F) has a Wadge complete k-partition. Moreover, the
DH of k-partitions in the Baire space does not collapse.
A similar fact for the reflective domains (but for the e
Tk-hierarchy of k-partitions in place of the e
Fk-hierarchy above!) was
established in [141]:
Theorem 4.13. In any reflective domain X, the DH of k-partitions does not collapse, i.e., for all S, T ∈e
Tk, 60
1(S) ⊆60
1(T) iff
S ≤T. Moreover, any level of the DH has a Wadge complete k-partition.
In particular, the last result applies to the Baire and Cantor domains.
4.6. Wadge degrees of k-partitions
Here we consider the Wadge reducibility of k-partitions for the Baire and Cantor spaces and domains. To our knowledge,
the first result about the Wadge reducibility of k-partitions of the Baire and Cantor spaces is Theorem 3.2 in [37]. The
following assertion is a particular case of that deep result.
Theorem 4.14. Let X ∈{ωω, 2ω}. Then the structure (B(X)k; ≤W) of Borel-measurable k-partitions is a well preorder.
This assertion gives important information about(B(X)k; ≤W) but it says nothing about the structure of the well preorder.
Let us introduce some algebraic structure on this preorder. For a k-partition ν of ωω and i < k, define a k-partition pi(ν) of
ωω as follows: [pi(ν)](ξ) = i, if ξ ̸∈0∗1ωω, and [pi(ν)](ξ) = ν(η), if ξ = 0n1η (here we use the self-evident notation in
the style of regular expressions in automata theory). Note that the definition of pi applies also to the Cantor space. The next
fact was established in [133,137].
Theorem 4.15. (i) The quotient-structures of the structures (kωω; ≤W, ⊕, p0, . . . , pk−1) and ((10
2)k; ≤W, ⊕, p0, . . . , pk−1) in
the Baire space are dcσ -semilattices, and in the Cantor space they are dc-semilattices.
(ii) The quotient structure of ((BC(60
1))k; ≤W, ⊕, p0, . . . , pk−1) in the Baire and Cantor spaces is a dc-semilattice.
Similar facts (but for a bit different algebraic notions from Section 2.5) were established in [135] for some classes of
domains:
Theorem 4.16. (i) Let X be a reflective domain and Pi = {ν ∈kX | ν(⊥) = i} for any i < k. Then (kX; ≤W, P0 . . . , Pk−1) is a
σ-dws.
(ii) Let X be a 2-reflective domain. Then the structure (kX; ≤W, {P
j
i }i,j<k) where P
j
i = {ν ∈kX | ν(⊥) = i ∧f (⊤) = j} for
all i, j < k, is a 2-dws.
As an immediate corollary of Theorems 4.16, 2.5 and Proposition 2.6 we obtain
Theorem 4.17. Let X be a reflective or a 2-reflective domain, k ≥
3 and C be one of the classes P(X), B, BC(60
1), 60
n,
50
n, BC(60
n), 10
n+1 in X, where n > 1. Then FO(Ck; ≤W) is hereditary undecidable.
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
139
Now we turn to characterizing some ideals of the Wadge preorder in the Baire space and domain (with small
modifications similar facts hold also for the Cantor space and domain). P. Hertling (see Satz 6.2 b) in [60] and Theorem
2.2.4 in [61]) characterized the structure of the Wadge degrees of partial BC(60
1)-measurable k-partitions defined in the
obvious way. The Wadge reducibility of such partitions is just the reducibility by continuous partial functions. From the
proof in [60,61] and from [133] we obtain the following:
Theorem 4.18. Let X ∈{ωω, 2ω}. Then the quotient structure of ((BC(60
1))k; ≤W, ⊕, p0, . . . , pk−1) is isomorphic to that of
(Fk \ {∅}; ≤, ⊔, p0, . . . , pk−1).
In [143] this was generalized to the case of 10
2-measurable k-partitions. We formulate the corresponding fact only for
the Baire space:
Theorem 4.19. The quotient structure of the dcσ-semilattice ((10
2(ωω))k; ≤W, ⊕, p0, . . . , pk−1) is isomorphic to the quotient
structure of ( e
Fk \ {∅}; ≤, ⊔, p0, . . . , pk−1).
The next result from [60,141] characterizes the 10
2-measurable k-partitions ν in terms of their ranks rk(ν) in the well
preorder ((B(ωω))k; ≤W).
Theorem 4.20. Let ν be a Borel measurable k-partition of the Baire space.
(i) ν is 10
2-measurable iff rk(ν) < ω1.
(ii) ν is BC(60
1)-measurable iff rk(ν) < ω.
Theorems 4.18–4.20, 4.12 and 4.13 provide the full extension of the theory of DH over the open sets in the Baire and
Cantor spaces to the DH of k-partitions.
The DH of k-partitions in the Baire and Cantor domains is also characterized completely by the following result from
[141].
Theorem 4.21. Let X be the Baire or a Cantor domain. Then the quotient structure of((10
2(X))k; ≤W) is isomorphic to the quotient
structure of (e
Tk; ≤) while the quotient structure of ((BC(60
1(X)))k; ≤W) is isomorphic to that of (Tk; ≤).
The next result follows from Theorems 4.19, 4.18, 4.21 and Proposition 2.11.
Corollary 4.22. For the Baire and Cantor spaces and domains there hold:
(i) Aut(BC(60
1); ≤W) ≃Sω
2 and Aut(10
2; ≤W) ≃Sω1
2 .
(ii) For any k ≥3, Aut((BC(60
1)k; ≤) ≃Sk ≃Aut((10
2)k; ≤).
The next result follows from Theorems 4.19, 4.18, 4.21 and Proposition 2.12.
Corollary 4.23. For the Baire and Cantor spaces and domains there hold:
(i) For any k ≥3, the theory FO((BC(60
1))k; ≤W) is undecidable and, moreover, it is computably isomorphic to the first-order
arithmetic FO(ω; +, ·).
(ii) For any k ≥3, FO((10
2)k; ≤W) is undecidable and, moreover, the theory FO(ω; +, ·) is m-reducible to FO((10
2)k; ≤W).
4.7. Future work
By Section 4.3, the status of the Hausdorff–Kuratowski theorem for domains (even for the Baire and Cantor domains) is
unclear, i.e. it is not known whether the DH over 60
α for α > 1 exhausts 10
α+1.
In the last two subsections we completely characterized the structure of 10
2-measurable k-partitions in the Baire and
Cantor spaces and domains. Outside 10
2-measurable k-partitions nothing seems to be known for k > 2. At the same time,
in the case of sets k = 2 the structure of the Wadge degrees in the Baire space is characterized completely [171]. It seems
interesting to extend all results from [171] to arbitrary k. The main obstacle here is that all the main facts in [171] are proved
using the Martin determinacy theorem, and it is not clear (at least to the author) how to use the game-theoretic approach
for k > 2. Hence, it may turn out that we have to develop a completely different technique (e.g., one could try to generalize
methods used in [60,61,141,143] for the 10
2-measurable k-partitions).
Another interesting direction is to prove as many as possible results of this section in more abstract form (ideally, for the
general context of Section 3). For some results (e.g. for the result from [92] about the reduction property of the DH’s) this
does not seem impossible.
140
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
5. Logic
In this section we briefly discuss fine hierarchies in the context of first-order logic. This field is important for the hierarchy
theory because many concrete versions of the fine hierarchies are variants (obtained e.g. by restricting the class of structures
under consideration) of the quantifier-alternations hierarchy of formulas and its refinements.
Investigation of the first-order logical hierarchies was initiated by Addison [2–5] as a part of his program to develop
a general ‘‘hierarchy theory’’ unifying the study of hierarchies in DST, computability theory and logic. An essential early
contribution to this field is [78]. Later contributions are [171,90,117].
We would like to stress that we confine our consideration here to the hierarchies of sentences of the first-order logic.
There are also many relevant papers dealing with similar hierarchies in the infinitary logic (most notably, in Lω1,ω, see e.g.
[72,168]); this work is closely related to classical DST and model theory of infinitary logic but apparently not to theoretical
computer science. In contrast, the hierarchies in first order logic are closely related e.g. to automata theory and complexity
theory, as we will see later.
5.1. Bases
We assume the reader to be familiar with the basic notions of first-order logic which may be found in any of the
numerous textbooks on the subject. For simplicity, we restrict our attention to finite relational signatures σ (i.e., finite
signatures without functional and constant symbols). With any first-order theory T of signature σ we associate the ω-base
Lσ(T) = {Σ0
k+1(T)}k<ω in the Lindenbaum algebra Bσ(T) of σ-sentences modulo T (see Section 2.1), where Σ0
k+1(T) is the
set of (equivalence classes of) sentences of σ equivalent in the theory T to a Σ0
k+1-sentence. (Recall that we can, using the
Stone representation theorem, apply the notions from Section 2 also to subsets of Boolean algebras.) For the empty theory
T we denote the ω-base Lσ(T) just by Lσ . Note that the restriction to sentences is not essential: we could similarly consider
the case of formulas with a fixed finite list of free variables.
Properties of the ω-base Lσ(T) depend of course on the theory T, e.g. it may collapse. As is well-known, the ω-base Lσ
does not collapse iff σ contains at least one non-unary predicate symbol. From a version of the Craig interpolation theorem
we obtain the following result (see [78,146,117]).
Theorem 5.1. Let T be axiomatizable by Π 0
2 -sentences. Then the ω-base Lσ(T) is interpolable. If, in addition, T has a model
embeddable in any model of T, then the largest element is join-irreducible in (Lσ
0 (T); ∪).
In [78] it was shown that for most signatures none of the levels Lσ
n , co-Lσ
n , n < ω, of the ω-base Lσ has the reduction
property.
5.2. Difference hierarchies
Here we discuss the DH’s {Σ0
n(m)}m over levels of the ω-base Lσ(T). From the general facts in Section 3.1 we obtain the
usual inclusion relations between levels of the DH’s. The main fact of this section is a characterization [118] of the DH’s in
terms of alternating chains, in the spirit of Proposition 3.5.
For a σ-structure A, let σA denote the signature consisting of all σ -symbols and new constant symbols ca, for each a ∈A.
If A is a substructure of B (A ⊆B), then let BA denote the σA-structure that coincides with B on σ and interprets ca as a. For
any n < ω, let A ⊆n B denote that any ∆0
n+1-sentence (i.e., a sentence equivalent simultaneously to a Σ0
n+1-sentence and
to a Π 0
n+1-sentence) of signature σA has the same value in AA and BA.
Theorem 5.2. Let T be a theory and n, m > 0. Then Σ0
n(m) coincides with the set of sentences φ of σ such that there is no
sequence A0 ⊆n · · · ⊆n Am of T-models with φ |= A2i and φ ̸|= A2i+1.
This generalizes the following fact on the DH over Σ0
1(T) from in [5]: Σ0
1(m) coincides with the set of sentences φ such
that there is no sequence A0 ⊆· · · ⊆Am of T-models with φ |= A2i and φ ̸|= A2i+1.
Using the theorem above and the technique of Ehrenfeuch–Fraisse games it may be shown that the long DH over Lσ does
not collapse, provided that σ contains a non-unary predicate symbol.
5.3. Fine hierarchy
Here we briefly discuss the fine hierarchy {Sα(T)}α<ε0 over the ω-base Lσ(T) which we call the fine hierarchy of sentences
modulo T. For T = ∅we denote the levels of fine hierarchy just by Sα.
From Theorem 5.1 and results in Section 3.4 we immediately obtain
Theorem 5.3 ([118]). Let T be axiomatizable by Π 0
2 -sentences. Then the fine hierarchy of sentences modulo T is perfect in all
limit levels. If, in addition, T has a model embeddable in any model of T, then the fine hierarchy of sentences over T is perfect.
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
141
The next result from [118] gives a model-theoretic characterization of the classes Sα(T) in the spirit of the alternating
trees in Section 3.4. Let τ ∈ω∗and φ be a sentence of signature σ . By a τ-alternating tree for φ in T we mean a family
{Aρ | ρ ∈2∗, |ρ| ≤|τ|} of T-models such that Aρ ⊆τ(|ρ|) Aρk for all |ρ| < |τ| and k < 2, φ is true in A∅, Aρ0, and φ is false
in Aρ1 for |ρ| < |τ|. Let τα be the string defined before Theorem 3.19.
Theorem 5.4. For any theory T and any α < ε0, the set Sα(T) coincides with the set of sentences of signature σ that do not have
τα-alternating trees in T.
5.4. Relation to classical DST
There is a well-known relation of logic to topology [72] given by the map sending a first order sentence φ of a finite
relational signature σ to the class Mφ of all countable models of φ. Via a natural coding, the class of all countable σ-structures
is identified with the Cantor space. Thus, we obtain a mapφ 7→Mφ from the Lindenbaum algebra Bσ ofσ-sentences to P(2ω).
In [171], it was conjectured that the rank of the preorder ({Mφ | φ ∈Bσ}; ≤W) is ε0, under suitable assumptions about σ .
Here we sketch the positive answer announced in [127].
It is easy to see that, for any theory T of signature σ and any n > 0, φ ∈Σ0
n(T) implies Mφ ∈60
n. By Proposition 3.14(iii),
φ ∈Sα(T) implies Mφ ∈Sα where {Sα}α<ε0 is the fine hierarchy over the ω-base {60
n+1} in 2ω from Section 4.4. From results
of the previous subsection and from [90] it follows that in fact φ ∈Sα is equivalent to Mφ ∈Sα, for each α < ε0. Thus, by
Theorem 5.3, the rank of ({Mφ | φ ∈Bσ}; ≤W) is at most ε0. Using Ehrenfeucht–Fraisse games, it is possible to find a finitely
axiomatizable theory T such that the fine hierarchy {Sα(T)}α<ε0 does not collapse. By standard coding technique it is then
not hard to show that if σ contains a non-unary predicate then the fine hierarchy of σ-sentences has rank at least ε0. Thus,
for such signatures the rank of ({Mφ | φ ∈Bσ}; ≤W) is ε0 and the conjecture is true.
5.5. Future work
There are several natural open questions related to this section. E.g., it would be interesting to have examples of natural
theories T such that the ω-base Lσ(T) does not collapse and for any n at least one of the classes Lσ(T), co-Lσ(T) has the
reduction property. We do not currently know a notion of m-reducibility that fits the hierarchies considered in this section.
We would like also to see some results on the typed Boolean ‘‘hierarchy’’ and on the hierarchies of k-partitions in the
context of logic.
6. Computability theory
In this section we discuss fine hierarchies and reducibilities in computability theory. These hierarchies and reducibilities
are important because they provide efficient tools for classifying degrees of undecidability of many interesting decision
problems in logic and theoretical computer science. This branch is interesting also for historical reasons because the different
notions of reducibility appeared first in this context. Finally, computability theory provides a bridge between the topological
approach of DST and combinatorial approaches used e.g. in complexity theory and automata theory. The first contributors
to this field were S. Kleene, A. Mostowski and E. Post in the 1940-s who initiated the investigation of hierarchies and
reducibilities in computability theory. In particular, a close relationship of hierarchies in computability theory to those in DST
was observed; this was the first evidence that such a subject as hierarchy theory might really exist. The difference hierarchy
in the context of computability theory was developed by Yu.L. Ershov in the 1960-s (some related facts were obtained by
H. Putnam). The fine hierarchy was discovered by the author in [112] also in the context of computability theory and later,
after acquaintance with the Wadge hierarchy, was developed in the abstract setting [115,122,124].
6.1. Preliminaries
We assume that the reader is familiar with the main notions of computability theory and simply recall some notation
and not broadly known definitions. For more details the reader may use any of the many available books on the subject, e.g.
[107,66,95,148,100].
If not specified otherwise, all functions are assumed in this section to be functions on ω, and all sets to be subsets of
ω. Thus, for an n-ary partial function φ, we have dom(φ) ⊆ωn and rng(φ) ⊆ω. Instead of (x1, . . . , xn) ∈dom(φ)
((x1, . . . , xn) ̸∈dom(φ)) we sometimes write φ(x1, . . . , xn) ↓(respectively, φ(x1, . . . , xn) ↑). We assume the reader to
be familiar with the computable partial (c.p.) functions, computable (total) functions and computably enumerable (c.e.)
sets. For any n > 1, there is a computable bijection λx1, . . . , xn.⟨x1, . . . , xn⟩(the Cantor coding function) between ωn and
ω. This fact reduces many considerations to the case of unary functions and predicates.
In computability theory and theoretical computer science people use similar computable codings for many types of
constructive objects. E.g., there is a computable bijection between ω∗(or 2∗) and ω. Another coding is used to define the
main object of computability theory — the acceptable numbering of all c.p. functions. Namely, let {Pn}n<ω be a computable
numbering of all programs in a suitable formal language (say programs for Turing machines or Pascal-programs working
142
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
only with the natural numbers). Furthermore, let ϕn be the (unary) c.p. function and πn = dom ϕn the c.e. set computed by
Pn. In this way we obtain the numbering ϕ = λn.ϕn of c.p. functions and the the numbering π = λn.πn of c.e. sets. Following
Mal’cev [93], we call these numberings the Kleene and Post numberings, respectively. Another well-known relevant example
is the Gödel numbering of the first-order sentences (formulas, terms) of a given finite signature.
We assume the reader to be acquainted with the computations relative to a given set A ⊆ω or a functionξ ∈ωω (which in
this situation are often called oracles). E.g., such computations may be formally defined using Turing machines with oracles.
Enumerating all programs for such machines we obtain numberings ϕA (ϕξ) of all partial functions computable in A (in ξ).
We call these numberings relativizations of the Kleene numbering. Similarly one can define the relativized Post numberings
πξ
n = dom ϕξ
n. These objects may be used to transfer the computability theory to the Baire and Cantor spaces. E.g., a partial
function Φ from ωω to ω is called computable if there is an n such that Φ = λξ.ϕξ
n(0). A partial function Φ from ωω to
ωω is called computable if there is an n such that Φ(ξ) = λx.ϕξ
n(x)) for all ξ. E.g., the bijections (ξ, x) 7→⟨ξ, x⟩between
ωω × ω and ωω and (ξ, η) 7→⟨ξ, η⟩between ωω × ωω and ωω defined by ⟨ξ, x⟩= x⌢ξ and by ⟨ξ, η⟩(2x) = ξ(x) and
⟨ξ, η⟩(2x + 1) = η(x), as well as their inverses, are computable. Any computable function is continuous (as topology on ω
we take the discrete topology). In this way, we obtain a reasonable computability theory in the Baire and Cantor spaces and
some of their relatives [107,66,95].
Since different numberings like those mentioned above are met everywhere in theoretical computer science, we recall
a couple of relevant general notions (for more details see e.g. [93,39–41,129]). By numbering we mean any function ν with
dom(ν) = ω, and by numbering of a set S — any numbering ν with rng(ν) = S. By ν-index set of a set M ⊆rng(ν) we mean
the preimage ν−1(M). Many natural decision problems are represented as index sets of some numberings. E.g., the decision
problems related to c.p. functions, c.e. sets and first-order sentences correspond to the index sets of the Kleene, Post and
Gödel numberings, respectively. We say that a numbering µ is reducible to a numbering ν (in symbols µ ≤ν), if µ = ν ◦f
for some computable function f , and that µ is equivalent to ν (µ ≡ν), if µ ≤ν and ν ≤µ. Relate to any numberings µ, ν
and to any sequence of numberings {νk}k<ω the numberings µ⊕ν, and L
k νk, called respectively join of µ and ν and infinite
join of νk(k < ω) defined as follows:
(µ ⊕ν)(2n) = µn, (µ ⊕ν)(2n + 1) = νn,
 M
k
νk
!
⟨x, y⟩= νx(y).
We call a numbering ν : ω →Sω acceptable if rng(ν) is closed downwards under ≤, (L
k νk) ∈rng(ν) and for some
computable function s it holds νk⟨n, x⟩= νs⟨k,n⟩(x) (the last property is an abstract version of a particular case of the smn-
theorem). It is well-known and easy to see that any two acceptable numberings with the same range are equivalent, and that
Kleene and Post numberings are acceptable. Notice the close similarity of acceptable numberings to the acceptable codings
ν : ωω →P(ωω) from Section 4.1. Using the bijection ωω × ω and ωω defined above one can define in a similar fashion
acceptable numberings of the form ν : ω →Sωω, and, in particular, of the form ν : ω →P(ωω), i.e. of subsets of the Baire
space.
Another very relevant notion is that of complete numbering. A numbering ν is complete (w.r.t. a fixed a ∈rng(ν)), if for
any c.p. function ψ there is a computable function t (called a ν-totalizer of ψ w.r.t. a) such that νt(x) = νψ(x) for ψ(x) ↓
and νt(x) = a for ψ(x) ↑. E.g., the Kleene numbering is complete w.r.t. the empty function and the Post numbering is
complete w.r.t. the empty set. For more on the complete numberings and their relatives see [93,41,129]. For any set S and
any a ∈S, define a unary operation pa on Sω as follows: [pa(ν)]n = a for υ(n) ↑and [pa(ν)]n = νυ(n) for υ(n) ↓, where υ
is the universal p.c. function υ(⟨n, x⟩) = ϕn(x). These completion operations were introduced in [110] as a variant of similar
operations from [41]. They are very relevant to fine hierarchies as we will see below and as the following result from [110]
demonstrates.
Theorem 6.1. The structure (Sω; ≤, ⊕, {pa}a∈S) is a dc-semilattice.
We conclude this subsection by recalling the Kleene notation system for computable ordinals. By computable linear order
we mean a linear order (P; ≤) where P is a computable subset of ω and the relation ≤is computable (the case P = ∅is
also possible). An ordinal is called computable if it is isomorphic to a computable well order. Clearly, if α is a computable
ordinal and β < α then β is also computable. The first non-computable ordinal denoted ωCK
1
is known as the Church–Kleene
ordinal.
Let ⪯be the least (with respect to inclusion) preorder on a subset of ω such that the following conditions hold: 1 ⪯x,
x ≺2y ↔x ⪯y for all y ̸= 0 and x ≺3 · 5e ↔∃n(ϕe(n) ↓∧x ≺ϕe(n)).
The predicate ⪯is c.e., and x ⪯y implies x, y ∈{2b, 3 · 5e | b, e < ω}. Let M be the set of all a such that Sa = {x|x ⪯a}
is linearly ordered by ⪯and ∀n(ϕe(n) ⪯a) for all 3 · 5e ⪯a. Let ≤O denote the restriction of the relation ⪯to the set
O = {a ∈M | (Sa; ⪯) is well founded} and let |a|O denote the order type of the well-order ({x ≤x <O a}; ≤O). It is clear
that the partial order (O; ≤O) is well founded, |1|O = 0, |2b|O = |b|O + 1 and |3 · 5e|O = sup{ϕe(n)O | n < ω} (see Fig.
10). The structure (O; ≤O) is called the Kleene notation system for computable ordinals. It is well-known that an ordinal is
computable iff it has a notation in the Kleene system. In other words, a 7→|a|O is a surjection from O onto ωCK
1 .
By (Oξ; ≤Oξ ) we denote the relativization of the Kleene system to any given oracle ξ. This relativized Kleene system give
notation to all ordinals computable in ξ.
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
143
Fig. 10. The Kleene system.
6.2. Bases and reducibilities
Let us define an effective version of the Borel hierarchy developed in [111,113,114,137] (several other related treatments
of the effective Borel hierarchy are known, see e.g. in [107,95,66,150]). Following the tradition of DST, we denote levels of
the effective hierarchies in the same manner as levels of the corresponding classical hierarchies, using the lightface letters
Σ, Π, ∆instead of the boldface 6, 5, 1 used in the classical DST.
Let β : ω →P(M) be a numbering of subsets of an arbitrary set M such that (rng(ν); ∪, ∩,¯, ∅, M) is a Boolean algebra
and the operations ∪, ∩,¯ are presented by computable functions on the β-indices. Finite effective Borel hierarchy over β
is the sequence {Σ0
n}n<ω defined as follows: Σ0
0 = {∅}; Σ0
1 is the class of sets S{βk | k ∈πx}, x ∈ω, equipped with the
numbering induced by the Post numbering, Σ0
n (n > 1) is the class of sets S{γk | k ∈πx}, x ∈ω, equipped again with the
numbering induced by π, where γ is the numbering of Π 0
n−1 induced by the numbering of Σ0
n−1 (which exists by induction).
It is easy to check that {Σ0
n}n<ω is a reducible ω-base. In the case when β is the natural numbering of the finite and
co-finite subsets of ω we obtain an ω-base in ω that coincides with the well-known arithmetical hierarchy. As the name
suggests, this hierarchy coincides with the quantifier-alternation hierarchy in the structure (ω; +, ·, 0, 1). In the case when
β is the natural numbering of the clopen sets in ωω (or 2ω) we obtain the ω-base known as the arithmetical hierarchy in the
Baire (respectively, Cantor) space. Similar ω-bases may be constructed in many spaces with suitable effectivity conditions
(e.g. in the effective reflective or 2-reflective domains defined in a natural way), see [137]. The hierarchies just introduced
are the main ω-bases for this section. One could also construct relativized (to any oracle ξ) versions of those bases: just take
the relativized Post numbering πξ in place of π. All the mentioned ω-bases in ω, in the Baire and Cantor spaces [107], and
also in any effective reflective or 2-reflective domain [137] do not collapse.
The transfinite extension of the hierarchy {Σ0
n}n<ω is also constructed in the natural way [107,111]. Of course, we cannot
hope to get natural ω1-hierarchies this way, because the standard definition from DST would destroy the main idea of
effectivity of the constructed hierarchies. In fact, we have to take an effective version of the DST-construction, and this leads
to using the Kleene notation system (O; <O) for constructive ordinals in place of ω1 in DST. Levels of the transfinite version
(denoted Σ0
(a) for all a ∈O) are defined in the same way as for the finite levels, using effective induction along the well-
founded set (O; <O) [107]. In order to avoid some tedious technical details we omit the formal definition here. The simplest
properties of the effective Borel hierarchy {Σ0
(a)}a∈O are proved in a straightforward way [111].
Proposition 6.2. If 1 ≤|a|O < ω then Σ0
(a) = Σ0
|a|O and If a <O b then Σ0
(a) ⊆∆0
(b).
The hierarchy {Σ0
(a)}a∈O in ω and ωω is commonly known as the hyperarithmetical hierarchy. It does not collapse and is
an exhausting refinement of the analytical hierarchy (which is denoted {Σ1
n}n<ω) in the first level, i.e. S
a∈O Σ0
(a) = ∆1
1 (see
e.g. [107,95]); the analytical hierarchy is the effective version of the projective hierarchy. This remarkable equality due to S.
Kleene is the effective version of the Suslin theorem. We do not define the projective and analytical hierarchies in this paper
though they are certainly the most prominent examples of the coarse hierarchies.
Remark. Note that the hyperarithmetical hierarchy is not formally a hierarchy in the sense of Section 2.7 because its levels
are ‘‘numbered’’ by ordinal notations and not by ordinals. This is not essential for the hyperarithmetical hierarchy because it
is known to be extensional, i.e. Σ0
(a) = Σ0
(b) for all a, b ∈O, |a|O = |b|O. But the transfinite fine hierarchies discussed below
are non-extensional, hence our definition of hierarchy, strictly speaking, does not apply for them. It is not hard to adjust the
definition to include also such hierarchies along well founded partial orders like (O; <O) (see below).
Computability theory aims to classify sets and functions according to their ‘‘algorithmic complexity’’. One of main tools
for this classification is the concept of reducibility. Intuitively, a set A ⊆ω is reducible to a set B ⊆ω if one can ‘‘reduce’’
questions ‘‘a ∈A?’’ to questions ‘‘b ∈B?’’. There are many explications of this idea, the most useful of which are the notions
of m- and T-reducibilities. The m-reducibility denoted ≤m is just the many-one reducibility by computable functions. A
set A is called Turing-reducible (T-reducible) to B (in symbols, A ≤T B) if A is computable in B, i.e. A = ϕB
n for some n.
144
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
The m-reducibility ≤ξ
m by functions computable in a given oracle ξ is sometimes also of interest to our topic. Note that the
reducibility of numberings from the preceding subsection subsumes m-reducibility of sets, as well as of k-partitions for each
k > 1.
It is well-known that the arithmetical and hyperarithmetical hierarchies in ω, ωω and 2ω fit the m-reducibility. In fact,
they have the stronger property that all their non-self-dual levels are effective pointclasses, that is they have acceptable
numberings (cf. with the notion of classical pointclass in the previous section). Since, by Section 6.1, the acceptable
numberings are unique up to equivalence, we can denote them by the same letters as the pointclasses. It is well-known
that any effective pointclass is non-self-dual. Actually, all levels of the fine hierarchies in ω, ωω we consider below in this
section will be effective pointclasses (acceptable numberings are constructed easily from definitions of the hierarchies), and
hence they ‘‘automatically’’ do not collapse.
We summarize the remarks above in the following definitions that adjust the notion of abstract hierarchy to the context
of computability theory. Effective ω-hierarchy is a sequence {Σn}n<ω of effective pointclasses equipped with acceptable
numberings satisfying Σn ⊕Πn ≤Σn+1, uniformly in n < ω. By effective O-hierarchy we mean a uniform sequence {Σ(a)}a∈O
of effective pointclasses satisfying Σ(a) ⊕Π(a) ≤Σ(b) uniformly in a <O b. The notions from Section 2.7 (like refinement,
discreteness and perfectness) are also adjusted for the case of effective hierarchies in a straightforward way.
We conclude this subsection by a well-known characterization of the arithmetical hierarchy in ω in terms of the Turing
jump operation A 7→A′ on P(ω) defined by A′ = {n | ϕA
n(n) ↓}. For any n < ω, define the n-th jump A(n) of A by A(0) = A
and A(n+1) = (A(n))′. Then ∅(n) is m-complete in Σ0
n for each n < ω. Moreover, this construction is extended to the iteration
of Turing jump along the Kleene system in a straightforward way such that ∅((a)) is m-complete in Σ0
(a) for each a ∈O (see
[107]).
6.3. Difference hierarchies
The difference ω-hierarchy {Σ0
n(m)}m<ω over any non-zero level of the (hyper)arithmetic hierarchy is defined in
accordance with the general definition in Section 3.1. For the transfinite version {Σ0
n((a))}a∈O we use the effective version
of definition in Section 4.3, namely Σ0
n(a) is the class of sets
D(a)({Ab}) =
[ (
Ab \
 [
c<Ob
Ac
!
| b <O a, r(b) ̸= r(a)
)
where {Ab}b<Oa is a c.e. sequence of sets in Σ0
n and r : ω →{0, 1} is a computable function such that r(a) = 0 iff |a|O is even,
for all a ∈O. Since the exact definition in the transfinite case is technically rather involved, we omitted some details here.
The effective DH over Σ0
1 was introduced and comprehensively studied by Ershov [38]. It is sometimes denoted {Σ−1
(a) }a∈O
and called the Ershov hierarchy.
It is easy to show that the DH’s introduced above are hierarchies in the sense of the previous section and they do not
collapse (at least, in ω, ωω and 2ω) and refine the (hyper-)arithmetical hierarchy in the next levels. As observed in [137],
these effective DH’s do not collapse also in all effective reflective and 2-reflective domains. As also in the context of DST, it
is easy to show that the effective DH over Σ0
n is m-discrete for n = 1 but not m-discrete for n > 1.
In [38] it is shown that the Ershov hierarchy is an exhaustive refinement of the arithmetical hierarchy in the second level.
Moreover, S{Σ−1
(a) | a ∈O, |a|O = ω2} = ∆0
2 and ω2 is the smallest ordinal with this property. In [114] this was extended to
the effective DH’s over Σ0
(a) for each a ∈O, |a|O > 1 but, when |a|O increases, one needs bigger and bigger ordinals in place
of ω2. In [119,131] we have shown that the transfinite effective DH over Σ0
1 in ωω (and in 2ω) also exhausts ∆0
2 but this time
we have the strict inclusion S{Σ0
1((a)) | a ∈O, |a|O = α} ⊂∆0
2 for each α < ωCK
1 . In [59] the same fact was obtained for
some other spaces. In [119] it is shown that any Σ-level of the Ershov hierarchy in ω has the reduction property.
By the preceding subsection, the complete sets in the Σ-levels of the arithmetical hierarchy in ω may be obtained by
iterating the Turing jump starting from the empty set. In [38] a similar fact was proved for the Ershov hierarchy. Since we
want to discuss some similar facts below, let us formulate a general notion. By jump operator we mean a unary operation J
on 2ω such that A ⊕A ≤m J(A) and J(A) is a complete numbering w.r.t. 0 uniformly in A. From properties of the complete
numberings it follows that actually we have A⊕A <m J(A). It is clear that for any set A complete w.r.t. 0 the sequence {J(a)(A)}
(more exactly the sequence of the principal ideals {B | B ≤m J(a)(A)} corresponding to the iterations of J along O starting
from the set A) behaves as an O-hierarchy; we denote this hierarchy by (J, A). As noticed above, if J is the Turing jump then
(J, ∅) is the hyperarithmetical hierarchy. As observed in [38], the operation Jm(A) = υ−1(A ⊕A), where υ⟨n, x⟩= ϕn(x) is
the universal c.p. function, is a jump operator called m-jump. By [38], (Jm, ∅) coincides with the Ershov hierarchy. Similarly,
if we take in place of Jm the m-jump relativized to ∅(a), for each a ∈O, we obtain the effective DH over Σ0
(2a) [114].
The effective DH’s in ω have numerous applications to classification of interesting decision problems (formalized as index
sets). We conclude this subsection by formulating a couple of such results about the long DH {Σ0
n(m)}n,m<ω, many more may
be found e.g. in [38,89,114–117,119,124,129,132,25]. Let {Bn}n<ω be the natural numbering of c.e. Boolean algebras (known
also as positive Boolean algebras, see e.g. [117,132,124] for details). The next fact was obtained in [117].
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
145
Theorem 6.3. For any sentence φ of signature τ = {∪, ∩,¯, 0, 1}, the index set {n | Bn |= φ} is m-complete in one of levels of
the long difference hierarchy, and the level is effectively computable from the sentence φ.
Now consider index sets of some classes of c.e. sets in the Post numbering. For a class C of Boolean algebras, let
h∗(C) = {n | L∗(πn) ∈C} where L∗(πn) is the quotient of L(πn) = {A ∈Σ0
1 | πn ⊆A} modulo finite sets. For any
sentence φ of signature τ = {∪, ∩,¯, 0, 1}, let Mφ denote the class of Boolean algebras satisfying φ. The next fact is from
[116]. In [89,115–117] one could find many other related results.
Theorem 6.4. For any sentence φ of signature τ = {∪, ∩,¯, 0, 1}, the index set h∗(Mφ) is m-complete in one of levels of the long
difference hierarchy, and the level is effectively computable from φ.
Finally, we formulate a result from [124] about the Lindenbaum algebra.
Theorem 6.5. Let σ be a finite relational signature that has at least one non-unary symbol and let (Bσ; γ ) be the Lindenbaum
algebra of σ-sentences with the Gödel numbering γ . Then for any unary formula φ(x) of signature τ = {∪, ∩,¯, 0, 1} the index
set {n | Bσ |= φ(γn)} is m-complete in one of the levels of the long difference hierarchy, and the level is effectively computable
from φ(x).
6.4. Fine hierarchy
Now we discuss the fine hierarchy {Σα}α<ε0 over the ω-base L = {Σ0
n+1}n<ω in ω (see Section 3.4). Since the base is
reducible, the fine hierarchy coincides with the corresponding typed Boolean hierarchy, i.e. {Σα, Πα | α < ε0} = {t(L) |
t ∈T ∗} where T ∗is the set of typed Boolean terms.
By the preceding subsection, the long DH may be characterized in terms of suitable jump operations. Is there a similar
characterization for the fine hierarchy? The answer is positive, and actually the fine hierarchy was discovered in [112] in this
way. Since the jump-characterization is non-trivial and yields additional information on the fine hierarchy, we provide some
details. Which jump operations to use? Of course, at least the m-jumps Jn
m relativized to ∅(n), for all n < ω. By the preceding
subsection, (Jn
m, ∅) is the difference hierarchy over Σ0
n+1. A wider class of ω-hierarchies is constructed by considering sets
generated from the empty set by all the operations Jn
m (n < ω), see [112]. It is easy to check that in this way we obtain a
non-collapsing hierarchy with order type ωω. This already shows that these jump operations do not suffice. By the way, one
could guess that in this way we obtain the symmetric DH over L. But this is also not the case; in fact we obtain some of the
exotic levels defined with the operation bisep.
In order to find a sufficient class of jump operations, we define an operation r : Sω × Sω × kω →Sω (where S is a set and
2 ≤k ≤ω) that generalizes the jump operations above, the Turing jump and many others. We set r(µ, ν, f ) = L
n p
f
ν(n)(µ).
Then r(µ, λx.a, f ) ≡p
f
a(µ) for all a ∈S, hence r generalizes the operations of completion from Section 6.1. Note that for
S = k = 2 the operation r is a ternary operation on sets satisfying r(ω, ∅, A) ≡A′, hence r generalizes also the Turing jump.
It induces also several other jump operators. Namely, for any sets B and C, if B is complete w.r.t. 0 then A 7→r(A⊕A, B, C) is
a jump operator. This follows from definition and the property that if ν is f -complete w.r.t. a then so is also the numbering
r(µ, ν, f ). The last property together with other properties of r generalizing the properties of the completion operations
were established in [112]. These properties play a central role in the algebraic proof of the result below that classifies
elements of the subalgebra generated by the operations r, ¯and ⊕from ∅within 2ω. As a corollary, we obtain the jump-
characterization of the fine hierarchy.
Definition 6.6. For all n < ω and α < ε0, define the sets Cn
α by induction on α as follows:
Cn
0 = ∅; Cn
ωγ = Cn+1
γ
for γ > 0;
Cn
α+1 = r(Cn
α ⊕C
n
α, Cn
0, ∅(n));
Cn
α+ωγ = r(Cn
α ⊕C
n
α, Cn
ωγ , ∅(n)) for α = ωγ · β > 0 and γ > 0.
Properties of complete numberings play a central role in the proof of the next result from [112,115].
Theorem 6.7. (i) Modulo m-equivalence, the class of sets generated within 2ω by the operations r, ¯and ⊕from ∅coincides with
the class of sets C0
α, C
0
α, C0
α ⊕C
0
α (α < ε0).
(ii) For all α < β < ε0, C0
α ⊕C
0
α <m C0
β.
(iii) For any α < ε0, C0
α ≡m Σα, C0
α ̸≤m C
0
α and C0
α ⊕C
0
α ≡m ∆α+1. In particular, the fine hierarchy does not collapse and is
m-discrete in all successor levels.
In [112] we also showed that from the sequence {Σα} one can extract a complete (in a sense) hierarchical classification of
arithmetical sets. Relate to any limit ordinal λ ≤ε0 the natural increasing sequence of ordinals {η(λ, k)}k<ω with supremum
λ (e.g. η(ε0, 0) = 0 and η(ε0, k + 1) = ωη(ε0,k)). Let H be the class of ω-hierarchies Hλ = {Ση(λ,k)}k<ω for all limit ordinals
λ ≤ε0. Using a suitable jump operation one can extend any of these ω-hierarchies to the Kleene ordinal notation system
similarly to the case when the arithmetical hierarchy is extended to the hyperarithmetical hierarchy). Then we have the
following reformulation of the main result from [112].
146
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
Theorem 6.8. The class H has the following properties:
(i) the arithmetical hierarchy belongs to H;
(ii) if an H-hierarchy Hλ is not m-discrete in level l + 1, then µ = η(λ, l + 1) is a limit ordinal, the hierarchy Hµ refines Hλ
in level l + 1 and the transfinite extension of Hµ exhausts ∆η(λ,l+1);
(iii) any sequence K0, K1, . . . of H-hierarchies, each of which refines the preceding one in some level, is finite;
(iv) the class of all finite Σ-levels of the H-hierarchies is exactly {Σα | α < ε0}.
The properties (i)–(iii) show that the class H has natural (from the point of view of hierarchy theory) closure properties;
one could say that H is closed under the Suslin–Kleene theorem. So it gives in a sense a complete hierarchical classification of
the arithmetical sets. The property (iv) means that the fine hierarchy consists exactly of the finite levels of the H-hierarchies.
Note that in [112] we described also a transfinite version of Theorem 6.8, i.e. a hierarchical classification of the
hyperarithmetical sets. This is very natural for hierarchy theory, but we nevertheless think that the finite version is more
interesting for the following reasons: a) classes of the transfinite fine hierarchies are not almost linearly ordered (for the
case of the difference hierarchy this was mentioned above); (b) dealing with the transfinite version is technically very
complicated; (c) ‘‘natural’’ sets are usually m-complete in a finite level of an H-hierarchy; d) the transfinite version is less
‘‘absolute’’ than the finite one, e.g. it is not generalizable to the abstract case which we considered in Section 3.4.
The next result from [124] demonstrates a close relationship of the fine hierarchy to multiple m-reducibility of tuples of
sets. Let F be a finite subset of V = {vn
k | n, k < ω} and TF be the set of typed Boolean terms with variables in F. Relate to
any R ⊆F the term eR = (T
v∈R v) ∩(T
v∈F\R ¯v) from TF. By F-assignment we mean a map A from F into s P(ω) such that
An
k = A(vn
k) ∈Σ0
n+1 for vn
k ∈F (the assignment may be written as a family {An
k | vn
k ∈F}). For t ∈TF let t[A] denote the
value of t on A (when vn
k is interpreted as An
k).
Now let F = (F; F ) be a pair with F as above and F a nonempty finite subset of P(F). By F-assignment we mean an
F-assignment A such that eR[A] = ∅for all R ∈P(F) \ F (intuitively, F specifies the F-assignments satisfying all Boolean
identities from P(F) \ F ). Let t[L, F] be the set of values of t on all F-assignments. These sets are closely related to the levels
of the fine hierarchy.
Relate to any F-assignment A the pair FA = (F; FA), where FA = {R ⊆F | eR[A] ̸= ∅}; A is clearly an FA-assignment.
An F-assignment B is m-reducible to A (in symbols B ≤m A), if there is a computable function f such that Bn
k = f −1(An
k)
for all vn
k ∈F. Note that if B ≤m A then B is an FA-assignment. We call A a complete F-assignment if any FA-assignment is
m-reducible to A. This notion generalizes several similar notions in computability theory, e.g. the notion of m-complete (or
effectively inseparable) pair of disjoint c.e. sets.
Theorem 6.9. Any Boolean combination of members of a complete F-assignment is m-complete in one of levels Σα, Πα, ∆α+1
(α < ε0) of the fine hierarchy, and all the possibilities are realized.
We conclude this subsection by an application of the fine hierarchy and the previous theorem to classification of index
sets. Some other examples may be found in [117,124,132]. For a numbered structure A = (A; ν), where ν is a numbering
of A, and a predicate P(v1, . . . , vn) on A, let ν−1(P) = {⟨x1, . . . , xk⟩| P(νx1, . . . , νxk)} be the ν-index set of P. A definable
index set of A is the index set ν−1(P) of a predicate P first-order definable in A. To prove the following result from [124] one
again needs a version of the alternating trees for the definable predicates. This time such invariants may be defined from
the Tarski-Ershov elementary classification of Boolean algebras.
Theorem 6.10. Let σ be a finite relational signature that has at least one non-unary symbol and let (Bσ; γ ) be the Lindenbaum
algebra of sentences of σ with the Gödel numbering γ . Then for any formula φ(v1, . . . , vk) of signature τ = {∪, ∩,¯, 0, 1} the
index set {⟨x1, . . . , xk⟩| Bσ |= φ(γ (x1), . . . , γ (xk))} is m-complete in one of levels Σα, Πα, ∆λ+1 (α, λ < ε0, λ is a limit
ordinal) of the fine hierarchy, and all the possibilities are realized. There is an algorithm that computes from a given formula φ the
corresponding level of the fine hierarchy.
6.5. Hierarchies of k-partitions
We have seen that iterating of some jump operators leads to interesting hierarchies of sets. In a similar way one can
obtain interesting hierarchies of functions from kω, where k is a fixed ordinal satisfying 2 ≤k ≤ω (in particular, for the
k-partitions of ω).
First we look for an analog of the difference hierarchy. We generalize the characterization of the effective DH in terms of
m-jump, using this time the completion operations pi, i < k, on kω from Section 6.1.
Definition 6.11 ([113]). (i) For all a ∈O and i < k, define the functions f i
(a) and f(a) from kω as follows: f(a) = L
i<k f i
(a),
f i
(1) = λx.i, f i
(2b) = pi(f(b)), and f i
(3·5e) = pi(L
n<ω f(ϕe(n))).
(ii) Set C(a) = {g | g ≤f(a)}, Ci
(a) = {g | g ≤f i
(a)} and D(a) = T
i<k Ci
(a).
From Theorem 6.1 one easily obtains that Ci
(a) ⊂D(b) ⊂C
j
(b) and C(a) = Ci
(2a) ∩Cl
(2a) = D(2a) for all i, j, l < k, i ̸= l and
a <O b. So the introduced classes are ordered as levels of a ¯k × O-hierarchy of k-partitions which is the effective version
of the ¯k × α-hierarchies in Section 2.8. It turns out that the introduced classes are closely related to limiting computations
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
147
considered in [35,113]. Relate to any c.p. function ψ and to any a ∈O a partial function µ = µa,ψ from ω to the set
B = {b | b <O a} as follows: µ(x) is the least element (if any) of ({b ∈B | ψ⟨x, b⟩↓}; ≤O). Note that µ(x) ↓implies
ψ⟨x, µ(x)⟩↓, and that fixing effective stepwise enumerations of ψ and (B; ≤O) one gets limiting computations of µ(x) and
ψ⟨x, µ(x)⟩.
Definition 6.12. (i) A function f ∈kω is called i-a-computable (for i < k and a ∈O), if there is a c.p. function ψ : ω →k
such that f (x) = i for µ(x) ↑and f (x) = ψ⟨x, µ(x)⟩for µ(x) ↓.
(ii) A function f ∈kω is called a-computable, if f (x) = ψ⟨x, µ(x)⟩for some c.p. function ψ : ω →k.
Theorem 6.13 ([113]). (For all i < k and a ∈O, the class of i-a-computable functions (of a-computable functions) coincides
with Ci
(a) (respectively, with C(a).) Moreover, S
a∈O D(a) = {f ∈kω | f ≤T ∅′}.
The last result shows that the hierarchy of k-partition introduced above is an effective version of the limit-hierarchy from
Section 4.5. For k = 2 it gives a characterization of the DH in terms of limiting computations which for the finite levels is
equivalent to the description from [38]. In [35,113] the reader can find much additional information about the hierarchies
of functions.
In [133] we considered the DH of k-partitions over the base Σ0
1 of c.e. sets in ω. Since this base is reducible, BHk(Σ0
1) =
FBHk(Σ0
1) by Theorem 3.20, i.e. it suffices to consider the DH of k-partitions over k-forests. This hierarchy is intimately related
to the completion operations pi, i < k, from Section 6.1. Namely, by Theorem 6.1, the structure (kω; ≤, ⊕, p0, . . . , pk−1)
is a dc-semilattice. By Proposition 2.9, there is an embedding g of the quotient-structure of (Fk; ≤, ⊔, p0, . . . , pk−1) into
that of (kω; ≤, ⊕, p0, . . . , pk−1) such that g(i) = λn.i for all i < k. By [133], the k-partition g(F) is m-complete in Σ0
1(F)
for each F ∈Fk and hence the DH of k-partitions over Σ0
1 does not collapse. By Section 2.6, we again have results on the
undecidability of the first-order theory of the structure of levels of the DH of k-partitions over Σ0
1 and on the automorphism
group of this structure. In [133] similar facts were also established for the DH of k-partitions over any level of the arithmetic
hierarchy in ω and over the base Σ0
1 of effective open sets in the Baire and Cantor spaces.
In the previous sections we discussed mainly the DH’s of k-partitions and some of its subhierarchies. In computability
theory, there is also a good candidate for the fine hierarchy of k-partitions over the ω-base {Σ0
n+1} in ω. It is the subalgebra
of (kω; r, ⊕) generated from λx.0, . . . , λx.k−1, where r is the ternary operation on kω obtained from the operation r in the
previous subsection for S = k. This subalgebra was not considered in detail in [112] but seems very interesting because, by
the preceding subsection, for k = 2 we obtain exactly the fine hierarchy over {Σ0
n+1}.
6.6. Undecidability in complete numberings and index sets
In [138,144] we have shown that Proposition 2.6 implies many undecidability results for the structures of complete
numberings and index sets and partitions. We give a couple of examples here.
For any C ⊆P(ω), let Ck be the corresponding subset of kω. Let C1
k (C2
k ) be the set of complete (respectively, 2-complete)
numberings from Ck. E.g., P(ω)k = kω, P(ω)1
k is the set of complete numberings in kω, and (∆0
2)2
k is the set of 2-complete ∆0
2-
partitions in kω. The next result from [138,144] shows that for many of the classes C1
k and C2
k the corresponding structures
have undecidable theories.
Theorem 6.14. Let k ≥2 and let C be one of the classes P(ω), ∆1
1, Σ0
n+1, Π 0
n+1, BC(Σ0
n), ∆0
n+1, where n > 0. Then FO(Ck; ≤),
FO(C1
k; ≤) and FO(C2
k; ≤) are hereditary undecidable.
Let ν be a numbering of S. A ν-index set of a set A ⊆S is the preimage ν−1(A). Let Iν be the class of all ν-index sets.
Investigation of m-degrees of index sets of important numberings (especially of the Kleene and Post numberings) is a popular
topic in computability theory (see e.g. [56,109,110,85,94]). Similar questions are also interesting for the more general case
of ν-index k-partitions which are k-partitions of the form c ◦ν where c : S →k (in [110] they are called generalized index
sets). In this section we discuss ν-index k-partitions for the following classes of numberings introduced in [41,110].
For any numbering ν and for each C ⊆P(ω), let Cν
k be the set of ν-index k-partitions in Ck. E.g., P(ω)ν
2 = Iν is the class
of all ν-index sets while (∆0
2)ν
3 is the class of ν-index 3-partitions in (∆0
2)3.
A complete (2-complete) numbering ν is called universal if every complete (respectively, 2-complete) numbering µ is
a quotient of ν, i.e. µ ≡f ◦ν for some f : rng(ν) →rng(µ). As shown in [41,110], many numberings of interest
to computability theory, e.g. numberings of the computable partial functionals, are universal complete or 2-complete. In
particular, the Kleene numbering is universal complete while the Post numbering is universal 2-complete. Therefore, the
following theorem applies to all those numberings.
Theorem 6.15. Let ν be a universal complete or 2-complete numbering, k ≥2 and let C be one of the classes P(ω), ∆1
1, Σ0
n+1,
Π 0
n+1, BC(Σ0
n), ∆0
n+1, where n > 0. Then FO(Cν
k ; ≤) is hereditary undecidable.
Sometimes the exact complexity estimations for the theories are possible, e.g.:
Theorem 6.16. Let ν be a universal complete numbering and k ≥2. Then FO(P(ω)ν
k; ≤m) is computably isomorphic to the
second-order arithmetic.
148
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
6.7. Relation to DST
Here we discuss relationships between DST and computability theory. We have seen that some hierarchies in
computability theory are effective versions of the corresponding hierarchies in DST. In fact, the relationship is much closer
[95]: the theory of effective hierarchies in the Baire and Cantor spaces refines the theory of classical hierarchies. As is usual
in computability theory, every natural effective ω-hierarchy {Σn}n<ω in ωω has the relativized versions {Σξ
n } such that for
any n the family {Σξ
n }ξ∈ωω is a uniform sequence of effective pointclasses. It is then easy to see that the classes 6n = S
ξ Σξ
n
form a classical ω-hierarchy.
Similarly, natural O-hierarchies {Σ(a)} usually have relativizations {Σξ
(a)}a∈O such that for any a ∈O the sequence
{Σξ
(a)}ξ∈ωω is a uniform sequence of effective pointclasses. The corresponding classical pointclasses usually have the
following extensionality property: 6(a) = 6(b) for a, b ∈O, |a|O = |b|O. This induces a classical ωCK
1 -hierarchy. In order to
get an ω1-hierarchy as the limit of relativized O-hierarchies, we have to consider the Kleene systems (Oη; ≤Oη) relativized
to any η ∈ωω. Then we get the classes {Σξ⊕η
(a) } for all ξ ∈ωω, a ∈Ou. For fixed η and a, {Σξ⊕η
(a) }ξ is again a uniform family of
effective pointclasses. The corresponding classical pointclasses satisfy the extensionality property 6(a) = 6(b) for a, b ∈Oη,
|a|Oη = |b|Oη. This induces the ω1-hierarchy {6α}α<ω1 because any countable ordinal α is of course computable in some
η ∈ωω, hence, α = |a|Oη for some a ∈Oη.
In order to systematize the connections between effective and classical notions we give a short dictionary of the
corresponding terms. The translation is obtained by relativization and taking union on all oracles. In this way, any effective
hierarchy discussed in this section leads to its classical counterpart in Section 4.
COMPUTABILITY THEORY
DESCRIPTIVE SET THEORY
computable function
continuous function
m-reducibility
Wadge reducibility
computable set
clopen set
effective open set
open set
computable ordinal
countable ordinal
(O; ≤O)
(ω1; ≤)
effective pointclass
classical pointclass
effective ω-hierarchy
classical ω-hierarchy
O-hierarchy
ω1-hierarchy.
The interplay between DST and computability theory has also other facets. E.g., one could ask for a characterization of
the Wadge degrees (or, as a first step, of the Borels ranks) of, say, the arithmetical, hyperarithmetical or (lightface) Σ1
1 -sets.
An important result in this direction is Theorem 2.4 in [91] stating the Borel rank of the hyperarithmetical sets is ωCK
1 . In
contrast, a result in [73] states that the Borel rank of the Σ1
1 -sets is bigger than ωCK
1 . We will see in Section 9 that results of
this type are useful for understanding the topological complexity of infinite behavior of computing devices.
Computability theory is interesting not only for the Baire and Cantor spaces and domains but also for more traditional
spaces like the real numbers or finite-dimensional Euclidean spaces. Hierarchies and reducibilities play a noticeable role in
such considerations related e.g. to computable analysis [176] and numeric mathematics.
6.8. Future work
By Section 6.3, the effective DH over Σ0
1 in the Baire, Cantor and Euclidean spaces exhausts the class ∆0
2. The status of
this result for a broad class of effective metric spaces and domains is unclear, as well as the status of the effective Hausdorff–
Kuratowski theorem (even for the Baire and Cantor spaces and domains).
As we have seen in Section 6.5, there is a good candidate for the fine hierarchy of k-partitions over the arithmetical
hierarchy; we would like to see a systematic study of this hierarchy, in particular a better understanding of the structure of
its levels.
In Section 6.4 we gave an example demonstrating the usefulness of the fine hierarchy for classification of the definable
index sets in the Lindenbaum algebra. We would like to see a systematic work also for other natural numbered structures.
Almost nothing is known about classifications of index k-partitions of natural numberings in the hierarchies of k-
partitions introduced in Section 6.5. We expect many interesting results in this direction.
7. Complexity theory
In this section we discuss some fine hierarchies in complexity theory. Complexity-theoretic hierarchies are of primary
importance for computer science because a huge amount of practically interesting decision problems turn out to be complete
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
149
in levels of suitable hierarchies under suitable reducibilities. In fact, complexity theory deals with many more interesting
hierarchies and reducibilities than those we mention below (for nice introductions see e.g. [7,8]). To get the real impression
of this wild world, visit the complexity zoo on the web [1]. We simply choose a couple of hierarchies and reducibilities
relevant to the other parts of this paper.
A remarkable feature of complexity theory is that many basic questions about hierarchies we are going to discuss are
still open (the most prominent of those is of course the P =?NP question). As a result, many facts become dependent on
some famous conjectures of complexity theory. Thus, the situation in this field resembles the situation in the axiomatic set
theory.
The first step in the development of the topic of this section was made by A. Meyer and L. Stockmeyer in the 1970-s
when they defined the polynomial time hierarchy [97,154] (for the sake of brevity we call it also the polynomial hierarchy).
In the 1980s the Boolean (i.e., difference) hierarchy over NP was introduced, apparently independently, by several groups
of people [177,76,23]. In the 1990-s some other refinements of the polynomial hierarchy were proposed [120,126,174].
7.1. Preliminaries
We assume the reader to be familiar with the basic notions and facts of complexity theory like polynomial time
computable functions and sets, deterministic and non-deterministic polynomially bounded Turing machines and their
relativizations, the notion of complexity class and concrete important complexity classes like NL, P, NP and PSPACE. All
this may be found in any book on complexity theory like [11,12,101].
Recall that the main ‘‘space’’ of complexity theory is the set A∗of finite words over a finite alphabet, and actually the set
2∗of binary words is sufficient. Sets of words are called languages. By ⟨a, b⟩we denote a polynomially computable coding
of pairs of words.
For a class K of languages accepted in a certain way by machines of a certain type and a language M, the relativized
class KM is the class of languages accepted in the same way by machines of the same type which in addition have access
to M as an oracle. For a class M of languages, set KM = S
M∈M KM. Levels of the polynomial hierarchy are defined by
Σ
p
0 = Π
p
0 = ∆
p
0 = P, ∆
p
k+1 = PΣp
k , Σ
p
k+1 = NPΣp
k and Π
p
k+1 = co-Σ
p
k+1 for k ≥0. Furthermore, set PH = S
k Σ
p
k .
Please note that the standard notation for the delta-levels of the polynomial hierarchy introduced above does not match
the standard notation for the delta-levels in the hierarchy theory: in the context of complexity theory the classes ∆
p
k and
Σ
p
k ∩Π
p
k need not to coincide, though it holds ∆
p
k ⊆Σ
p
k ∩Π
p
k .
7.2. Bases and reducibilities
As is well-known, the sequence L = {Σ
p
n+1}n<ω of levels of the polynomial hierarchy is an ω-base. It has several
natural characterizations, including a characterization as a logical quantifier-alternation hierarchy with some bounds on
the quantified variables.
Unfortunately, the non-collapse of the polynomial hierarchy is a long standing open problem. Moreover, this problem is
extremely hard because the non-collapse of the polynomial hierarchy implies P ̸= NP (to see this observe that Σ
p
1 = NP).
This is a big obstacle for the development of the theory analogous to those in the previous sections.
Nevertheless, it is possible to obtain some non-trivial conditional results. For this, we will follow the usual ways of
complexity theory. One possibility is to use the commonly believed conjecture that the polynomial hierarchy {Σ
p
n+1}n<ω
does not collapse, i.e. Σ
p
n+1 ̸= Π
p
n+1 for all n < ω. In this way, we are interested in the following question: if the polynomial
hierarchy does not collapse then what ‘‘natural’’ refinements of this hierarchy do not collapse? Another possibility is to
prove absolute results for the polynomial hierarchy {Σ
p,M
n
} relativized to a given oracle M. As is well-known, there are
oracles modulo which the polynomial hierarchy does not collapse or it collapses to any given level. It is easy to show that
LM = {Σ
p,M
n+1}n<ω is an ω-base for each oracle M.
As we have seen in the previous sections, the reducibility of ω-bases under consideration simplifies many considerations
about the refinements of these ω-base. Unfortunately, recently we obtained the following negative result [50]: if the PH
does not collapse then for each n ≥1 none of the classes Σ
p
n, Π
p
n has the reduction property. In the relativized worlds, the
situation may be better: there is an oracle relative to which P = NP ∩coNP ̸= NP and NP has the reduction property; this
solves an open question in [13].
As the main reducibility for this section we choose the polynomial time m-reducibility ≤
p
m, i.e. the m-reducibility by
functions computable in deterministic polynomial time. In fact, in complexity theory many other interesting notions of
reducibility are considered, and some of them (e.g., the m-reducibility by functions computable in deterministic logarithmic
space) could work equally well. It is well-known that the polynomial m-reducibility fits the polynomial hierarchy. Levels
of all hierarchies discussed below will be closed under the polynomial m-reducibility, and some of them will even fit the
polynomial m-reducibility.
150
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
7.3. Difference hierarchies
The DH {NP(n)}n<ω over NP was introduced as a tool for classification of some decision problems not classifiable in
the polynomial hierarchy (provided it does not collapse). E.g., let TSP denote the traveling salesperson problem: given the
distance matrix between n cities, find the shortest tour (for visiting all the cities). As is well-known, the complexity of TSP
is in a sense close to Σ
p
2. The problem TSP(d) of deciding, given a distance matrix and an integer d, is there a tour of length
≤d, is NP-complete. And the problem ETSP(d) of deciding, given a distance matrix and an integer d, is there a tour of length
exactly d, is NP(2)-complete (see [101] for details).
Since L = {Σ
p
n+1}n<ω is an ω-base, the DH over any Σ
p
n+1 is a hierarchy in the sense of Section 2.7. It is well-known and
easy to see that all these DH’s fit the polynomial m-reducibility. The next major fact about the DH’s was obtained by Kadin
[71].
Theorem 7.1. If the polynomial hierarchy does not collapse then the DH over NP does not collapse.
Since the proof of the last result is relativizable, we obtain
Corollary 7.2. (i) If the polynomial hierarchy does not collapse then the long difference hierarchy over L does not collapse.
(ii) There is an oracle M such that the long difference hierarchy over the ω-base LM does not collapse.
The DH over NP is closely related to some other complexity-theoretic hierarchies of current interest that are defined by
deterministic polynomial-bounded computations with NP-oracle and different restrictions on the access to the oracle. To
get an impression on this see e.g. [174,63–65].
7.4. Symmetric difference hierarchy
In complexity theory we again meet the situation similar to that we have seen in computability theory: there are simple
examples of decision problems that can not be completely characterized in terms of the long DH over L = {Σ
p
n+1}n<ω.
Consider as an example the set
D = {⟨a, b⟩| (a ̸∈A ∧b ∈B) ∨(a ∈A ∧b ̸∈B)}
where the sets A and B are polynomially m-complete in Σ
p
1 and Σ
p
2, respectively. Note that if A and B represent ‘‘natural’’
decision problems then the problem represented by D is also rather ‘‘natural’’. The set D is not classifiable up to the
polynomial m-equivalence in the difference hierarchy over Σ
p
2 because both D and its complement are differences of Σ
p
2-sets,
they are Σ
p
2-hard and polynomially m-incomparable (provided the hierarchy does not collapse). But it is easy to show [120,
126] that D is polynomially m-complete in the level Σ
p
2 + Σ
p
1 of the symmetric-difference hierarchy over L. Such examples
show that the symmetric-difference hierarchy over L might be useful.
The next fact from [120,126] extends the Kadin non-collapse theorem to the symmetric-difference hierarchy.
Theorem 7.3. If the polynomial hierarchy does not collapse then the symmetric-difference hierarchy over L does not collapse.
Again the proof of the last result is relativizable and we immediately obtain that there is an oracle modulo which the
symmetric-difference hierarchy over L does not collapse. Some extensions of the symmetric-difference hierarchy and their
relation to other complexity classes were considered in [174].
7.5. Fine hierarchy
When one tries to classify not only isolated sets (representing decision problems) but sets from a class with some closure
properties (say, closed under propositional connectives on the corresponding unary predicates) one meets many natural
sets similar to the set D in the previous subsection which are not classifiable even in the symmetric-difference hierarchy. Of
course, one could try to refine the symmetric-difference hierarchy further, similarly to the previous sections.
Consider first the typed Boolean ‘‘hierarchy’’ {t(L)}t∈T∗over the ω-base L = {Σ
p
n+1}n where T ∗is the set of typed Boolean
terms. The collection of levels of this ‘‘hierarchy’’ extends that of the symmetric-difference hierarchy (see Section 3.4). It is
easy to show [120,126] that in this way we obtain reasonable complexity classes:
Proposition 7.4. All levels t(L) of the typed Boolean ‘‘hierarchy’’ over L are closed under the polynomial m-reducibility and
contain polynomially m-complete sets.
Levels of the typed Boolean ‘‘hierarchy’’ are closely related to the classification of some easily defined sets (like the set D
above). There are, nevertheless, some troubles with the typed Boolean ‘‘hierarchy’’. First, the non-collapse property of the
symmetric-difference hierarchy was not extended to the typed Boolean ‘‘hierarchy’’ so far because the proof of Theorem 7.3
in [120,126] depends heavily on the properties of the symmetric-difference operation and does not generalize automatically
to other Boolean operations. Currently we do not know whether any level t(L) is distinct from its dual. Second, the structure
of levels of the typed Boolean ‘‘hierarchy’’ under inclusion might turn out complicated. In particular, we do not know whether
the typed Boolean ‘‘hierarchy’’ is a hierarchy in the sense of this paper.
Let now {Sα}α<ε0 be the fine hierarchy over L defined as in Section 3.4. Then we obviously have
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
151
Proposition 7.5. (i) The fine hierarchy over L is a hierarchy in the sense of Section 3.4, and it is a global refinement of the
symmetric-difference hierarchy.
(ii) All levels of the fine hierarchy over L are closed under the polynomial m-reducibility.
Unfortunately, there are also troubles with the fine hierarchy. First, again we did not succeed in proving the non-collapse
property (under the assumption of the non-collapse property of the polynomial hierarchy) for the levels of the fine hierarchy
distinct from the levels of the symmetric-difference hierarchy. Second, without having the polynomially m-complete sets
in levels of the fine hierarchy its usefulness is doubtful. Currently we only know that there exists an oracle modulo which
all levels Sω+k+1, (k < 1), contain polynomially m-complete sets.
Of course, some of the mentioned difficulties are related to the fact that the non-self-dual levels of the polynomial
hierarchy does not have the reduction property unless PH collapses [50]. As we have already seen in some sections above,
without this property the properties of the fine hierarchy and the typed Boolean ‘‘hierarchy’’ become more complicated.
7.6. Hierarchy of k-partitions
Here we mention a couple of results on the difference hierarchy BHk(NP) of k-partitions over NP introduced and studied
in [75,86]. It is easy to show, similar to the corresponding fact about the typed Boolean ‘‘hierarchy’’, that any level of the
chain DH CBHk(NP) has a polynomially m-complete k-partition, and that any level of the poset DH BHk(NP) is closed under
the polynomial m-reducibility. The next fact extends the Kadin theorem to the chain classes.
Theorem 7.6 ([75,86]). If the polynomial hierarchy does not collapse then the chain DH of k-partitions over NP does not collapse,
i.e., for all finite k-chains P and Q , P ≤Q iff NPk(P) ⊆NPk(Q).
Concerning the relativized versions of BHk(NP), the following interesting separation result holds.
Theorem 7.7 ([75,86]). For all finite k-posets P and Q , if P ̸≤Q then there exists an oracle M such that NPM
k (P) ̸⊆NPM
k (Q).
7.7. Future work
As we have seen, some basic questions about the fine hierarchies in complexity theory remain open, even under
the assumption of the non-collapse of the polynomial hierarchy. We summarize some open questions below (under the
assumption that the PH does not collapse):
1. Is the poset ({t(L) | t ∈T ∗}; ⊆) well-founded? What is its width? Is any class t(L) distinct from its dual?
2. Does any level of the fine hierarchy over {Σ
p
n+1} contain a polynomially m–complete set? Are all levels distinct from
their duals?
3. Characterize the levels of the Boolean hierarchy of k-partitions over NP that have polynomially m-complete elements.
8. Automata on finite words
In this section we discuss some hierarchies and reducibilities arising in automata theory. Automata theory is an important
part of computer science with many deep applications. In fact, many results of this extensive field became already a part
of the information technology being realized in most of the existing hardware and software systems. At the same time,
automata theory remains an area of active research, with many long-standing open problems. The theory is naturally divided
in two parts devoted to the study of finite and infinite behavior of computing devices. In this section we consider the
finite behavior of finite automata which is captured by the notion of regular language, i.e. the set of words recognized by a
deterministic finite automaton (dfa). A positive feature of this field is that many important decision problems concerning
dfa’s are decidable (in contrast, say, with computability or complexity theory). Accordingly, much effort is devoted to finding
the optimal decision algorithms and to the complexity issues.
There are several well-established approaches to automata theory, among the most influential being the algebraic
approach [102] of Eilenberg, Schützenberger and many others (exploiting the deep connections of finite automata to finite
semigroups) and the logical approach of R. Büchi, R. McNaghton, S. Peipert [19,96] and many others (exploiting the deep
connections of finite automata to axiomatizability by logical sentences). Though both approaches would be possible for
describing most of the further material, we use mainly the logical approach because it is better related to other sections of
this paper.
Hierarchies in automata theory (in particular, the Brzozovski’s dot-depth hierarchy) were introduced in the 1970-s in
terms of the Kleene regular expressions. In [164] a characterization of the dot-depth hierarchy as a logical quantifier-
alternation hierarchy was obtained. Later similar facts were established for other natural hierarchies. This makes these
hierarchies similar to the hierarchies of sentences in Section 2.1, only this time one considers sentences modulo equivalence
in finite models of a theory. More recently, people began to consider also fine hierarchies of regular languages [147,149,51,
128,136,145] and reducibilities inducing nontrivial degree structures on the regular sets [10,167,158,48,136,145].
152
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
8.1. Preliminaries
We assume the reader to be familiar with the standard notions and facts of automata theory which may be found e.g. in
[162,105]. If not stated otherwise, A denotes some finite alphabet with at least two letters. Let A∗and A+ be the sets of finite
(respectively, of finite non-empty) words over A. Sets of words are called languages. In this section we mainly use the logical
approach to the theory of regular languages. This is the reason why we mostly deal with subsets of A+ (they correspond
to the non-empty structures, the empty structure is excluded because dealing with it in logic is not usual). With suitable
changes analogs of the results below hold also for the subsets of A∗.
By automaton (over A) we mean a triple M = (Q, A, f ) consisting of a finite non-empty set Q of states, the input alphabet
A and a transition function f : Q × A →Q . The transition function is naturally extended to the function f : Q × A∗→Q
defined by induction f (q, ε) = q and f (q, u·x) = f (f (q, u), x), where ε is the empty word, u ∈A∗and x ∈A. A word acceptor
is a triple (M, i, F) consisting of an automaton M, an initial state i of M and a set of final states F ⊆Q . Such an acceptor
recognizes the language L(M, i, F) = {u ∈A∗| f (i, u) ∈F}. Languages recognized by such acceptors are called regular.
Relate to any alphabet A = {a, . . .} the signatures ϱ = {≤, Qa, . . .} and σ = {≤, Qa, . . . , ⊥, ⊤, p, s}, where ≤is a binary
relation symbol, Qa (for any a ∈A) is a unary relation symbol, ⊥and ⊤are constant symbols, and p, s are unary function
symbols. A word u = u0 . . . un ∈A+ may be considered as a structure u = ({0, . . . , n}; <, Qa, . . .) of signature σ , where <
has its usual meaning, Qa(a ∈A) are unary predicates on {0, . . . , n} defined by Qa(i) ↔ui = a, the symbols ⊥and ⊤denote
the least and the greatest elements, while p and s are respectively the predecessor and successor functions on {0, . . . , n}
(with p(0) = 0 and s(n) = n).
For a sentence φ of σ , set Lφ = {u ∈A+ | u |= φ}. Sentences φ, ψ are treated as equivalent when Lφ = Lψ. A language
is FOσ -axiomatizable if it is of the form Lφ for some first-order sentence φ of signature σ . Similar notions apply to other
signatures in place of σ . It is well-known (see e.g. [96,163,155,103,105]) that the class of FOσ -definable languages (as well
as the class of FOϱ-definable languages) coincides with the important class of regular aperiodic languages which are also
known as star-free languages.
We will discuss also some enrichments of the signature σ. Namely, for any positive integer d let τd be the signature
σ ∪{P0
d, . . . , Pd−1
d
}, where Pr
d is the unary predicate true on the positions of a word which are equivalent to r modulo d. By
FOτd-definable language we mean any language of the form Lφ, where φ is a first-order sentence of signature τd. Note that
signature τ1 is essentially the same as σ because P0
1 is the valid predicate. In contrast, for d > 1 FOτd-definable languages
need not be aperiodic. E.g., the sentence P1
2(⊤) defines the language L consisting of all words of even length which is known
to be non-aperiodic. We are also interested in the signature τ = S
d τd.
It is known [155,136,145] that the class FOτ (FOτd) coincides with the class of so called regular quasi-aperiodic
(respectively, d-quasi-aperiodic) languages. In [36,145] it was observed that FOτ = S
d FOτd. Note that the set of quasi-
aperiodic regular languages is a proper subset of the set of regular languages. An example of regular non-quasi-aperiodic
language is the language over {a, b} consisting of all words with an even number of entries of a.
It is easy to see that, for any fixed d > 0, the non-empty words correspond bijectively to the (isomorphism types of)
finite models of the theory CLOτd (CLO stand for ‘‘colored linear order’’) of signature τd with the following axioms:
- < is a linear order,
- any element satisfies exactly one of the predicates Qa (a ∈A),
- ∀x(⊥≤x ≤⊤),
- ∀x(p(x) ≤x ∧¬∃y(p(x) < y < x)),
- ∀x(x ≤s(x) ∧¬∃y(x < y < s(x))),
- ∀x(x > ⊥→p(x) < x),
- ∀x(x < ⊤→x < s(x)),
- P0
d(⊥),
- any element satisfies exactly one of the predicates P0
d, . . . , Pd−1
d
,
- ∀x < ⊤(Pr
d(x) →Pr+1
d
(s(x))) for 0 ≤r < d −1,
- ∀x < ⊤(Pr−1
d
(x) →P0
d(s(x))).
8.2. Bases and reducibilities
We denote by Σσ
n the class of languages that can be axiomatized by a Σ0
n -sentence of σ. The classes Σϱ
n are defined
analogously with respect to ϱ. We also use the standard Π- and ∆-notation from the hierarchy theory. There is a levelwise
correspondence of these classes to the well-known concatenation hierarchies of automata theory. Namely, the classes Σϱ
n
and BC(Σϱ
n ) coincide with the classes of the Straubing–Thérien hierarchy [104], while classes Σσ
n and BC(Σσ
n ) coincide with
the classes of the dot-depth hierarchy [164].
The notation above applies also to the signatures τd and τ from the previous subsection. In [145] it was observed that
Στ
n = S
d Στd
n
for each n > 0, where Σn with an upper index denotes the class of regular languages axiomatized by
Σn-sentences of the corresponding signature in the upper index. For any signature θ as above, we call the corresponding
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
153
quantifier-alternation hierarchy θ-hierarchy. As follows from the well-known facts from logic, the ϱ-, σ -, τd- and τ-
hierarchies are ω-bases. It is known [164,136] that all these hierarchies do not collapse. These ω-bases are the starting
point for the subsequent discussion of the fine hierarchies of regular languages.
Unfortunately, the introduced ω-bases are probably not reducible. In [149] it was shown that none of the classes Σϱ
n , Πϱ
n ,
Σσ
n , Πσ
n has the reduction property, for each n > 0. In [149,158,136] it was shown that the classes Σϱ
1 , Σϱ
2 , Σσ
1 , Στd
1
(for
each d > 0) and Στ
1 have the separation property.
In [158] the reducibility by quantifier-free formulas of signature σ was introduced and studied. Here we define a
generalization of this notion from [136,145] to the signature τd for any fixed d > 0. A qf τd-interpretation I over alphabets
A = {a, . . .} and B = {b, . . .} is given by a tuple
(φU(¯x), φ<(¯x, ¯y), φ⊥(¯x), φ⊤(¯x), φS(¯x, ¯y), φb(¯x), . . . , φr
d(¯x))
where ¯x = (x1, . . . , xn) and ¯y = (y1, . . . , yn) are sequences of different variables of the same length n > 0 (n is fixed in
advance) and φU(¯x), . . . , φr
d(¯x) are quantifier-free formulas of τ A
d with the following properties. Let u = u0 · · · ul be any
word over A of length |u| = l + 1. Then the set T = {¯x ∈{0, . . . , l}n|u |= φU(¯x)} should be non-empty and the formulas
φ<(¯x, ¯y), φ⊥(¯x), φ⊤(¯x), φS(¯x, ¯y)), φb(¯x), . . . , φr
d(¯x) interpreted in u should define a model of CLOτd B with the universe T
(the formulas φ⊥(¯x), φ⊤(¯x) should be true exactly on the first and the last element, respectively). Since the finite models of
CLOτd B are in a bijective correspondence with elements of B+, any qf τd-interpretation I induces a function u 7→uI from A+
into B+.
Examples. 1. Let φU(¯x) be a valid formula, let φ<(¯x, ¯y) define the lexicographic ordering between ¯x and ¯y, let
φ⊥(¯x), φ⊤(¯x), φS(¯x, ¯y) be defined in the obvious way according to their intended interpretations, and let φb(¯x, . . .), φr
d(¯x)
be chosen in a way to get a model of CLOτd B on this ordering. Then uI is of length |u|n, and letters of the word uI are easily
computed from the interpretation. Note that u 7→uI is a plt-function.
2. Let φU(x) be a valid formula of one variable x, let φ<(x, y) be x > y, let φa(x) be Qa(x) for any a ∈A, let φ⊥(¯x), φ⊤(¯x)
be x = ⊤, x = ⊥respectively, and let φS(x, y) be S(y, x). Let φr
d(¯x) be defined in the obvious way to satisfy the axioms of
CLOτd. Then we obtain a qf τd-interpretation I over A and A such that uI is the reverse of the word u ∈A+. Note that u 7→uI
is a plt-function.
3. Let u 7→pu be the function on A+ which adds a fixed prefix p ∈A∗to a word u. Is there a qf τd-interpretation I over
A and A such that uI = pu for any u? For p = ε the answer is of course positive, otherwise it is negative (since any qf τd-
interpretation sends words of length 1 to words of length 1). But it is easy to see that there is a qf τd-interpretation I such
that uI = pu for any u of length > 1. The same of course applies to the operation of adding a suffix to a word.
4. For any semigroup morphism h : A+ →B+ with the property ∀a, b ∈A(|h(a)| ≡|h(b)| (mod d)) there is a qf τd-
interpretation I over A and B such that uI = h(u) for almost all u ∈A+ (i.e. for all but finitely many words).
Definition 8.1. A function f : A+ →B+ is called qf τd-function if there is a qf τd-interpretation I over A and B such that
uI = f (u) for almost all u ∈A+. qf τd-Reducibility is the m-reducibility by qf τd-functions.
In [158,136,145] it was shown that these reducibilities have quite natural properties, in particular for any d > 0 the qf τd-
reducibility fits the τd-hierarchy. The first impression is that these reducibilities are related by inclusion for the different
moduli d but actually for all distinct d, e > 0, the qf τd-reducibility is incomparable with the qf τe-reducibility [145]. It
is also possible to find reducibilities that fit the ϱ- and τ-hierarchies but we will not discuss them in this paper. Please
note the essential difference from (some of) the preceding sections where we had one notion of m-reducibility that fits all
hierarchies we have discussed. In contrast, in this section we have different reducibilities for the different bases (and for the
fine hierarchies over these bases).
8.3. Difference hierarchies
Here we briefly discuss the DH’s {Σθ
n (m)}m over any level of the θ-hierarchy, for the signatures θ introduced above. All
these DH’s do not collapse [147,149,136,145] which is proved by introducing suitable alternating-chain invariants for all
levels in terms of some Ehrenfeucht–Fraisse games. By [158,136,145], the DH’s for the signatures τd fit the qf τd-reducibility.
Moreover, the DH over Στd
1 is qf τd-discrete by [145] and Proposition 3.6. As usual, the discreteness does not hold anymore
for the DH’s over Στd
n for n ≥2.
Next we would like to discuss the problem of decidability of levels of the DH’s (given an acceptor M, decide whether
L(M) belongs to a given level). Currently, decidability is known only for levels of the DH over the first levels of the quantifier-
alternation hierarchies and a couple of close classes.
An especially easy proof may be provided for the DH over Σϱ
1 . In this case it is possible to find a natural well poset related
to this hierarchy exactly as in Section 3.1. Namely, define a partial order on A+ as follows: u ⊆v, if u is embeddable into v. By
a well-known result of G. Higman, (A+; ⊆) is a well poset. Moreover, it is easy to see that Σϱ
1 coincides with the class of upper
sets in this well poset. By Proposition 3.4, Σϱ
1 (n) coincides with the class of sets that have no 1-alternating chains of length n
in (A+; ⊆). This (along with several other related facts) was observed in [153,51,128]. This result implies decidability of any
level Σϱ
1 (n) as follows (our proof here is shorter than those in [51,128]). Since the computable sets coincide with the level ∆0
1
of the arithmetical hierarchy, it suffices to show that the relation ‘‘L(M) ∈Σϱ
1 (n)’’ is in both Σ0
1 and Π 0
1 . By definition, L(M)
154
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
is in Σϱ
1 (n) iff there is a sentence φ of signature ϱ such that φ is a certain Boolean combination of n existential sentences
and L(M) = Lφ. Since the last relation is computable, the relation ‘‘L(M) ∈Σϱ
1 (n)’’ is in Σ0
1 . Furthermore, L(M) ̸∈Σϱ
1 (n)
iff there is an 1-alternating chain for L(M) of length n. The last characterization shows that the relation ‘‘L(M) ̸∈Σϱ
1 (n)’’ is
in Σ0
1 . Thus, the relation ‘‘L(M) ∈Σϱ
1 (n)’’ is computable. This illustrates the usefulness of the method of alternating chains.
The method implies several other decidability results of this type, though sometimes more sophisticated characterizations
are needed.
We illustrate one such more sophisticated characterization by sketching a result in [51] about the classes Σσ
1 (n). In this
case it seems impossible to find a well partial order on words with the properties like those in the previous paragraph.
Instead, it is possible to relate effectively to any acceptor M a computable well poset (P; ≤M) (of the so called structured
words) and a computable surjection f : P →A+ such that L(M) ∈Σσ
1 (n) iff f −1(L(M)) has no 1-alternating chains of
length n in (P; ≤M). By a version of the argument above, the relation ‘‘L(M) ∈Σσ
1 (n)’’ is computable. A similar argument
applies to the DH over Στd
1 for each d ≥1 [136,145].
As usual, after proving decidability of a natural problem one is interested in its complexity. There are many papers in
which exact complexity estimations of the problems similar to those discussed here are found. We do not describe them
here systematically because it is not directly related to the topic of this paper. We give only the following examples: for any
n > 0, the relation ‘‘L(M) ∈Σϱ
1 (n)’’ is NL-complete w.r.t. deterministic logarithmic space m-reductions [157] while the
relation ‘‘L(M) ∈FOϱ’’ is PSPACE-complete [24]. Recently, similar results were obtained for signature τd in place of ϱ [52].
Interestingly, the proof of NL-upper bound requires a new characterization of Στd
1 (n) in terms of alternating chains which
is crucial for the formulation of deciding algorithm working in nondeterministic logarithmic space.
8.4. Fine hierarchy
Here we mention a couple of known facts about other fine hierarchies of regular languages. E.g., it may be shown that the
symmetric-difference hierarchy over the ω-base {Σσ
n+1} does not collapse (see the next subsection for details). By [158,136],
most levels of the typed Boolean ‘‘hierarchies’’ over the ω-bases {Στd
n+1} have a qf τd-complete sets. Since these bases (and
other bases discussed above) are not reducible, the order of the levels of the typed Boolean ‘‘hierarchies’’ under inclusion
may be non-trivial. And indeed, in [149] it was shown there are three pairwise incomparable levels of the typed Boolean
‘‘hierarchy’’ over {Σσ
n+1}.
8.5. Relation to complexity theory
The subject of this section is obviously related to Section 5. In a sense the both sections consider the same hierarchies,
only here we deal only with the finite models of sentences while in Section 5 with arbitrary models. Less obvious is the close
relation of this section to complexity theory which we briefly discuss here. For a comprehensive survey see [175].
Consider a polynomial-time nondeterministic Turing machine M working on an input word x over some alphabet B
and printing a letter from another alphabet A after finishing any computation path. The printed letters from A are on the
leaves of the binary tree defined by the nondeterministic choices of M on input x. An order of the tuples in the program
of M determines a left-to-right order of all the leaves. In this way, M may be considered as a deterministic transducer that
computes a total function M : B∗→A+. Now, relate to any language L ⊆A+ (called in this situation a leaf language)
the language M−1(L) ⊆B∗. Denote by Leafb(L) the set of languages M−1(L), for all machines M specified above which have
balanced (in some natural sense, see [175] for details) computation trees, and denote by Leafu(L) the set of languages M−1(L),
for all machines M specified above (which may have unbalanced computation trees). Obviously, we have Leafb(L) ⊆Leafu(L)
for every language L, and there exist languages L where Leafb(L) = Leafu(L) is unlikely. For a class of languages C, set
Leaf(C) = S{Leaf(L) | L ∈C}. When we write a formula containing Leaf without a subscript we mean that the formula
holds for both Leafb and Leafu.
It turns out that many important complexity classes have natural and useful characterizations in terms of leaf languages
(see e.g. [10,167,67,17,68,69]). In particular, a close relationship between some classes of regular leaf languages and
complexity classes within PSPACE was established in [67], e.g. we have Leaf(R) = PSPACE and Leaf(A) = PH where
R and A are the classes of regular and regular aperiodic languages, respectively. In [20], a close relationship between
some hierarchies discussed here and the polynomial hierarchy was established: Leaf(Σϱ
n ) = Leaf(Σσ
n ) = Σ
p
n, for each
n > 0 (this result extends also to the ∆-levels [16]). The last result was extended in [130] (for the unbalanced mode) to all
levels of the typed Boolean ‘‘hierarchies’’ over the ω-bases {Σϱ
n+1} and {Σ
p
n+1}. In particular, this applies to all levels of the
symmetric-difference hierarchies over these ω-bases. Moreover, these results holds uniformly on the oracle (if we take the
non-deterministic oracle machines in the above description of the leaf-language definability).
What is the aim of proving results of this kind? In my opinion, the existence of nontrivial connections between automata-
theoretic and complexity-theoretic hierarchies is interesting in its own right and is somewhat unexpected. Moreover,
sometimes results of this type may be even of use. E.g., assume for a moment that the ϱ-hierarchy collapses. By a result
above, the polynomial hierarchy would then collapse too. This is of course unlikely, hence the ϱ-hierarchy should not
collapse. This may be turned to the exact proof if we take into account that the polynomial hierarchy does not collapse
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
155
modulo a suitable oracle, and the results above are relativizable. Thus, the non-collapse of the ϱ-hierarchy follows from a
known fact of complexity theory. Similarly, Theorem 7.3 and a result above implies that the symmetric-difference hierarchy
over {Σϱ
n+1} does not collapse.
We conclude this subsection by mentioning a very relevant reducibility introduced in [10] and independently in [167].
Definition 8.2. (i) A language L ⊆A∗is polylogtime reducible to K ⊆B∗, for short L ≤plt K , if there exist functions
f : A∗× N →B and g : A∗→N, computable in polylogarithmic time (on a deterministic Turing machine which treats the
input word as an oracle) such that x ∈L ↔f (x, 1)f (x, 2) . . . f (x, g(x)) ∈K for every x ∈A∗.
(ii) By plt-function we mean any function of the form x 7→f (x, 1)f (x, 2) . . . f (x, g(x)) where f and g are computable in
polylogarithmic time.
Examples. 1. The function u 7→pu on A+ which adds a fixed prefix p ∈A∗to a word u is a plt-function. The same of course
applies to the operation of adding a suffix to a word.
2. Let h : A+ →B+ be a semigroup morphism. Such functions are defined by their values h : A →B+ on the letters of A
(i.e., words of length 1) because we have h(a0 · · · al) = h(a0) · · · h(al), where ai ∈A. It is easy to see that any such function
h with the property ∀a, b ∈A(|h(a)| = |h(b)|) is a plt-function.
The following result from [10,167] relates plt-reducibility to the balanced version of leaf language definability.
Theorem 8.3. For all languages L and K, L ≤plt K iff Leafb(L)O ⊆Leafb(K)O for all oracles O.
Though plt-reducibility does not fit any hierarchy discussed in this section, it is very relevant to the qf τd-reducibilities,
in particular any level of the τd-hierarchy (for each d > 0) has a plt-complete set [136]. The classes of regular aperiodic and
quasi-aperiodic languages may be characterized in the complexity-theoretic terms [175,136] as follows: a regular language
L is aperiodic iff Leafu(L)O ⊆PHO for all oracles O; a regular language L is quasi-aperiodic iff Leafb(L)O ⊆PHO for all
oracles O.
In [175] a notion of reducibility (called ptt-reducibility) was introduced which is related to the unbalanced leaf language
definability in exactly the same way as in Theorem 8.3. In [14,136,145] exact characterizations of NP in terms of regular leaf
languages were obtained. Some non-trivial initial segments of the qf τd-degrees were characterized in [158,136,145]. For
more results in this direction see [158,136,175,48,49,145].
8.6. Future work
The most challenging open problem related to this section is the problem of decidability of levels of the hierarchies
discussed above. In fact, already the decidability questions for BC(Σϱ
2 ) and Σϱ
2 (2) are open.
There are many interesting open questions about the reducibilities considered above. Sometimes we formulate them in
the form of conjectures.
Conjecture 1. The relations ≤plt and ≤qfτd are decidable on the regular languages. This means (for ≤qfτd) that there exists an
algorithm which decides, given dfa’s recognizing the languages L and M, whether L ≤qfτd M.
This conjecture seems very hard because (together with the completeness results above) implies the decidability of all
levels of the σ -hierarchy which is a long-standing open question of automata theory. One could weaken the Conjecture 1 in
different ways to get less hard problems, e.g.
Conjecture 2. The relations ≤plt and ≤qfτd are decidable on BC(Σσ
1 ).
The last conjecture seems rather plausible (though not easy to prove!) because in [51,128] the decidability of several
natural problems related to BC(Σσ
1 ) was established.
Many natural questions on the introduced degree structures also remain open, e.g. is there an infinite antichain or an
infinite descending chain within (BC(Σσ
1 ); ≤qfτd)? Investigation of the initial segments of these degree structures seems
also interesting.
We would like to see more work on the fine hierarchies and the hierarchies of k-partitions over the bases and ω-bases
discussed in this section.
9. Automata on infinite words
Investigation of the infinite behavior of computing devices is of great interest for computer science because many
hardware and software concurrent systems (like processors or operating systems) may not terminate. In many cases, the
infinite behavior of a device is captured by the notion of ω-language recognized by the device. The most basic notion of this
field is that of regular ω-languages, i.e. ω-languages recognized by finite automata. Regular ω-languages play an important
role in the theory and technology of specification and verification of finite state systems. They are also important for the
synthesis problem asking for an efficient construction of a system satisfying a given specification [22].
Regular ω-languages were introduced by J.R. Büchi in the 1960-s and studied by many people including B.A. Trakhtenbrot,
R. McNaughton and M.O. Rabin. The subject quickly developed into a rich topic with several deep applications. Much
156
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
information and references on the subject may be found e.g. in [162,165,166,151,173,105]. We assume acquaintance with
some basic concepts, notation and results in this field, all of them may be found in the cited sources.
One branch of the discussed topic deals with the classifications of regular ω-languages by means of topology, hierarchies
and reducibilities. A series of papers culminated with the paper [173] giving, in a sense, the finest possible classification.
In [121,123,125] the Wagner hierarchy of regular ω-languages was related to the Wadge hierarchy and to the author’s fine
hierarchy. This provided new proofs of results in [173] and yielded some new results on the Wagner hierarchy. See also an
alternative algebraic approach [26,27,31,21]. Later some results from [173,125] were extended to other computing devices
[32,131,98,46,29,140].
9.1. Preliminaries
For a finite alphabet A, let A∗and Aω denote respectively the sets of all words and of allω-words (i.e. sequencesα : ω →A)
over A. We use some almost standard notation concerning words and ω-words, so we are not too casual in reminding it
here. For w ∈A∗and α ∈A∗∪Aω, w ⊆α means that w is the substring of α, w · α = wα denote the concatenation,
l = |w| is the length of w = w(0) · · · w(l −1). For w ∈A∗, W ⊆A∗and L ⊆A∗∪Aω, let w · L = {wα | α ∈L} and
W · L = {wα | w ∈W, α ∈L}. For k, l < ω and α ∈A∗∪Aω, let α[k, l] = α(k) · · · α(l −1) and α[k] = α[0, k]. Our notation
does not distinguish a word of length 1 and the corresponding letter.
By initial automaton (over A) we mean a tuple (Q, A, f , i) consisting of a dfa (Q, A, f ) and an initial state i ∈Q . The
transition function f is naturally extended to the function f
: Q × A∗→Q defined by induction f (q, ε) = q and
f (q, u · x) = f (f (q, u), x), where u ∈A∗and x ∈A. Similarly, we may define the function f : Q × Aω →Q ω by
f (q, ξ)(n) = f (q, ξ[n]). Relate to any initial automaton M the set of cycles CM = {fM(ξ) | ξ ∈Aω} where fM(ξ) is the
set of states which occur infinitely often in the sequence f (i, ξ) ∈Q ω. Note that in this section we consider mainly dfa’s.
A Muller acceptor has the form (M, F ) where M is an initial automaton and F ⊆CM; it recognizes the set L(M, F ) =
{ξ ∈Xω | fM(ξ) ∈F }. It is well known that Muller acceptors recognize exactly the regular ω-languages called also just
regular sets. The class R of all regular ω-languages is a proper subclass of BC(60
2) that in turn is a proper subclass of 10
3.
Next we define aperiodic regular ω-languages. This important class of sets has several characterizations, in particular as:
languages of ω-words axiomatized by first-order sentences of a natural signature, as in the previous section for the finite
words; languages of ω-words satisfying a formula of linear time temporal logic; languages recognized by aperiodic acceptors
[96,163,165,166]. We take the last characterization as the definition here: an automaton M = (Q, X, f ) is aperiodic if for
all q ∈Q , u ∈A+ and n > 0 the equality f (q, un) = q implies f (q, u) = q. It is clearly equivalent to say that for all q ∈Q
and u ∈A+ there is m < ω with f (q, um+1) = f (q, um). An acceptor (or a transducer) is aperiodic if so is the corresponding
automaton. A regular ω-language is aperiodic if it is recognized by an aperiodic Muller acceptor. The class of regular aperiodic
ω-languages is denoted A.
Next we define functions computed by dfa’s. A synchronous transducer (over alphabets A, B) is a tuple T
=
(Q, A, B, f , g, i), also written as T = (M, B, g, i), consisting of an automaton M, an initial state i and an output function
g : Q × A →B. The output function is extended to the function g : Q × A∗→B∗defined by induction
g(q, ε) = ε,
g(q, u · x) = g(q, u) · g(f (q, u), x),
and to the function g : Q × Aω →Bω defined by
g(q, ξ) = g(q, ξ(0)) · g(f (q, ξ(0)), ξ(1)) · g(f (q, ξ[0, 2)), ξ(2)) · · · .
In other notation, g(q, ξ) = limng(q, ξ[n]). The transducer T computes the function gT : Aω →Bω defined by gT (ξ) =
g(i, ξ). If the output function is of the form g : Q →B (i.e., does not really depend on the second argument), then T is called
delayed synchronous transducer.
Asynchronous transducer (over alphabets X, Y) is defined as a synchronous transducer with only one exception: this time
the output function g maps Q × A into B∗. As a result, the value g(q, ξ) defined as above is in B≤ω, and the function gT maps
Aω into B≤ω. Nevertheless, we usually consider the case when gT maps Aω into Bω; this condition is easily characterized in
terms of T .
Functions computed by synchronous (asynchronous, aperiodic synchronous, aperiodic asynchronous) transducers are
called DS-functions (respectively, DA-functions, AS-functions and AA-functions). Following [173], for the case of uniformity
we call continuous functions CA-functions and continuous synchronous functions (defined in the obvious way) — CS-
functions. The delayed versions of the synchronous notions are defined similarly. As is well known, all introduced classes of
functions are closed under composition, any AA-function is a DA-function, any DA-function is a CA-function, and similarly
for the synchronous versions.
We proceed with some relevant information on the Gale-Stewart games. Let A, B be some alphabets. Relate to any set
L ⊆(A × B)ω the Gale-Stewart game G(L) played by two opponents 0 and 1 as follows. Player 0 chooses a letter x0 ∈A, then
player 1 chooses a letter y0 ∈B, then 0 chooses x1 ∈A, then 1 chooses y1 ∈B and so on. Each player knows all the previous
moves. After ω moves, 0 has constructed a word ξ = x0x1 · · · ∈Aω while 1 has constructed a word η = y0y1 · · · ∈Bω.
Player 1 wins this particular play if ξ × η = λn.(ξ(n), η(n)) ∈L, otherwise 0 wins.
A strategy for player 1 (0) in the game G(L) is a function h : A+ →B (respectively, h : B∗→A) that prompts the 1’s move
(respectively, the 0’s move) for any finite string of the opponent’s previous moves. It is clear that strategies for 1 (for 0) are
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
157
in a bijective correspondence with CS-functions h : Aω →Bω (respectively, with delayed CS-functions h : Bω →Aω); we
identify strategies with the corresponding CS-functions.
A strategy h for player 1 (0) in the game G(L) is winning if the player wins each play when following the strategy, i.e. if
ξ × h(ξ) ∈L for all ξ ∈Aω (respectively, h(η) × η ∈L for all η ∈Bω). A set L ⊆(A × B)ω is determined if one of the players
has a winning strategy in G(L). It is interesting and useful to know which sets are determined and, in case of determinacy,
how complicated it is to compute the winner and how complicated is his winning strategy.
By the Martin determinacy theorem (see Section 4.1), any Borel set L ⊆(A×B)ω is determined. Note that, since any regular
set is Borel, this implies the determinacy of regular sets. One of the best results of automata theory is the Büchi-Landweber
regular determinacy theorem [15] stating that for any regular set A the winner in G(A) may be computed effectively, (s)he
has a winning strategy which is a DS-function, and the strategy is also computed effectively. In [140] we have established
the following aperiodic version of the Büchi-Landweber theorem: For any regular aperiodic set L ⊆(A × B)ω, the winner of
the game G(L) may be computed effectively, (s)he has a winning strategy which is an AS-function, and the strategy is also
computed effectively. In [108] some other ‘‘restricted versions’’ of the Büchi-Landweber theorem were established. Such
results are closely related to the synthesis problem mentioned above.
We conclude this subsection by citing some facts from [34,151] about the infinite behavior of some computing devices
more complicated than dfa’s, like push-down automata or Turing machines. Any such device M equipped with the Muller
accepting condition recognizes the ω-language L(M) (note that the Muller condition makes sense for such devices because
the set of inner states is always finite). As observed in [34], if M is deterministic then L(M) ∈BC(60
2), i.e. L(M) is
topologically not very complicated. By [151], the class of languages recognized by deterministic Turing machines coincides
with BC(Σ0
2) (the lightface version!). For non-deterministic devices M, the topological complexity might be much higher.
The reason is that there are up to continuum many runs of M on an input ω-word ξ, and ξ is (by definition) accepted if
there is a run on ξ such that the set of inner states of M visited infinitely often in this run belongs to the class F of sets of
states specified by the Muller condition. By [151], the class of languages recognized by non-deterministic Turing machines
coincides with the level Σ1
1 of the analytical hierarchy. Thus, levels of the effective hierarchies from Section 6 are relevant
to characterizing the infinite behavior of computing devices.
9.2. Bases and reducibilities
For this section the following 2-bases are the most interesting: the 2-base (L0, L1) where Ln = R ∩60
n+1 is the class of
regular 60
n+1-sets, n < 2, and the 2-base (K0, K1) where Kn = A ∩60
n+1 is the class of regular aperiodic 60
n+1-sets, n < 2.
It is easy to see that Ln = R ∩Σ0
n+1 and Kn = A ∩Σ0
n+1, i.e. the classical and effective Borel hierarchies work equally well
in this section. Note that it does not make big sense to consider the classes Ln and Kn for n ≥2 because, as is well-known,
R = BC(L1) and A = BC(K1).
By [156], BC(L0) = L1 ∩co-L1 and, by [140], BC(K0) = K1 ∩co-K1. By [125,140], all classes L0, L1, K0, K1 have the
reduction property. Hence, the 2-bases (L0, L1) and (K0, K1) are reducible and interpolable, in the sense of Section 2.10.
We will consider four reducibilities on ω-languages. Namely, let ≤CA, ≤m ≤DA and ≤AA be the m-reducibilities by the
CA-, computable, DA- and AA-functions, respectively. Obviously, CA-reducibility is just the Wadge reducibility but we use
here the other notation in order to stress the analogy with the two other reducibilities. The Wadge reducibility is natural
from the topological point of view but it does not correspond to the constructive nature of dfa’s. The class R is of course
not closed under the Wadge reducibility, and hence the 2-bases do not fit the Wadge reducibility. By [173], R is closed
under DA-reducibility and the 2-base (L0, L1) fits the DA-reducibility. Similarly, the CA-, m- and DA-reducibilities do not
correspond well enough to the regular aperiodic sets, i.e. the class A is not closed under these reducibilities. By [140], A is
closed under AA-reducibility and the 2-base (K0, K1) fits AA-reducibility.
It is easy to see that the corresponding degree structures (under all four reducibilities) are upper semilattices. The
operation of least upper bound is induced by the operation ⊕from Section 4.1. The same applies to the case of k-partitions
of the Cantor space.
Note that in [173,125,140] also the synchronous versions of the above-mentioned reducibilities were considered.
Although they are quite interesting and closely related to the Gale-Stewart games we do not discuss them below, in order
to keep the text more coherent.
9.3. Difference hierarchies
Here we discuss the difference hierarchies over the bases L0, L1, K0, K1. For a Muller acceptor (M, F ), define [173] a
preorder ≤0 and a partial order ≤1 on the set of cycles CM as follows: U ≤1 V, if U ⊇V, and U ≤0 V, if for any q ∈U there
exists a w ∈X∗with f (q, w) ∈V. Note that (CM; ≤0, ≤1) is a 2-preorder in the sense of Section 3.4.
Theorem 9.1 ([173]). Let n < ω and let (M, F ) be a Muller acceptor recognizing the language L.
(i) L ∈60
1(n) iff F has no 1-alternating chains of length n in (CM; ≤0).
(ii) L ∈60
2(n) iff F has no 1-alternating chains of length n in (CM; ≤1).
158
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
An immediate corollary of the last result is the decidability of all levels of the DH’s over L0 and L1. The next result
characterizes the Boolean closures of L0 and K0.
Theorem 9.2. (i) [156] Any regular 10
2-set is a Boolean combination of open regular sets, i.e. L1 ∩co-L1 = BC(L0) = R ∩10
2.
(ii) [140] Any regular aperiodic 10
2-set is a Boolean combination of open regular aperiodic sets, i.e. K1 ∩co-K1 = BC(K0) =
A ∩10
2.
9.4. Symmetric difference hierarchy
In [172,173] the following invariants for the Muller acceptors were introduced.
Definition 9.3. (i) A chain for a Muller acceptor (M, F ) is a sequence U0 ⊆· · · ⊆Um of elements of CM such that Ui ∈F
iff Ui+1 ̸∈F . The number m + 1 is the length of this chain.
(ii) A chain as above is a −chain (a+ chain), if U0 ̸∈M (resp. U0 ∈M).
The next notion is an evident variation of the corresponding notion from [172,173].
Definition 9.4. (i) A superchain of type (m, n) for a Muller automaton (M, F ) is a sequence (C0, . . . , Cn) of chains of length
m + 1 for (F , M) such that Ci is a−chain iff Ci+1 is a+ chain.
(ii) A superchain as above is a−superchain (a+ superchain), if C0 is a−chain (resp. a+ chain).
For any m, n < ω, let C(m, n) be the class of sets L(M, F ) where F have no +-superchain of type (m, n). In [172,173] it
was shown that the family of classes C(m, n) (called the coarse structure) is well ordered with the order type ω2. In [125] it
is shown that the coarse structure essentially coincides with the symmetric-difference hierarchy over the 2-base (L0, L1).
To understand the reason, compare the superchains with the alternating chains of type ((1, m), (0, n)) in Section 3.3 and
take into account Theorem 9.1.
9.5. Fine hierarchy
Here we discuss the fine hierarchies {Rα}α<ωω and {Aα}α<ωω over the 2-bases (L0, L1) and (K0, K1), respectively.
Recall from Section 3.4 that definition (say, for the 2-base (K0, K1)) may look as follows:
Definition 9.5. The fine hierarchy over (K0, K1) is the sequence {Aα}α<ωω defined by induction as follows:
An = Dn(K0) for n < ω;
Aωn = Dn(K1) for 0 < n < ω;
Aβ+ωn = bisep(K0, Aβ, co-Aβ, Aωn) for 0 < n < ω and β = ωn · β1 for some β1, 0 < β1 < ωω;
Aβ+1 = bisep(K0, Aβ, co-Aβ, A0) for ω ≤β < ωω.
Since the 2-bases (L0, L1) and (K0, K1) are reducible, both fine hierarchies coincide with the corresponding typed
Boolean hierarchies by Theorem 3.17. Since the 2-bases are interpolable, both fine hierarchies are perfect in all limit level.
Moreover, it turns out that the fine hierarchy over (L0, L1) (over (K0, K1)) perfectly fits the DA-reducibility (respectively,
AA-reducibility). We formulate the last fact explicitly.
Theorem 9.6 ([173,125]). There exist regular ω-languages Aα, α < ωω such that:
(i) For any α < ωω, Aα ̸≤DA Aα.
(ii) For all α < β < ωω, Aα ⊕Aα <DA Aβ.
(iii) Any regular ω-language is DA-equivalent to one of the sets Aα, Aα, Aα ⊕Aα (α < ωω).
(iv) For any α < ωω, Aα is DA-complete in Rα and Aα ⊕Aα is DA-complete in Rα ∩co-Rα.
In [140] it was shown that the sets Aα in the last theorem may be chosen aperiodic, and they also satisfy the same
properties with Aα in place of Rα and AA-reducibility in place of DA-reducibility. In particular, the structures (R; ≤DA)
and (A; ≤AA) are almost well-ordered with the corresponding ordinal ωω. By Section 2.9, both fine hierarchies have no
non-trivial refinements that fit the corresponding reducibilities.
We have also the following corollary of the determinacy results stated in Section 9.1. It shows deep interconnections
between the the above-introduced reducibilities and hierarchies with the fine hierarchy {Sα} over {60
n+1}n<ω from
Section 4.4 and the fine hierarchy {Σα} over {Σ0
n+1}n<ω from Section 6.4. Let ≤m denote the m-reducibility by computable
functions on the Cantor space.
Theorem 9.7. (i) [173] The relations ≤CA, ≤m and ≤DA coincide on R.
(ii) [140] The relations ≤CA, ≤m, ≤DA and ≤AA coincide on A.
(iii) [125] For any α < ωω, Rα = R ∩Σα = R ∩6α.
(iv) [140] For any α < ωω, Aα = A ∩Σα = A ∩6α.
We conclude this subsection by providing invariants for the fine hierarchy of regular ω-languages in the spirit of
Section 3.4. Above we related with any Muller acceptor (M, F ) the corresponding 2-preorder (CM; ≤0, ≤1). Let τα be the
string defined in Section 3.4.
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
159
Theorem 9.8 ([173,125]). For any Muller acceptor (M, F ) and any α < ωω, L(M, F ) ∈Rα iff there is no τα-alternating tree
for F in (CM; ≤0, ≤1).
Corollary 9.9. The relations ‘‘L(M, F ) ∈Rα’’ and ‘‘L(M1, F1) ≤DA L(M, F )’’ are decidable.
In [77,178] it was shown that for any α < ωω the relation ‘‘L(M, F ) ∈Rα’’ is decidable in polynomial time. In [159]
exact complexity estimations for deciding the topological properties like Rα for most popular types of ω-automata [166]
were established. The problems are typically NL-complete (PSPACE-complete) for the deterministic Muller, Mostowski and
Büchi automata (respectively, for the nondeterministic Rabin, Muller, Mostowski and Büchi automata).
In [28] it was shown that the class A is decidable in PSPACE for the nondeterministic Büchi automata. In [160] it is
shown that for each nonzero α < ωω the class Aα is PSPACE-complete w.r.t. any (deterministic or nondeterministic) type
of ω-automata.
9.6. Fine hierarchy of k-partitions
Here we mention some results from [139] about the ω-regular k-partitions, i.e. k-partitions of Aω all components of which
are regular sets. The notion of Muller acceptor is generalized to the notion of Muller k-acceptor (a device that recognizes
k-partitions of Aω) in a straightforward way. Namely, it is a pair (M, c) where M is an initial automaton and c : CM →k is
a k-partition of CM. Such a k-acceptor recognizes the k-partition L(M, c) = c ◦fM where fM : Aω →CM is the map defined
above. It is not hard to show that a k-partition L : Aω →k is regular iff it is recognized by a Muller k-acceptor.
The next result extends to the case of k-partitions the Staiger-Wagner theorem from [156] (Proposition 9.2(i)): every
regular 10
2-set is a Boolean combination of open sets. We will generalize the following equivalent reformulation of this
result: if a regular set L is not a Boolean combination of open sets then 60
2 ≤CA L or 50
2 ≤CA L. For all distinct i, j < k, let
Ai,j : Xω →k be the unique k-partition satisfying A−1(i) = B, A−1(j) = B and A−1(l) = ∅for all l ∈k \ {i, j} where B is a
CA-complete set for 60
2. Observe that the k-partitions Ai,j (i, j < k, i ̸= j) are pairwise CA-incomparable.
Let (A, c) be a Muller k-acceptor, ≤0 the preorder on CA from Section 9.3 and ≡0 the corresponding equivalence relation.
We say that ≡0 respects the labeling c if D ≡0 E implies c(D) = c(E) for all D, E ∈CA.
Theorem 9.10. For any Muller k-acceptor (A, c) the following conditions are equivalent:
(i) L(A, c) ̸∈(B(60
1))k;
(ii) The relation ≡0 does not respect the labeling c;
(iii) Al,j ≤CA L(A, c) for some distinct l, j < k.
From the equivalence of (i) and (ii) above we immediately obtain that the relation ‘‘L(A, c) ∈BC(60
1)k’’ is decidable.
Now let {L0(F)}F∈Fk be the DH of k-partitions over L0 and {60
1(F)}F∈Fk be the DH of k-partitions over 60
1 (see Section 3.5).
Theorem 9.11. (i) The relation ‘‘L(A, c) ∈60
1(F)’’ is decidable.
(ii) For any k ≥2, the quotient-structures of (BC(L0)k; ≤CA)) and (Fk; ≤) are isomorphic.
(iii) For any k ≥2, the relations ≤CA and ≤DA coincide on BC(60
1)k ∩Rk.
From the last result and Proposition 2.6 we obtain the usual corollaries on the undecidability and automorphisms of the
structures of k-partitions.
Note that the above-mentioned results extend the main facts about an initial segment of the Wagner hierarchy to the
case of k-partitions. Recently the author extended the main facts about all levels of the Wagner hierarchy to the k-partitions.
This extension should appear elsewhere.
9.7. Other types of automata
Here we briefly discuss some recent results on the topological classification of ω-languages recognized by devices
more complex that the finite automata. First let us notice that there is a well-known small difference between the Wadge
hierarchies in the Baire and in the Cantor space with respect to the question for which ordinals α < ν (here ν is the Wadge
ordinal, see Section 4.4) the class 1α of the Wadge hierarchy has a Wadge complete set (such sets correspond to the self-
dual Wadge degrees). For the Cantor space, these are exactly the successor ordinals α < ν while for the Baire space — the
successor ordinals and the limit ordinals of countable cofinality [171,169]. This follows easily from the well-known fact that
the Cantor space is compact while the Baire space is not.
By a result above, the order type of the Wadge degrees of regular ω-languages is ωω. In [32] the Wadge degrees of regular
ω-languages were characterized (this characterization follows also from the relations between the Wagner, fine and Wadge
hierarchies). Namely, these are exactly the Wadge degrees of ranks ωn
1kn + · · · + ω1
1k1 + k0 where n < ω and ki < ω for all
i ≤n. By results above, the same characterization holds for the Wadge degrees of regular aperiodic ω-languages.
In [32] the Wadge degrees of ω-languages recognized by deterministic push-down automata were determined; these are
exactly the Wadge degrees of ranks ωn
1αn +· · ·+ω1
1α1 +α0 where n < ω and αi < ωω for all i ≤n. Thus, the corresponding
ordinal is (ωω)ω.
160
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
In [131] the Wadge degrees of ω-languages recognized by deterministic Turing machines were determined; these are
exactly the Wadge degrees of ranks ωn
1αn+· · ·+ω1
1α1+α0 where n < ω and αi < ωCK
1
for all i ≤n. Thus, the corresponding
ordinal is (ωCK
1 )ω where ωCK
1
is the first non-computable ordinal. The proof makes an essential use of a result of L. Staiger
mentioned in Section 9.1 and a result of A. Louveau mentioned in Section 6.1.
For the non-deterministic devices, an interesting fact was recently obtained in [46]: the Wadge degrees of ω-languages
recognized by the non-deterministic push-down automata coincide with those recognized by the non-deterministic Turing
machines. By a result of L. Staiger mentioned in Section 9.1, these are exactly the Wadge degrees of Σ1
1 -sets. By a result in
[73] mentioned in Section 6.1, the corresponding ordinal is strictly bigger than the Wadge rank of the ∆1
1-sets. Additional
information on these Wadge degrees may be found in [43,45,47].
9.8. Future work
Above in this section we completely characterized the topological fine hierarchy of regular aperiodic ω-languages. Along
with the topological classification, there are some alternative classifications of regular aperiodic ω-languages. E.g., one could
consider the logical fine hierarchy of regular aperiodic ω-languages which is the fine hierarchy over the base {Ln} where Ln is
the class of ω-languages axiomatized by the first-order Σ0
n+1-sentences of signature ϱ, similarly to the case of finite words
in Section 8.1. It seems interesting to understand better the relationships between these hierarchies.
There are some model-theoretic open questions related to results of this section. E.g., consider the structures
(B(60
2); 60
2, 60
1, ∪, ∩,¯), (R; L1, L0, ∪, ∩,¯) and (A; K1, K0, ∪, ∩,¯) where 60
2, 60
1, L1, . . . are treated as unary predicates
on the corresponding universes. The results of this section show some striking similarities between the three structures
which suggest that all the structures may turn out to be elementary equivalent. It may even turn out that any of the two last
structures is an elementary substructure of the previous one. Currently, the author does not know whether this is really the
case.
Another natural open question is to understand better the structure (R; ≤AA). This structure may turn out to be more
complicated than the structures discussed in Section 9.5. In particular, we do not know whether it is almost well ordered.
In the previous section we discussed only the Wadge degrees ofω-languages recognized by computing devices, though for
the case of dfa we had also found reducibilities that fit the corresponding hierarchies. We guess that for all classes discussed
in the previous subsection, except the deterministic context-free sets, such reducibilities do not exist. For the hierarchy
of deterministic context-free sets this question is open, as well as the question of decidability of levels. For a non-trivial
particular case decidability was shown in [44]. The same questions are currently open for the class of visibly push-down
languages from [9].
Along with ω-words, in theoretical computer science people are interested in recognizability of more complicated
structures, e.g. ordinal words of length > ω, biinfinite words, finite words together with infinite words, or infinite trees
(see [18,105]). We would like to see a systematic work about the complexity of the corresponding languages. Recently,
some progress was made for the hard and important case of (infinite) tree languages. Namely the Wadge degrees of infinite
tree languages recognized by deterministic finite automata were determined in [98], and the lower bound ε0 for the Wadge
rank of the so called weak alternating tree languages was established in [29,99].
10. Conclusion
We hope that this survey may convince the reader that the fine hierarchies and m-reducibilities provide useful and
flexible classification tools for several parts of theoretical computer science. Moreover, we tried to demonstrate that this
topic is interesting in its own right and is evolving to become a real theory.
At the same time, there are many open questions and directions of future research. Some of them were mentioned above.
In my opinion, there are some fields of theoretical computer science in which the methods surveyed in this paper could be
especially useful, in particular the descriptive complexity theory and the circuit complexity theory.
Acknowledgements
Some results of this paper were obtained during my visiting professorship at the University of Siegen in 2002 and the
DFG Mercator visiting professorship at the University of Würzburg in 2006 and 2007. I am grateful to both universities and
to DFG for supporting my stays, to the listeners of my lecture courses for coming, and to Dieter Spreen and Klaus Wagner
for making the stays possible and for many helpful discussions. Discussions with Bill Wadge and help of Anton Zhukov with
making the pictures are also gratefully acknowledged.
References
[1] S. Aaronson, The complexity zoo. http://www.complexityzoo.com.
[2] J.W. Addison, Separation principles in the hierarchies of classical and effective set theory, Fund. Math. 46 (1959) 123–135.
[3] J.W. Addison, Some problems in herarchy theory, in: Recursive Function Theory Proc. Symp., Pure Math. AMS 5 (1962) 123–130.
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
161
[4] J.W. Addison, The theory of hierarchies, in: Logic, Methodology and Philosophy of Science (Proc. of 1960 Int. Congress, Stanford, Palo Alto), 1962,
pp. 26–37.
[5] J.W. Addison, The method of alternating chains, in: The Theory of Models, North Holland, Amsterdam, 1965, pp. 1–16.
[6] S. Abramsky, A. Jung, Domain Theory, in: Handbook of Logic in Computer Science, vol. 3, Oxford, 1994, pp. 1–168.
[7] E. Allender, M.C. Loui, K.W. Regan, Complexity classes, in: M.J. Atallah (Ed.), Algorithms and Theory of Computation Handbook, CRC Press, 1999,
p. 27–1.
[8] E. Allender, M.C. Loui, K.W. Regan, Reducibility and completeness, in: M.J. Atallah (Ed.), Algorithms and Theory of Computation Handbook, CRC Press,
1999, p. 28–1.
[9] R. Alur, P. Madhusudan, Visibly pushdown languages, in: 36th ACM Symposium on Theory of Computing, 2004, pp. 202–211.
[10] D.P. Bovet, P. Crescenzi, R. Silvestri, A uniform approach to define complexity classes, Theoret. Comput. Sci. 104 (1992) 263–283.
[11] J.L. Balcázar, J. Díaz, J. Gabarró, Structural Complexity I, in: EATCS Monographs on Theoretical Computer Science, vol. 11, Springer-Verlag, 1988.
[12] J.L. Balcázar, J. Díaz, J. Gabarró, Structural Complexity II, in: EATCS Monographs on Theoretical Computer Science, vol. 11, Springer-Verlag, 1990.
[13] A. Blass, Y. Gurevich, Equivalence relations, invariants, and normal forms, in: Logic and Machines: Decision Problems and Complexity, in: Lecture
Notes in Computer Science, vol. 171, Springer-Verlag, 1986, pp. 24–42.
[14] B. Borchert, D. Kuske, F. Stephan, On existentially first-order definable languages and their relation to NP, Theoret. Inform. Appl. 33 (1999) 259–269.
[15] J.R. Büchi, L.H. Landweber, Solving sequential conditions by finite-state strategies, Trans. Amer. Math. Soc. 138 (1969) 295–311.
[16] B. Borchert, K.-J. Lange, F. Stephan, P. Tesson, D. Thérien, The dot-depth and the polynomial hierarchy correspond on the Delta levels, Internat. J.
Found. Comput. Sci. 16 (2005) 625–644.
[17] B. Borchert, On the acceptance power of regular languages, Theoret. Comput. Sci. 148 (1995) 207–225.
[18] J.R. Büchi, D. Siefkes, The monadic second-order theory of all countable ordinals, Lecture Notes in Math. 328 (1973) 1–126.
[19] J.R. Büchi, Weak second-order arithmetic and finite automata, Z. Math. Logic Grundl. Math. 6 (1960) 66–92.
[20] H.-J. Burtschick, H. Vollmer, Lindström Quatifiers and Leaf Language Definability, Internat. J. Found. Comput. Sci. 9 (1998) 277–294.
[21] J. Cabessa, A game theoretic approach to the algebraic counterpart of the wagner hierarchy, Ph.D. Thesis, Universities of Lausanne and Paris-7, 2007.
[22] A. Church, Logic, arithmetic and automata, in: Proc. Int. Congr. Math., 1962, Inst. Mittag-Lefler, Djursholm, Sweden, 1963, pp. 23–35.
[23] J.-Y. Cai, L.A. Hemachandra, The Boolean Hierarchy: Hardware Over NP, in: Lecture Notes in Computer Science, vol. 223, Springer, Berlin, 1986,
pp. 105–124.
[24] S. Cho, D.T. Huynh, Finite automaton aperiodicity is PSPACE-complete, Theoret. Comput. Sci. 88 (1991) 99–116.
[25] B.F. Csima, A. Montalban, R.A. Shore, Boolean algebras, Tarski invariants, and index sets, Notre Dame J. Formal Logic 47 (2006) 1–23.
[26] O. Carton, D. Perrin, Chains and superchains for ω-rational sets, automata and semigroups, Internat. J. Algebra Comput. 7 (7) (1997) 673–695.
[27] O. Carton, D. Perrin, The Wagner hierarchy of ω-rational sets, Internat. J. Algebra Comput. 9 (7) (1999) 673–695.
[28] V. Diekert, P. Gastin, First-order definable languages, in: J. Flum, E. Grädel, Th. Wilke (Eds.), Logic and Automata: History and Perspectives, in: Texts
in Logic and Games, Amsterdam University Press, 2008, pp. 261–306.
[29] J. Duparc, F. Murlak, On the topological complexity of weakly recognizable tree languages, in: Proc. FCT 2007, in: Lecture Notes in Computer Science,
vol. 4639, Berlin, Springer, 2007, pp. 261–273.
[30] B.A. Davey, H.A. Pristley, Introduction to Lattices and Order, Cambridge, 1994.
[31] J. Duparc, M. Riss, The missing link for ω-rational sets, automata, and semigroups, Internat. J. Algebra Comput. 16 (1) (2006) 161–185.
[32] J. Duparc, A hierarchy of deterministic context-free ω-languages, Theoret. Comput. Sci. 290 (3) (2003) 1253–1300.
[33] H.-D. Ebinghaus, J. Flum, W. Thomas, Mathematical Logic, Springer, New York, 1994.
[34] J. Engelfriet, H.J. Hoogeboom, X-Automata on ω-words, Theoret. Comput. Sci. 110 (1) (1993) 1–51.
[35] R.L. Epstein, R. Haas, R. Kramer, Hierarchies of sets and degrees below 0′, in: M. Lerman, J.H. Schmerl, R.I. Soare (Eds.), Logic Year 1979-80: University
of Connecticut, Springer, Berlin, 1981, pp. 32–48.
[36] Z. Esik, M. Ito, Temporal logic with cyclic counting and the degree of aperiodicity of finite automata, Acta Cybern. 16 (1) (2003) 1–28.
[37] F. van Engelen, A. Miller, J. Steel, Rigid Borel sets and better quasiorder theory, Contemp. Math. 65 (1987) 199–222.
[38] Yu.L. Ershov, On a hierarchy of sets 1, 2, 3, Algebra Logika 7 (1) (1968) 47–74; 7 (4) (1968) 15–47; 9 (1) (1970) 34–51 (in Russian).
[39] Y.L. Ershov, Theorie der Numerierungen I, Zeitschr. Math. Logik Grundl. Math. 19 (1973) 289–388.
[40] Y.L. Ershov, Theorie der Numerierungen II, Zeitschr. Math. Logik Grundl. Math. 21 (1975) 473–584.
[41] Yu.L. Ershov, Theory of Numberings, Nauka, Moscow, 1977 (in Russian).
[42] Yu.L. Ershov, Theory of domains and nearby, Lecture Notes Comput. Sci. 735 (1993) 1–7.
[43] O. Finkel, Wadge hierarchy of omega context free languages, Theoret. Comput. Sci. 269 (1–2) (2001) 283–315.
[44] O. Finkel, An effective extension of the Wagner hierarchy to blind counter automata, in: Proc. CSL-2001, in: Lecture Notes of Computer Science, vol.
2143, 2001, pp. 369–383.
[45] O. Finkel, Borel hierarchy and omega context free languages, Theoret. Comput. Sci. 290 (3) (2003) 1385–1405.
[46] O. Finkel, Borel ranks and Wadge degrees of context-free ωlanguages, Math. Struct. Comput. Sci. 16 (2006) 813–840.
[47] O. Finkel, P. Simonnet, Topology and ambiguity in omega context free languages, Bull. Belgian Math. Soc. 10 (2003) 707–722.
[48] C. Glaßer, Polylogtime-reductions decrees dot-depth, in: Proceedings 22nd Symposium on Theoretical Aspects of Computer Science, in: Lecture
Notes in Computer Science, vol. 3404, Springer, Berlin, 2005.
[49] C. Glaßer, Languages polylog-time reducible to dot-depth 1/2, J. Comput. System Sci. 73 (2007) 36–56.
[50] C. Glaßer, C. Reitwießner, V. Selivanov, The shrinking property for NP and coNP, in: Conf. Computability in Europe-2008, in: Lecture Notes in Computer
Science, vol. 5028, Springer, Berlin, 2008, pp. 210–220.
[51] C. Glaßer, H. Schmitz, The Boolean structure of dot-depth one, J. Automata Languages Combin. 6 (2001) 437–452.
[52] C. Glaßer, H. Schmitz, V. Selivanov, Efficient algorithms for membership in Boolean hierarchies of regular languages, in: Proceedings of STACS-2008,
pp. 337–348 (full version in ECCC Report TR07-094).
[53] G. Giertz, K.H. Hoffmann, K. Keimel, J.D. Lawson, M.W. Mislove, D.S. Scott, Continuous Lattices and Domains, Cambridge, 2003.
[54] F. Hausdorff, Grundzüge der Mengenlehre, W. de Gruyter, Berlin, Leipzig, 1914.
[55] F. Hausdorff, Mengenlehre, W. de Gruyter, Berlin, Leipzig, 1927.
[56] L. Hay, A discrete chain of degrees of index sets, J. Symbolic Logic 37 (1972) 139–149.
[57] A. Hemmerling, Hierarchies of function classes defined by the first-value operator, RAIRO Theoret. Inform. Appl. 42 (2) (2008) 253–270. Universität
Greifswald Preprint-Reihe Mathematik 12/2004.
[58] A. Hemmerling, Characterizations of the class ∆ta
2 over Euclidian spaces, Math. Logic Quarterly 50 (2004) 507–519.
[59] A. Hemmerling, The Hausdorff–Ershov hierarchy in Euclidean spaces, Arch. Math. Logic 45 (2006) 323–350.
[60] P. Hertling, Topologische Komplexitätsgrade von Funktionen mit endlichem Bild. Informatik-Berichte 152, 34 pages, Fernuniversität Hagen,
December 1993.
[61] P. Hertling, Unstetigkeitsgrade von Funktionen in der effectiven Analysis, Ph.D. Thesis, FernUniversität Hagen, Informatik-Berichte 208–11, 1996.
[62] P. Hertling, Topological complexity with continuous operations, J. Complexity 12 (1996) 315–338.
[63] E. Hemaspaandra, L. Hemaspaandra, H. Hempel, What’s up with downward collapse: Using the easy-hard technique to link boolean and polynomial
hierarchy collapses. Compl. Theory Column 21, ACM–SIGACT Newsletter 29 (3) (1998) 10–22.
[64] E. Hemaspaandra, L. Hemaspaandra, H. Hempel, A downward collapse within the polynomial hierarchy, SIAM J. Comput. 28 (1999) 383–393.
[65] L. Hemaspaandra, H. Hempel, G. Wechsung, Query order, SIAM J. Comput. 28 (1999) 637–651.
[66] P. Hinman, Recursion-Theoretic Hierarchies, Springer, Berlin, 1978.
162
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
[67] U. Hertrampf, C. Lautemann, T. Schwentick, H. Vollmer, K.W. Wagner, On the power of polynomial time bit-reductions, in: Proc. 8th Structure in
Complexity Theory, 1993, pp. 200–207.
[68] U. Hertrampf, H. Vollmer, K.W. Wagner, On the power of number–theoretic operations with respect to counting, in: Proc. 10th Structure in
Complexity Theory, 1995, pp. 299–314.
[69] U. Hertrampf, H. Vollmer, K.W. Wagner, On balanced vs unbalanced computation trees, Math. Systems Theory 29 (1996) 411–421.
[70] P. Hertling, K. Weihrauch, Levels of degeneracy and exact lower complexity bounds for geometric algorithms, in: Proc. of the 6th Canadian Conf. on
Computational Geometry, Saskatoon 1994, pp. 237–242.
[71] J. Kadin, The polynomial hierarchy collapses if the Boolean hierarchy collapses, SIAM J. Comput. 17 (6) (1987) 1263–1282.
[72] A.S. Kechris, Classical Descriptive Set Theory, Springer, New York, 1995.
[73] A.S. Kechris, D. Marker, R.L. Sami, Π 1
1 Borel sets, J. Symbolic Logic 54 (1989) 915–920.
[74] K. Kuratowski, A. Mostowski, Set Theory, North Holland, 1967.
[75] S. Kosub, Complexity and partitions, Ph.D. Thesis, Würzburg, 2000.
[76] J. Köbler, Untersuchungen verschidener polynomieller Reduktionsclassen von NP, Diploma Thesis, Universität Stuttgart, 1985.
[77] S. Krishnan, A. Puri, R. Brayton, Structural Complexity of ω-Automata, in: Lecture Notes in Computer Science, vol. 915, Springer, Berlin, 1995,
pp. 143–156.
[78] M.R. Krom, Separation principles in the hierarchy theory of pure first order logic, J. Symbolic Logic 3 (1963) 222–236.
[79] J.B. Kruskal, The theory of well-quasi-ordering: A frequently discovered concept, J. Combin. Theory A 13 (1972) 297–305.
[80] O.V. Kudinov, V.L. Selivanov, Undecidability in the Homomorphic Quasiorder of Finite Labeled Forests, in: Lecture Notes in Computer Science, vol.
3988, Springer, Berlin, 2006, pp. 289–296.
[81] O.V. Kudinov, V.L. Selivanov, Definability in the homomorphic quasiorder of finite labeled forests, in: S.B. Cooper, B. Löwe, A. Sorbi (Eds.), Conf.
Computability in Europe-2007, in: Lecture Notes in Computer Science, vol. 4497, Springer, Berlin, 2007, pp. 436–445. Ann. Pure Appl. Logic (accepted).
[82] O.V. Kudinov, V.L. Selivanov, Undecidability in the homomorphic quasiorder of finite labeled forests, J. Logic Comput. 17 (2007) 1135–1151.
[83] J. Köbler, U. Schöning, K. Wagner, The difference and truth-table hierarchies for NP, Theoret. Inform. Appl. 21 (1987) 419–435.
[84] K. Kuratowski, Topology, Academic Press, 1966.
[85] T.M. Kuz’mina, Structure of m-degrees of index sets of families of partial recursive functions, Algebra Logic 20 (1981) 55–68 (in Russian, there is an
English translation).
[86] S. Kosub, K. Wagner, The boolean hierarchy of NP-partitions, in: STACS-2000 Proceedings, in: Lecture Notes of Computer Science, 1770, Springer,
Berlin, 2000, pp. 157–168.
[87] E. Lehtonen, Descending chains and antichains of the unary, linear, and monotone subfunction relations, Order 23 (2006) 129–142.
[88] E. Lehtonen, Labeled posets are universal, European J. Combin. 29 (2) (2008) 493–506.
[89] S. Lempp, Hyperarithmetical index sets in recursion theory, Trans. Amer. Math. Soc 303 (2) (1987) 559–584.
[90] T. Linton, Countable structures, Ehrenfeucht strategies, and Wadge reductions, J. Symbolic. Logic 56 (1991) 1325–1348.
[91] A. Louveau, Some results in the Wadge hierarchy of Borel sets, Lecture Notes Math. 1019 (1983) 28–55.
[92] A. Louveau, J. Saint-Raymond, Les propriétés de réduction et de norme pour les classes de boréliens, Fund. Math. 131 (1988) 223–243.
[93] A.I. Mal’cev, Algorithms and Recursive Functions, Wolters–Noordhoff, Groningen, 1970.
[94] J. Mohrherr, Kleene index sets and functional m-degrees, J. Symbolic Logic 48 (4) (1983) 829–840.
[95] Y.N. Moschovakis, Descriptive Set Theory, North Holland, Amsterdam, 1980.
[96] R. McNaughton, S. Papert, Counter-free Automata, MIT Press, Cambridge, MA, 1971.
[97] A.R. Meyer, L.J. Stockmeyer, The equivalence problem for regular expressions with squaring requires exponential space, in: Proc. of 13th Annual IRRR
Symp. on Switching and Automata Theory, 1972, pp. 125–129.
[98] F. Murlak, The Wadge Hierarchy of Deterministic Tree Languages, in: Lecture Notes in Computer Science, vol. 4052, Springer, Berlin, 2006,
pp. 408–419.
[99] F. Murlak, Effective topological hierarchies of recognizable tree languages, Ph.D. Thesis, The University of Warsaw, 2008.
[100] P.G. Odifreddi, Classical Recursion Theory, Elsevier, Amsterdam, 1999.
[101] Ch.H. Papadimitriu, Computational Complexity, Addison Wesley, 1994.
[102] J.E. Pin, Varieties of Formal Languages, Plenum, London, 1986.
[103] J.E. Pin, Logic on words, Bull. EATCS 54 (1994) 145–165.
[104] D. Perrin, J.E. Pin, First order logic and star–free sets, J. Comput. System Sci. 32 (1986) 393–406.
[105] D. Perrin, J.-E. Pin, Infinite Words, in: Pure and Applied Mathematics, vol. 141, Elsevier, 2004.
[106] H. Putnam, Trial and error predicates and the solution to a problem of Mostowski, J. Symbolic Logic 30 (1965) 49–57.
[107] H. Rogers Jr., Theory of Recursive Functions and Effective Computability, McGraw-Hill, New York, 1967.
[108] A. Rabinovich, W. Thomas, Logical refinements of church’s problem, in: Proc. of CSL-2007, in: Lecture Notes in Computer Science, vol. 4646, Springer,
Berlin, 2007, pp. 69–83.
[109] V.L. Selivanov, On the structure of degrees of index sets, Algebra Logic 18 (1979) 286–299 (in Russian, there is an English translation).
[110] V.L. Selivanov, On the structure of degrees of generalized index sets, Algebra Logic 21 (1982) 316–330 (in Russian, there is an English translation).
[111] V.L. Selivanov, On index sets in the Kleene–Mostowski hierarchy, Trans. Inst. Math., Novosibirsk 2 (1982) 135–158 (in Russian).
[112] V.L. Selivanov, Hierarchies of hyperarithmetical sets and functions, Algebra Logika 22 (6) (1983) 666–692. English translation: Algebra Logic, 22
(1983), 473–491.
[113] V.L. Selivanov, A hierarchy of limiting computations, Siberian Math. J. 25 (1984) 146–156 (in Russian there is an English translation).
[114] V.L. Selivanov, On Ershov hierarchy, Siberian Math. J. 26 (1985) 134–149 (in Russian, there is an English translation).
[115] V.L. Selivanov, Fine hierarchies of arithmetical sets and definable index sets, Trudi Mat. Inst. SO AN SSSR 12 (1989) 165–185 (in Russian).
[116] V.L. Selivanov, Index sets of classes of hyperhypersimple sets, Algebra Logika 29 (2) (1990) 220–240 (in Russian). English translation: Algebra Logic
29 (2) (1990) 155–168.
[117] V.L. Selivanov, Fine hierarchies and definable index sets, Algebra Logika 30 (6) (1991) 705–725. English translation: Algebra Logic 30 (1991) 463—475.
[118] V.L. Selivanov, Fine hierarchy of formulas, Algebra Logika 30 (5) (1991) 568–582. English translation: Algebra Logic 30 (1991) 368–379.
[119] V.L. Selivanov, Hierarchies, Numerations, Index Sets, Handwritten notes, 1992, 300 pp.
[120] V.L. Selivanov, Two refinements of the polynomial hierarchy, in: Proc. of Symposium on Theor. Aspects of Computer Science STACS–94, in: Lecture
Notes in Computer Science, vol. 775, Springer, Berlin, 1994, pp. 439–448.
[121] V.L. Selivanov, Fine hierarchy of regular ω-languages, Preprint N 14, 1994, The University of Heidelberg, Chair of Mathematical Logic, 13 pp.
[122] V.L. Selivanov, Fine hierarchies and Boolean terms, J. Symbolic Logic 60 (1995) 289–317.
[123] V.L. Selivanov, Fine Hierarchy of Regular ω-Languages, in: Lecture Notes in Computer Science, vol. 915, Springer, Berlin, 1995, pp. 277–287.
[124] V.L. Selivanov, Fine hierarchy and definability in the Lindenbaum algebra, in: Logic: From Foundations to Applications, Proceedings of the Logic
Colloquium-93 in Keele, Oxford, 1996, pp. 425–452.
[125] V.L. Selivanov, Fine hierarchy of regular ω-languages, Theoret. Comput. Sci. 191 (1998) 37–59.
[126] V.L. Selivanov, Refining the polynomial hierarchy, Algebra Logic 38 (1999) 456–475 (in Russian, there is an English translation).
[127] V.L. Selivanov, On two conjectures of W. Wadge, in: Abstracts of Int. Conf. in Honor of Yu.L. Ershov, Novosibirsk, 2000, p. 139.
[128] V.L. Selivanov, A Logical Approach to Decidability of Hierarchies of Regular Star-Free Languages, in: Lecture Notes in Computer Science, vol. 2010,
Springer, Berlin, 2001, pp. 539–550.
[129] V.L. Selivanov, Precomplete numberings, in: Proc. of Int. Conferences on Math. Logic honoring Yu.L. Ershov and A.I. Mal’tsev, Novosibirsk, 2002,
pp. 104–143.
V.L. Selivanov / Theoretical Computer Science 405 (2008) 116–163
163
[130] V.L. Selivanov, Relating automata-theoretic hierarchies to complexity-theoretic hierarchies, Theoret. Inform. Appl. 36 (2002) 29–42.
[131] V.L. Selivanov, Wadge degrees of ω-languages of deterministic turing machines, Theoret. Inform. Appl. 37 (2003) 67–83.
[132] V.L. Selivanov, Positive structures, in: S. Barry Cooper, Sergei S. Goncharov (Eds.), Computability and Models, Perspectives East and West, Kluwer
Academic/Plenum Publishers, New York, 2003, pp. 321–350.
[133] V.L. Selivanov, Boolean hierarchies of partitions over reducible bases, Algebra Logic 43 (1) (2004) 44–61.
[134] V.L. Selivanov, Hierarchies in ϕ-spaces and applications, Math. Logic Quarterly 51 (1) (2005) 45–61.
[135] V.L. Selivanov, Variations on the Wadge reducibility, Siberian Adv. Math. 15 (3) (2005) 44–80.
[136] V.L. Selivanov, Some Reducibilities on Regular Sets, in: Lecture Notes in Computer Science, vol. 3526, Berlin, Springer, 2005, pp. 430–440. Journal
version published online: Hierarchies and reducibilities on regular languages related to modulo counting, RAIRO Theoret. Inform. Appl. (15 January)
(2008). 10.1051/ita:2007063.
[137] V.L. Selivanov, Towards a descriptive set theory for domain-like structures, Theoret. Comput. Sci. 365 (2006) 258–282.
[138] V.L. Selivanov, A useful undecidable theory, in: S.B. Cooper, B. Löwe, A. Sorbi (Eds.), Conf. Computability in Europe-2007, in: Lecture Notes in Computer
Science, vol. 4497, Springer, Berlin, 2007, pp. 685–694.
[139] V.L. Selivanov, Classifying omega-regular partitions, in: Preproceedings of LATA-2007, Universitat Rovira i Virgili Report Series, 35/07, pp. 529–540.
[140] V.L. Selivanov, Fine hierarchy of regular aperiodic ω-languages, in: T. Harju, J. Karhumäki, A. Lepistö (Eds.), Conf. DLT-2007, in: Lecture Notes in
Computer Science, vol. 4588, Springer, Berlin, 2007, pp. 399–410. Journal version appeared in: Int. J. Foundations Comput. Sci. 19 (3) (2008) 649–675.
[141] V.L. Selivanov, On the Wadge reducibility of k-partitions, ENTCS, CCA-2007 Conference, in press (doi:10.1016/j.entcs.2008.03.008).
[142] V.L. Selivanov, The quotient algebra of labeled forests modulo h-equivalence, Algebra Logic 46 (2) (2007) 120–133.
[143] V.L. Selivanov, Hierarchies of ∆0
2-measurable k-partitions, Math. Logic Quarterly 53 (2007) 446–461.
[144] V.L. Selivanov, Undecidability in some structures related to computation theory, J. Logic Comput. (in press).
[145] V.L. Selivanov, Hierarchies and reducibilities on regular languages related to modulo counting, RAIRO Theoret. Inform. Appl., Published Online: 15
January 2008, doi: 10.1051/ita:2007063.
[146] J.R. Shoenfield, Mathematical Lodic, Addison-Wesley, 1967.
[147] A.G. Shukin, Difference hierarchies of regular languages, Computing Systems, Novosibirsk 161 (1998) 141–155 (in Russian).
[148] R.I. Soare, Recursively Enumerable Sets and Degrees, Springer, Berlin, 1987.
[149] V.L. Selivanov, A.G. Shukin, On hierarchies of regular star-free languages (in Russian), Preprint 69 of A.P. Ershov Institute of Informatics Systems,
2000, 28 p.
[150] L. Staiger, Hierarchies of recursive ω-languages, Elektron. Inf. verarb. Kybern. 22 (5–6) (1986) 219–241.
[151] L. Staiger, ω-Languages, in: Handbook of Formal Languages, vol. 3, Springer, Berlin, 1997, pp. 339–387.
[152] J. Steel, Determinateness and the separation property, J. Symbolic Logic 45 (1980) 143–146.
[153] J. Stern, Characterizations of some classes of regular events, Theoret. Comput. Sci. 35 (1985) 17–42.
[154] L.J. Stockmeyer, The polynomial hierarchy, Theoret. Comput. Sci. 3 (1976) 1–22.
[155] H. Straubing, Finite Automata, Formal Logic and Circuit Complexity, Birkhäuser, Boston, 1994.
[156] L. Staiger, K. Wagner, Automatentheoretische und automatenfreie Characterisierungen topologischer klassen regulärer Folgenmengen, Elektron. Inf.
verarb. Kybern. EIK 10 (7) (1974) 379–392.
[157] H. Schmitz, K. Wagner, The Boolean hierarchy over level 1/2 of the Sraubing–Therien hierarchy. Preprint, CoRR, cs.CC/9809118, 1998,
http://arxive.org/abs/cs.CC/9809118.
[158] V.L. Selivanov, K.W. Wagner, A reducibility for the dot-depth hierarchy, Theoret. Comput. Sci. 345 (2–3) (2005) 448–472.
[159] V.L. Selivanov, K.W. Wagner, Complexity of topological properties of regular ω-languages, Fund. Inform. 20 (2008) 1–21.
[160] V.L. Selivanov, K.W. Wagner, Complexity of aperiodicity for topological properties of regular ω-languages, in: Conf. Computability in Europe-2008,
in: Lecture Notes in Computer Science, vol. 5028, Springer, Berlin, 2008, pp. 533–543.
[161] A. Tang, Chain properties in Pω, Theoret. Comput. Sci. 9 (1979) 153–172.
[162] B.A. Trakhtenbrot, J.M. Barzdin, Finite automata, in: Behavior and Synthesis, Mir, Moscow, 1970 (in Russian, English translation: North Holland,
Amsterdam, 1973).
[163] W. Thomas, Star-free regular sets of ω-sequences, Inform. Control 42 (1979) 148–156.
[164] W. Thomas, Classifying regular events in symbolic logic, J. Comput. System Sci. 25 (1982) 360–376.
[165] W. Thomas, Automata on infinite objects, in: Handbook of Theor. Computer Science B, 1990, pp. 133–191.
[166] W. Thomas, Languages, automata and logic, in: Handbook of Formal Language Theory B, 1996, pp. 133–191.
[167] N.K. Vereshchagin, Relativizable and non-relativizable theorems in the polynomial theory of algorithms, Izvestiya Rossiiskoi Akademii Nauk 57
(1993) 51–90 (in Russian, there is an English translation).
[168] R.L. Vaught, Invariant sets in topology and logic, Fund. Math. 82 (1974) 269–294.
[169] R. Van Wesep, Wadge degrees and descriptive set theory, Lec. Notes in Math. 689 (1976) 151–170.
[170] W. Wadge, Degrees of complexity of subsets of the Baire space, Notices AMS (1972) A-714.
[171] W. Wadge, Reducibility and determinateness in the Baire space, Ph.D. Thesis, University of California, Berkely, 1984.
[172] K. Wagner, Eine topologische Characterisierung einiger Klassen regulärer Folgenmengen, Elektron. Inf. verarb. Kybern. EIK 13 (9) (1977) 473–487.
[173] K. Wagner, On ω-regular sets, Inform. Control 43 (1979) 123–177.
[174] K.W. Wagner, A note on parallel queries and the symmetric-difference hierarchy, Inform. Process. Lett. 66 (1998) 13–20.
[175] K.W. Wagner, Leaf language classes, in: Proc. of MCU’2004-conference in Saint-Petersburg, Russia, September 21–24, 2004 (revised version in: LNCS,
vol. 3354, pp. 60–81).
[176] K. Weihrauch, Computable Analysis, Springer, Berlin, 2000.
[177] G. Wechsung, K.W. Wagner, On the Boolean closure of NP, Manuskript, Extended abstract as: G. Wechsung, On the Boolean closure of NP,
in: Proceedings of the 1985 Int. Conf. on Fundamentals of Computation Theory, in: Lecture Notes in Computer Science, vol. 199, Springer-Verlag,
1985, pp. 485–493.
[178] T. Wilke, H. Yoo, Computing the Wadge Degree, the Lipschitz Degree, and the Rabin Index of a Regular Language of Infinite Words in Polynomial
Time, in: Lecture Notes in Computer Science, vol. 915, Springer, Berlin, 1995, pp. 288–302.
